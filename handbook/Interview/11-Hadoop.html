<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hadoop | Code Diary</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/learn-ceiling/hand.jpg">
    <meta name="description" content="技术笔记、编程心得分享">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/learn-ceiling/assets/css/0.styles.df47c79f.css" as="style"><link rel="preload" href="/learn-ceiling/assets/js/app.235538a9.js" as="script"><link rel="preload" href="/learn-ceiling/assets/js/2.c7d2b1f7.js" as="script"><link rel="preload" href="/learn-ceiling/assets/js/19.ea21c3cf.js" as="script"><link rel="prefetch" href="/learn-ceiling/assets/js/10.c4c4f495.js"><link rel="prefetch" href="/learn-ceiling/assets/js/11.06c1692d.js"><link rel="prefetch" href="/learn-ceiling/assets/js/12.e70990f1.js"><link rel="prefetch" href="/learn-ceiling/assets/js/13.5ea6f405.js"><link rel="prefetch" href="/learn-ceiling/assets/js/14.5ce76ccb.js"><link rel="prefetch" href="/learn-ceiling/assets/js/15.b5c61832.js"><link rel="prefetch" href="/learn-ceiling/assets/js/16.6e4e0759.js"><link rel="prefetch" href="/learn-ceiling/assets/js/17.b6f52e7f.js"><link rel="prefetch" href="/learn-ceiling/assets/js/18.155f2caf.js"><link rel="prefetch" href="/learn-ceiling/assets/js/20.33c43e06.js"><link rel="prefetch" href="/learn-ceiling/assets/js/21.f4e6e20a.js"><link rel="prefetch" href="/learn-ceiling/assets/js/22.485d0a07.js"><link rel="prefetch" href="/learn-ceiling/assets/js/23.fb805a45.js"><link rel="prefetch" href="/learn-ceiling/assets/js/24.6a258cf5.js"><link rel="prefetch" href="/learn-ceiling/assets/js/25.c4c4023d.js"><link rel="prefetch" href="/learn-ceiling/assets/js/26.d92cf884.js"><link rel="prefetch" href="/learn-ceiling/assets/js/27.5d88d619.js"><link rel="prefetch" href="/learn-ceiling/assets/js/28.a0b76e62.js"><link rel="prefetch" href="/learn-ceiling/assets/js/29.3f0426da.js"><link rel="prefetch" href="/learn-ceiling/assets/js/3.d1fbc4fe.js"><link rel="prefetch" href="/learn-ceiling/assets/js/30.7adccd2c.js"><link rel="prefetch" href="/learn-ceiling/assets/js/31.7d0b9a7f.js"><link rel="prefetch" href="/learn-ceiling/assets/js/32.6970bcc0.js"><link rel="prefetch" href="/learn-ceiling/assets/js/33.eeb35d50.js"><link rel="prefetch" href="/learn-ceiling/assets/js/34.ea24ea8b.js"><link rel="prefetch" href="/learn-ceiling/assets/js/35.c40a585a.js"><link rel="prefetch" href="/learn-ceiling/assets/js/36.79790a12.js"><link rel="prefetch" href="/learn-ceiling/assets/js/37.a847b8a1.js"><link rel="prefetch" href="/learn-ceiling/assets/js/38.9a6ab34d.js"><link rel="prefetch" href="/learn-ceiling/assets/js/39.bf0bc1a7.js"><link rel="prefetch" href="/learn-ceiling/assets/js/4.b6acf418.js"><link rel="prefetch" href="/learn-ceiling/assets/js/40.2e93acfd.js"><link rel="prefetch" href="/learn-ceiling/assets/js/41.bcc213e5.js"><link rel="prefetch" href="/learn-ceiling/assets/js/42.558394fc.js"><link rel="prefetch" href="/learn-ceiling/assets/js/43.cd846378.js"><link rel="prefetch" href="/learn-ceiling/assets/js/44.afcb9063.js"><link rel="prefetch" href="/learn-ceiling/assets/js/45.526cdab6.js"><link rel="prefetch" href="/learn-ceiling/assets/js/46.3bbeeda3.js"><link rel="prefetch" href="/learn-ceiling/assets/js/47.dba7847e.js"><link rel="prefetch" href="/learn-ceiling/assets/js/48.29379048.js"><link rel="prefetch" href="/learn-ceiling/assets/js/49.f526a58a.js"><link rel="prefetch" href="/learn-ceiling/assets/js/5.3747e8f8.js"><link rel="prefetch" href="/learn-ceiling/assets/js/50.2be0a3da.js"><link rel="prefetch" href="/learn-ceiling/assets/js/51.46ccf051.js"><link rel="prefetch" href="/learn-ceiling/assets/js/52.9bcd0722.js"><link rel="prefetch" href="/learn-ceiling/assets/js/53.06fef668.js"><link rel="prefetch" href="/learn-ceiling/assets/js/54.534da4f1.js"><link rel="prefetch" href="/learn-ceiling/assets/js/55.22f59a2a.js"><link rel="prefetch" href="/learn-ceiling/assets/js/56.5b1e2aa6.js"><link rel="prefetch" href="/learn-ceiling/assets/js/57.daacfc08.js"><link rel="prefetch" href="/learn-ceiling/assets/js/58.cb240494.js"><link rel="prefetch" href="/learn-ceiling/assets/js/59.f0cab42c.js"><link rel="prefetch" href="/learn-ceiling/assets/js/6.3688e4ed.js"><link rel="prefetch" href="/learn-ceiling/assets/js/60.74872728.js"><link rel="prefetch" href="/learn-ceiling/assets/js/61.a7a19f44.js"><link rel="prefetch" href="/learn-ceiling/assets/js/62.bda341fd.js"><link rel="prefetch" href="/learn-ceiling/assets/js/63.39847a02.js"><link rel="prefetch" href="/learn-ceiling/assets/js/64.8ac906c5.js"><link rel="prefetch" href="/learn-ceiling/assets/js/7.dddd7af2.js"><link rel="prefetch" href="/learn-ceiling/assets/js/8.4b31d8be.js"><link rel="prefetch" href="/learn-ceiling/assets/js/9.9a27c3e2.js">
    <link rel="stylesheet" href="/learn-ceiling/assets/css/0.styles.df47c79f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><main><main slot="sidebar-top"><a href="https://github.com/25122lxy/" aria-label="View source on GitHub" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path> <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" class="octo-arm" style="transform-origin: 130px 106px;"></path> <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></main> <div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learn-ceiling/" class="home-link router-link-active"><!----> <span class="site-name">Code Diary</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/learn-ceiling/" class="nav-link">
  Index
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Learn" class="dropdown-title"><span class="title">Learn</span> <span class="arrow down"></span></button> <button type="button" aria-label="Learn" class="mobile-dropdown-title"><span class="title">Learn</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/Microservice/01-初识微服务.html" class="nav-link">
  Microservice
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/RabbitMQ/1.RabbitMQ-简介及安装.html" class="nav-link">
  RabbitMQ
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/Redis/0-Redis-Basic.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/SQL/SQL案例.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/前端快速入门/01-HTML-CSS.html" class="nav-link">
  前端快速入门
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/Linux/01-Linux入门.html" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Project" class="dropdown-title"><span class="title">Project</span> <span class="arrow down"></span></button> <button type="button" aria-label="Project" class="mobile-dropdown-title"><span class="title">Project</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/RabbitMQ/1.RabbitMQ-简介及安装.html" class="nav-link">
  社区精品汇
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Interview" class="dropdown-title"><span class="title">Interview</span> <span class="arrow down"></span></button> <button type="button" aria-label="Interview" class="mobile-dropdown-title"><span class="title">Interview</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/00-查漏补缺.html" class="nav-link">
  查漏补缺
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/01-Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/02-Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/03-MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/04-Java框架.html" class="nav-link">
  Java框架
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/05-微服务.html" class="nav-link">
  微服务
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/06-消息中间件.html" class="nav-link">
  消息中间件
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/07-Java集合.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/08-Java并发.html" class="nav-link">
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/09-JVM.html" class="nav-link">
  JVM
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/10-Linux.html" class="nav-link">
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/11-Hadoop.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/12-Hive.html" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/13-Spark.html" class="nav-link">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/16-数据采集工具.html" class="nav-link">
  数据采集工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="lxy25122-blog" class="dropdown-title"><span class="title">lxy25122-blog</span> <span class="arrow down"></span></button> <button type="button" aria-label="lxy25122-blog" class="mobile-dropdown-title"><span class="title">lxy25122-blog</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lxy25122" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/tjlxy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/learn-ceiling/" class="nav-link">
  Index
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Learn" class="dropdown-title"><span class="title">Learn</span> <span class="arrow down"></span></button> <button type="button" aria-label="Learn" class="mobile-dropdown-title"><span class="title">Learn</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/Microservice/01-初识微服务.html" class="nav-link">
  Microservice
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/RabbitMQ/1.RabbitMQ-简介及安装.html" class="nav-link">
  RabbitMQ
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/Redis/0-Redis-Basic.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/SQL/SQL案例.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/前端快速入门/01-HTML-CSS.html" class="nav-link">
  前端快速入门
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/Linux/01-Linux入门.html" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Project" class="dropdown-title"><span class="title">Project</span> <span class="arrow down"></span></button> <button type="button" aria-label="Project" class="mobile-dropdown-title"><span class="title">Project</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Learn/RabbitMQ/1.RabbitMQ-简介及安装.html" class="nav-link">
  社区精品汇
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Interview" class="dropdown-title"><span class="title">Interview</span> <span class="arrow down"></span></button> <button type="button" aria-label="Interview" class="mobile-dropdown-title"><span class="title">Interview</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/00-查漏补缺.html" class="nav-link">
  查漏补缺
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/01-Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/02-Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/03-MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/04-Java框架.html" class="nav-link">
  Java框架
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/05-微服务.html" class="nav-link">
  微服务
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/06-消息中间件.html" class="nav-link">
  消息中间件
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/07-Java集合.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/08-Java并发.html" class="nav-link">
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/09-JVM.html" class="nav-link">
  JVM
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/10-Linux.html" class="nav-link">
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/11-Hadoop.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/12-Hive.html" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/13-Spark.html" class="nav-link">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/learn-ceiling/handbook/Interview/16-数据采集工具.html" class="nav-link">
  数据采集工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="lxy25122-blog" class="dropdown-title"><span class="title">lxy25122-blog</span> <span class="arrow down"></span></button> <button type="button" aria-label="lxy25122-blog" class="mobile-dropdown-title"><span class="title">lxy25122-blog</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lxy25122" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/tjlxy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/learn-ceiling/" aria-current="page" class="sidebar-link">学前必读</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Learn</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Project</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Interview</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-ceiling/handbook/Interview/00-查漏补缺.html" class="sidebar-link">查漏补缺</a></li><li><a href="/learn-ceiling/handbook/Interview/01-Java基础.html" class="sidebar-link">Java基础</a></li><li><a href="/learn-ceiling/handbook/Interview/02-Redis.html" class="sidebar-link">Redis</a></li><li><a href="/learn-ceiling/handbook/Interview/03-MySQL.html" class="sidebar-link">MySQL</a></li><li><a href="/learn-ceiling/handbook/Interview/04-Java框架.html" class="sidebar-link">Java框架</a></li><li><a href="/learn-ceiling/handbook/Interview/05-微服务.html" class="sidebar-link">微服务</a></li><li><a href="/learn-ceiling/handbook/Interview/06-消息中间件.html" class="sidebar-link">消息中间件</a></li><li><a href="/learn-ceiling/handbook/Interview/07-Java集合.html" class="sidebar-link">Java集合</a></li><li><a href="/learn-ceiling/handbook/Interview/08-Java并发.html" class="sidebar-link">Java并发</a></li><li><a href="/learn-ceiling/handbook/Interview/09-JVM.html" class="sidebar-link">JVM</a></li><li><a href="/learn-ceiling/handbook/Interview/10-Linux.html" class="sidebar-link">Linux</a></li><li><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html" aria-current="page" class="active sidebar-link">Hadoop</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#入门" class="sidebar-link">入门</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_1-集群的最主要瓶颈" class="sidebar-link">1.集群的最主要瓶颈</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_2-hadoop运行模式✔" class="sidebar-link">2.Hadoop运行模式✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_3-hadoop生态圈的组件并做简要描述" class="sidebar-link">3.Hadoop生态圈的组件并做简要描述</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_4-解释hadoop和hadoop生态系统两个概念" class="sidebar-link">4.解释Hadoop和Hadoop生态系统两个概念</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_5-请列出正常工作的hadoop集群中需要启动那些进程-它们的作用分别是什么✔" class="sidebar-link">5.请列出正常工作的Hadoop集群中需要启动那些进程，它们的作用分别是什么✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_6-hadoop常用端口号✔" class="sidebar-link">6.Hadoop常用端口号✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#核心配置文件✔" class="sidebar-link">核心配置文件✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#hadoop宕机" class="sidebar-link">Hadoop宕机</a></li></ul></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#hdfs" class="sidebar-link">HDFS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_7-hdfs数据读写流程✔" class="sidebar-link">7.hdfs数据读写流程✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_8-hdfs在读取文件的时候-如果其中一个块突然损坏了怎么办" class="sidebar-link">8.HDFS在读取文件的时候，如果其中一个块突然损坏了怎么办</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_9-hdfs在上传文件的时候-如果其中一个datanode突然挂掉了怎么办" class="sidebar-link">9.HDFS在上传文件的时候，如果其中一个DataNode突然挂掉了怎么办</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_10-namenode在启动的时候会做哪些操作✔" class="sidebar-link">10.NameNode在启动的时候会做哪些操作✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_11-secondarynamenode了解吗-它的工作机制是怎样的-数据持久化-✔" class="sidebar-link">11.SecondaryNameNode了解吗，它的工作机制是怎样的(数据持久化)✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_12-secondarynamenode不能恢复namenode的全部数据-那如何保证namenode数据存储安全-ha高可用" class="sidebar-link">12.SecondaryNameNode不能恢复NameNode的全部数据，那如何保证NameNode数据存储安全(Ha高可用)</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_13-在namenodeha中-会出现脑裂问题吗-怎么解决脑裂" class="sidebar-link">13.在NameNodeHa中，会出现脑裂问题吗？怎么解决脑裂</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_14-小文件过多会有什么危害-如何避免✔" class="sidebar-link">14.小文件过多会有什么危害，如何避免✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_15-请说下hdfs的组织架构✔" class="sidebar-link">15.请说下HDFS的组织架构✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_16-hdfs中的block默认保存几份✔" class="sidebar-link">16.HDFS中的block默认保存几份✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_17-hsds默认blocksize是多大✔" class="sidebar-link">17.HSDS默认BlockSize是多大✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#hdfs的namenode内存" class="sidebar-link">HDFS的NameNode内存</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#纠删码-cpu资源换取存储空间-计算-换-空间" class="sidebar-link">纠删码（CPU资源换取存储空间）计算 换 空间</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#异构存储-不同盘存不同数据-根据实际数据情况" class="sidebar-link">异构存储（不同盘存不同数据，根据实际数据情况）</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#hdfs能不能并发写入" class="sidebar-link">HDFS能不能并发写入</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#hdfs的数据压缩算法" class="sidebar-link">HDFS的数据压缩算法</a></li></ul></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#mapreduce" class="sidebar-link">MapReduce</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#请说下mr中shuffle阶段✔" class="sidebar-link">请说下MR中shuffle阶段✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#shuffle阶段是数据压缩机制了解吗✔" class="sidebar-link">shuffle阶段是数据压缩机制了解吗✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_21-在写mr时-什么情况下可以使用规约" class="sidebar-link">21.在写MR时，什么情况下可以使用规约</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_22-谈谈hadoop序列化和反序列化及自定义bean对象实现序列化" class="sidebar-link">22.谈谈Hadoop序列化和反序列化及自定义bean对象实现序列化</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_23-fileinputformat切片机制" class="sidebar-link">23.FileInputFormat切片机制</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_24-如何判定一个job的map和reduce的数量" class="sidebar-link">24.如何判定一个job的map和reduce的数量</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_25-maptask的个数由什么决定" class="sidebar-link">25.Maptask的个数由什么决定</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_26-maptask和reducetask工作机制-也可回答mapreduce工作原理-✔" class="sidebar-link">26.MapTask和ReduceTask工作机制（也可回答MapReduce工作原理）✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_27-描述mapreduce有几种排序及排序发生的阶段" class="sidebar-link">27.描述mapReduce有几种排序及排序发生的阶段</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_28-描述mapreduce中combiner的作用是什么-一般使用情景-哪些情况不需要-及和reduce的区别" class="sidebar-link">28.描述mapReduce中combiner的作用是什么，一般使用情景，哪些情况不需要，及和reduce的区别</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_29-如果没有定义partitioner-那数据在被送达reducer前是如何被分" class="sidebar-link">29.如果没有定义partitioner，那数据在被送达reducer前是如何被分</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_30-mapreduce出现单点负载多大-怎么负载平衡" class="sidebar-link">30.MapReduce出现单点负载多大，怎么负载平衡</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_31-hadoop的缓存机制-distributedcache" class="sidebar-link">31.Hadoop的缓存机制（Distributedcache）</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_32-如何使用mapreduce实现两个表的join" class="sidebar-link">32.如何使用mapReduce实现两个表的join</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_33-什么样的计算不能用mr来提速" class="sidebar-link">33.什么样的计算不能用mr来提速</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_34-etl是哪三个单词的缩写" class="sidebar-link">34.ETL是哪三个单词的缩写</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#mapreduce2-0容错性" class="sidebar-link">MapReduce2.0容错性</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#mapreduce跑得慢的原因" class="sidebar-link">MapReduce跑得慢的原因</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#mapreduce优化方法-图-✔" class="sidebar-link">MapReduce优化方法(图)✔</a></li></ul></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#yarn" class="sidebar-link">Yarn</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_35-yarn集群的架构和工作原理知道多少✔" class="sidebar-link">35.Yarn集群的架构和工作原理知道多少✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_36-yarn的任务提交流程是怎样的✔" class="sidebar-link">36.YARN的任务提交流程是怎样的✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_37-yarn的资源调度三种模型了解吗✔" class="sidebar-link">37.YARN的资源调度三种模型了解吗✔</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_38-简述hadoop1与hadoop2的架构异同" class="sidebar-link">38.简述hadoop1与hadoop2的架构异同</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#_39-为什么会产生yarn-它解决了什么问题-有什么优势" class="sidebar-link">39.为什么会产生yarn,它解决了什么问题，有什么优势</a></li><li class="sidebar-sub-header"><a href="/learn-ceiling/handbook/Interview/11-Hadoop.html#yarn调优参数✔" class="sidebar-link">Yarn调优参数✔</a></li></ul></li></ul></li><li><a href="/learn-ceiling/handbook/Interview/12-Hive.html" class="sidebar-link">Hive</a></li><li><a href="/learn-ceiling/handbook/Interview/13-Spark.html" class="sidebar-link">Spark</a></li><li><a href="/learn-ceiling/handbook/Interview/16-数据采集工具.html" class="sidebar-link">数据采集工具</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="hadoop"><a href="#hadoop" class="header-anchor">#</a> Hadoop</h1> <h2 id="入门"><a href="#入门" class="header-anchor">#</a> 入门</h2> <h3 id="_1-集群的最主要瓶颈"><a href="#_1-集群的最主要瓶颈" class="header-anchor">#</a> 1.集群的最主要瓶颈</h3> <ul><li>磁盘IO</li></ul> <h3 id="_2-hadoop运行模式✔"><a href="#_2-hadoop运行模式✔" class="header-anchor">#</a> 2.Hadoop运行模式✔</h3> <ul><li>本地模式/单机模式（Local Mode）
<ul><li>在本地模式下，<strong>所有的 Hadoop 组件都在单个 Java 虚拟机（JVM）中运行</strong>，不需要启动 Hadoop 集群。这种模式适用于开发和测试，并且通常用于小规模数据处理。</li> <li>只是用来演示一下官方案例。生产环境不用</li></ul></li> <li>伪分布式模式（Pseudo-Distributed Mode）
<ul><li>在伪分布式模式下，<strong>Hadoop 安装在单个节点上，但每个组件（如 HDFS、YARN 和 MapReduce）都在不同的 JVM 中独立运行</strong>。这样使得用户可以模拟一个真实的分布式环境，用于测试和调试。</li> <li>也是单机运行，<strong>但是具备Hadoop集群的所有功能，一台服务器模拟一个分布式的环境</strong>。个别缺钱的公司用来测试，生产环境不用。</li></ul></li> <li>完全分布式模式（Fully-Distributed Mode）
<ul><li>完全分布式模式是 Hadoop 在真实分布式环境中的运行模式。在这种模式下，<strong>Hadoop 集群由多个节点组成，每个节点都有自己的角色</strong>（如 NameNode、DataNode、ResourceManager、NodeManager 等）。数据和计算任务在整个集群中进行分布和处理。</li> <li><strong>多台服务器组成分布式环境</strong>。生产环境使用。</li></ul></li></ul> <p>在完全分布式模式下，Hadoop 集群的架构通常包括一个主节点（Master Node）和多个从节点（Slave Node）。<strong>主节点负责管理整个集群，从节点负责存储和处理数据</strong>。</p> <p>通过选择适合你的需求的运行模式，你可以在不同规模和场景下使用 Hadoop 进行大数据处理和分析。</p> <h3 id="_3-hadoop生态圈的组件并做简要描述"><a href="#_3-hadoop生态圈的组件并做简要描述" class="header-anchor">#</a> 3.Hadoop生态圈的组件并做简要描述</h3> <ol><li>Zookeeper：<strong>是一个开源的分布式应用程序协调服务</strong>,基于zookeeper可以实现同步服务，配置维护，命名服务。</li> <li>Flume：<strong>一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统。</strong></li> <li>Hbase：<strong>是一个分布式的、面向列的开源数据库</strong>, 利用Hadoop HDFS作为其存储系统。</li> <li>Hive：<strong>基于Hadoop的一个数据仓库工具</strong>，可以将结构化的数据档映射为一张数据库表，并提供简单的sql 查询功能，可以将sql语句转换为MapReduce任务进行运行。</li> <li>Sqoop：<strong>将一个关系型数据库中的数据导进到Hadoop的 HDFS中，也可以将HDFS的数据导进到关系型数据库中。</strong></li></ol> <h3 id="_4-解释hadoop和hadoop生态系统两个概念"><a href="#_4-解释hadoop和hadoop生态系统两个概念" class="header-anchor">#</a> 4.解释Hadoop和Hadoop生态系统两个概念</h3> <ul><li>Hadoop是指Hadoop框架本身；</li> <li>hadoop生态系统，不仅包含hadoop，还包括保证hadoop框架正常高效运行其他框架，比如zookeeper、Flume、Hbase、Hive、Sqoop等辅助框架。</li></ul> <h3 id="_5-请列出正常工作的hadoop集群中需要启动那些进程-它们的作用分别是什么✔"><a href="#_5-请列出正常工作的hadoop集群中需要启动那些进程-它们的作用分别是什么✔" class="header-anchor">#</a> 5.请列出正常工作的Hadoop集群中需要启动那些进程，它们的作用分别是什么✔</h3> <ul><li><p>NameNode</p> <ul><li>管理DataNode、维护所有文件和目录，以Fsimage+Editlog文件的形式永久保存在磁盘上</li> <li>记录每个文件所在的节点信息，不保存，启动时会进行重建</li></ul></li> <li><p>DataNode</p> <ul><li>存储数据块，受client或NameNode调度</li> <li>定期向NameNode发送数据块的信息</li></ul></li> <li><p>SecondAryNameNode<code>定期合并Editlog和FSimage文件，减少NameNode启动时间</code></p></li> <li><p>Resourcemanager<code>调度DataNode</code></p> <ul><li>管理集群上资源的使用</li></ul></li> <li><p>NodeManager<code>执行任务</code></p> <ul><li>运行在集群中所有节点上的节点管理器</li></ul></li> <li><p>ZKFC<code>监控NameNode的状态，写入ZooKeeper中</code>、</p></li> <li><p>JournalNode<code>NameNode的EditLog文件</code></p></li></ul> <h3 id="_6-hadoop常用端口号✔"><a href="#_6-hadoop常用端口号✔" class="header-anchor">#</a> 6.Hadoop常用端口号✔</h3> <table><thead><tr><th></th> <th>HDFS WEB端口</th> <th>YARN WEB端口</th> <th>历史服务器</th> <th>HDFS客户端端口(fs.defaultFS)</th></tr></thead> <tbody><tr><td>2.x</td> <td>50070</td> <td>8088</td> <td>19888</td> <td>8020(9000)</td></tr> <tr><td>3.x</td> <td>9870</td> <td>8088</td> <td>19888</td> <td>8020</td></tr></tbody></table> <h3 id="核心配置文件✔"><a href="#核心配置文件✔" class="header-anchor">#</a> 核心配置文件✔</h3> <table><thead><tr><th>版本号</th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th></tr></thead> <tbody><tr><td>2.x</td> <td>core-site.xml</td> <td>hdfs-site.xml</td> <td>yarn-site.xml</td> <td>mapred-site.xml</td> <td>slaves</td> <td>capacity-scheduler.xml</td></tr> <tr><td>3.x</td> <td>core-site.xml</td> <td>hdfs-site.xml</td> <td>yarn-site.xml</td> <td>mapred-site.xml</td> <td>workers</td> <td>capacity-scheduler.xml</td></tr></tbody></table> <p>查看yarn应用的日志？</p> <ul><li>8088页面点进去</li> <li><code>yarn logs -applicationId appid</code></li></ul> <p>HA</p> <ol><li><p>HDFS HA 会多出那些进程？</p> <p>ZKFC(与ZooKeeper通信)、JournalNode(同步元数据)</p></li> <li><p>YARN HA</p></li></ol> <h3 id="hadoop宕机"><a href="#hadoop宕机" class="header-anchor">#</a> Hadoop宕机</h3> <ul><li>MR：控制Yarn同时运行的任务数</li> <li>写入文件快：控制传输到HDFS的速度</li></ul> <h2 id="hdfs"><a href="#hdfs" class="header-anchor">#</a> HDFS</h2> <h3 id="_7-hdfs数据读写流程✔"><a href="#_7-hdfs数据读写流程✔" class="header-anchor">#</a> 7.hdfs数据读写流程✔</h3> <p><strong>写流程</strong></p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20230910093621054.png" alt="image-20230910093621054"></p> <ol><li>Client 客户端发送上传请求，<strong>通过 RPC(远程过程调用)与 NameNode 建立通信</strong>，NameNode 检查该用户是否有上传权限，以及上传的文件是否在 HDFS 对应的目录下重名，如果这两者有任意一个不满足，则直接报错，如果两者都满足，则 <strong>返回给客户端</strong>一个可以上传的信息；</li> <li>Client 根据文件的大小进行切分，默认 128M 一块，切分完成之后给 NameNode 发送请求第一个 block 块上传到哪些服务器上</li> <li>NameNode 收到请求之后，根据网络拓扑和机架感知以及副本机制进行文件分配，返回可用的 DataNode 的地址；<code>Hadoop 在设计时考虑到数据的安全与高效, **数据文件默认在 HDFS 上存放三份, 存储策略为本地一份，同机架内其它某一节点上一份, 不同机架的某一节点上一份。**</code></li> <li>客户端收到地址之后与服务器地址列表中的一个节点如 A 进行通信，本质上就是 RPC 调用，建立 pipeline(通信管道)，A 收到请求后会继续调用 B，B 在调用 C，将整个 pipeline 建立完成，逐级返回 Client；</li> <li>Client 开始向 A 上发送第一个 block**（先从磁盘读取数据然后放到本地内存缓存），以 packet（数据包，64kb）为单位，A 收到一个 packet 就会发送给 B，然后B发送给C，A每传完一个packet就会放入一个应答队列等待应答**</li> <li>数据被分割成一个个的 packet 数据包在 pipeline 上依次传输，<strong>在pipeline 反向传输中，逐个发送 ack（命令正确应答）</strong>，最终由 pipeline 中第一个 DataNode节点A将pipelineack 发送给 Client</li> <li><strong>当一个block传输完成之后, Client再次请求NameNode上传第二个block， NameNode重新选择三台DataNode给Client。</strong></li></ol> <p><strong>读流程</strong></p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20230910093445328.png" alt="image-20230910093445328"></p> <ol><li>Client向NameNode发送RPC请求请求文件block的位置</li> <li>NameNode 收到请求之后会检查用户权限以及是否有这个文件，如果都符合，则会视情况返回部分或全部的 block 列表，对于每个 block，NameNode 都会返回含有该 block 副本的 DataNode 地址；这些返回的 DataNode 地址， 会按照集群拓扑结构得出 DataNode 与客户端的距离，然后进行排序，排序两个规则：网络拓扑结构中距离 Client 近的排靠前；心跳机制中超时 汇报的 DataNode 状态为 STALE，这样的排靠后；</li> <li>Client 选取排序靠前的DataNode来读取block，如果客户端本身就是 DataNode,那么将从本地直接获取数据(<strong>短路读取特性</strong>)</li> <li>底层上本质是建立SocketStrea（FSDataInputStream），重复的调用父类 DataInputStream的read方法，直到这个块上的数据读取完毕；</li> <li>当读完列表的block后，若文件读取还没有结束，客户端会继续向 NameNode 获取下一批的block列表；</li> <li><strong>读取完一个block都会进行 checksum 验证</strong>，如果读取DataNode时出现错误，客户端会通知NameNode，然后再从<strong>下一个拥有该 block 副本的 DataNode 继续读；</strong></li> <li><strong>read方法是并行的读取block信息，不是一块一块的读取</strong>；NameNode只是返回 Client请求包含块的DataNode地址，并不是返回请求块的数据</li> <li><strong>最终读取来所有的 block 会合并成一个完整的最终文件</strong></li></ol> <h3 id="_8-hdfs在读取文件的时候-如果其中一个块突然损坏了怎么办"><a href="#_8-hdfs在读取文件的时候-如果其中一个块突然损坏了怎么办" class="header-anchor">#</a> 8.HDFS在读取文件的时候，如果其中一个块突然损坏了怎么办</h3> <ul><li>客户端读取完DataNode上的块之后会进行checksum验证，也就是把客户端读取到本地的块与HDFS上的原始快进行校验，如果发现校验结果不一致，客户端会通知NameNode，然后在从下一个拥有该block副本的DataNode继续读</li></ul> <h3 id="_9-hdfs在上传文件的时候-如果其中一个datanode突然挂掉了怎么办"><a href="#_9-hdfs在上传文件的时候-如果其中一个datanode突然挂掉了怎么办" class="header-anchor">#</a> 9.HDFS在上传文件的时候，如果其中一个DataNode突然挂掉了怎么办</h3> <ul><li>在文件上传时，会进行反方向ack验证，如果DataNode挂掉，客户端就接收不到这个DataNode发送的ack确认，客户端就会通知NameNode，NameNode检查该块的副本与规定的不符，NameNode会通知DataNode去复制副本，并将挂掉的DataNode下线处理，不在让他参与文件的上传与下载。</li></ul> <h3 id="_10-namenode在启动的时候会做哪些操作✔"><a href="#_10-namenode在启动的时候会做哪些操作✔" class="header-anchor">#</a> 10.NameNode在启动的时候会做哪些操作✔</h3> <ul><li><p>格式化文件系统，生成FSimage文件</p></li> <li><p>启动NameNode</p> <ul><li>读取Fsimage文件，将文件内容加载到内存</li> <li>等待DataNode发起注册与发送blockreport</li></ul></li> <li><p>启动DataNode</p> <ul><li>向NameNode注册</li> <li>发送blockreport</li> <li>检查Fsimage中记录的块的数量与block中块的数量是否一致</li></ul></li> <li><p>进行操作（创建、删除文件）</p></li> <li><p>第二次启动</p> <ul><li>读取Fsimage和Editlog文件</li> <li>将Fsimage和Editlog文件合并成新的Fsimage文件</li> <li>创建新的Editlog文件，内容开始为空</li> <li>启动DataNode</li></ul></li></ul> <h3 id="_11-secondarynamenode了解吗-它的工作机制是怎样的-数据持久化-✔"><a href="#_11-secondarynamenode了解吗-它的工作机制是怎样的-数据持久化-✔" class="header-anchor">#</a> 11.SecondaryNameNode了解吗，它的工作机制是怎样的(数据持久化)✔</h3> <ul><li>合并NameNode的Editlog到Fsimage文件中</li></ul> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20230910095119496.png" alt="image-20230910095119496"></p> <p>Secondary NameNode 是合并 NameNode 的 edit logs 到 fsimage 文件中； 它的具体工作机制：</p> <ol><li>SecondaryNameNode询问NameNode是否需要checkpoint(检查点)，直接带回NameNode是否检查结果</li> <li>SecondaryNameNode请求执行checkpoint</li> <li>NameNode滚动正在写的edits日志</li> <li>将滚动前的编辑日志(editlog)和镜像文件（Fsimage）拷贝到secondaryNameNode</li> <li>secondaryNameNode加载编辑日志和镜像文件到内存，并合并</li> <li>生成新的镜像文件Fsimage.chkpoint</li> <li>拷贝Fsimage.chkpoint到NameNode</li> <li>NameNode将Fsimage.chcpoint重新命名成fsimage</li></ol> <p>所以如果 NameNode 中的元数据丢失，是可以从 Secondary NameNode 恢复一部分元数据信息的，但不是全部，因为 NameNode正在写的edits日志还没有拷贝到 Secondary NameNode，这部分恢复不了</p> <h3 id="_12-secondarynamenode不能恢复namenode的全部数据-那如何保证namenode数据存储安全-ha高可用"><a href="#_12-secondarynamenode不能恢复namenode的全部数据-那如何保证namenode数据存储安全-ha高可用" class="header-anchor">#</a> 12.SecondaryNameNode不能恢复NameNode的全部数据，那如何保证NameNode数据存储安全(Ha高可用)</h3> <p>这个问题就要说 NameNode 的高可用了，即 NameNode HA</p> <p>一个NameNode有单点故障的问题，那就配置双NameNode，配置有两个关键点，<strong>一是必须要保证这两个 NameNode的元数据信息必须要同步的，二是一个NameNode挂掉之后另一个要立马补上</strong></p> <ol><li><strong>元数据信息同步在 HA 方案中采用的是“共享存储”</strong>。每次写文件时，需要将日志同步写入共享存储，这个步骤成功才能认定写文件成功。然后备份节点定期从共享存储同步日志，以便进行主备切换</li> <li>**监控NameNode状态采用zookeeper，两个NameNode节点的状态存放在zookeeper中，**另外两个NameNode节点分别有一个进程监控程序，实施读取 zookeeper中有NameNode的状态，来判断当前的NameNode是不是已经宕机。如果Standby的 NameNode节点的ZKFC发现主节点已经挂掉，那么就会强制给原本的 Active NameNode节点发送强制关闭请求，之后将备用的 NameNode设置为 Active</li></ol> <h3 id="_13-在namenodeha中-会出现脑裂问题吗-怎么解决脑裂"><a href="#_13-在namenodeha中-会出现脑裂问题吗-怎么解决脑裂" class="header-anchor">#</a> 13.在NameNodeHa中，会出现脑裂问题吗？怎么解决脑裂</h3> <blockquote><p><strong>假设 NameNode1当前为Active状态，NameNode2当前为Standby状态。如果某一时刻 NameNode1对应的ZKFailoverController进程发生了“假死”现象，那么Zookeeper服务端会认为NameNode1挂掉了，根据前面的主备切换逻辑，NameNode2会替代NameNode1 进入 Active状态。但是此时NameNode1可能仍然处于Active状态正常运行，这样 NameNode1和NameNode2都处于 Active状态，都可以对外提供服务。这种情况称为脑裂。</strong></p></blockquote> <ul><li>调用旧ActivateNameNode的HAServiceProtocolRPC接口的<code>transitionToStandby</code>方法</li> <li>ssh登录到目标机器上，执行命令fuser将对应的进程杀死，或者执行一个用户自定义的shell脚本来将对应的进程隔离</li></ul> <h3 id="_14-小文件过多会有什么危害-如何避免✔"><a href="#_14-小文件过多会有什么危害-如何避免✔" class="header-anchor">#</a> 14.小文件过多会有什么危害，如何避免✔</h3> <ol><li><p>危害：</p> <ol><li><p>影响NameNode内存（1个文件块，占用namenode多大内存150字节b）</p> <p>Hadoop上大量HDFS元数据信息存储在NameNode内存中,因此过多的小文件必定会压垮 NameNode的内存。</p></li> <li><p>影响MapTask的数量（浪费资源）</p> <p>每个小文件都会起到一个MapTask，1个MapTask默认内存1G。浪费资源</p></li></ol></li> <li><p>处理</p> <ol><li><p>har归档，将小文件归档</p></li> <li><p>JVM重用：不解决，只是提高效率，一般设置重用10次</p> <ol><li><p>MapTask、ReduceTask都是进程级别，运行在JVM上，因此都要经历：启动JVM，销毁JVM，</p> <p>有小文件场景开启JVM重用；如果没有小文件，不要开启JVM重用，因为会一直占用使用到的task卡槽，直到任务完成才释放。</p> <p>JVM重用可以使得JVM实例在同一个job中重新使用N次，N的值可以在Hadoop的mapred-site.xml文件中进行配置。通常在10-20之间</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>mapreduce.job.jvm.numtasks<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span>How many tasks to run per jvm,if set to -1 ,there is no limit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>  
</code></pre></div><p>从切片的角度：</p></li></ol></li> <li><p><code>CombineTextInputFormat</code>将多个小文件读到一个MapTask中（避免MapTask的数量过多，浪费资源）</p></li> <li><p><strong>启动一个合并任务（reduce的数量）</strong></p></li></ol></li></ol> <h3 id="_15-请说下hdfs的组织架构✔"><a href="#_15-请说下hdfs的组织架构✔" class="header-anchor">#</a> 15.请说下HDFS的组织架构✔</h3> <ul><li><p>client</p> <ul><li>切分文件</li> <li>与NameNode交互，获取文件位置信息</li> <li>与DataNode交互，读取或写入数据</li> <li>管理HDFS</li></ul></li> <li><p>NameNode</p> <ul><li>管理HDFS命名空间</li> <li>管理数据块映射信息</li> <li>管理副本配置策略</li> <li>处理客户端读写请求</li></ul></li> <li><p>DataNode</p> <ul><li>存储实际的数据块</li> <li>执行数据块的读写操作</li></ul></li> <li><p>SecondaryNameNode</p> <ul><li>辅助NamNode，分担其工作量</li> <li>定期合并Fsimage和Editlog文件，减少NameNode启动时间</li> <li>辅助恢复NameNode一部分数据</li></ul></li></ul> <h3 id="_16-hdfs中的block默认保存几份✔"><a href="#_16-hdfs中的block默认保存几份✔" class="header-anchor">#</a> 16.HDFS中的block默认保存几份✔</h3> <ul><li>3、</li></ul> <h3 id="_17-hsds默认blocksize是多大✔"><a href="#_17-hsds默认blocksize是多大✔" class="header-anchor">#</a> 17.HSDS默认BlockSize是多大✔</h3> <p>【64M--Hadoop2.72】【Hadoop2.73--128M】</p> <ol><li><code>2.73</code>之前：64M</li> <li><code>2.74</code>及之后：128M</li> <li><code>hive</code>：256M</li> <li>企业怎么选
<ol><li>一般企业，128M</li> <li>大厂，256M</li></ol></li></ol> <h3 id="hdfs的namenode内存"><a href="#hdfs的namenode内存" class="header-anchor">#</a> HDFS的NameNode内存</h3> <p>1）Hadoop2.x系列，配置NameNode默认2000m</p> <p>2）Hadoop3.x系列，配置NameNode内存是动态分配的</p> <p>​    NameNode内存最小值1G，每增加100万个block，增加1G内存。</p> <h3 id="纠删码-cpu资源换取存储空间-计算-换-空间"><a href="#纠删码-cpu资源换取存储空间-计算-换-空间" class="header-anchor">#</a> 纠删码（CPU资源换取存储空间）计算 换 空间</h3> <ol><li><p>提高存储利用率</p> <ol><li>存100M的文件，3个副本，需要多少存储空间？=》300M的存储空间</li> <li>300M的存储空间，能存多少数据？=》100/300 = 33%（利用率）</li></ol></li> <li><p>企业怎么选</p> <ol><li>一般企业，不开纠删码功能：磁盘 比 CPU便宜</li> <li>大厂，开启纠删码功能：不差钱、提高存储利用率</li></ol></li></ol> <h3 id="异构存储-不同盘存不同数据-根据实际数据情况"><a href="#异构存储-不同盘存不同数据-根据实际数据情况" class="header-anchor">#</a> 异构存储（不同盘存不同数据，根据实际数据情况）</h3> <ol><li>热数据：频繁访问</li> <li>冷数据：很少访问</li> <li>HDFS可以</li></ol> <h3 id="hdfs能不能并发写入"><a href="#hdfs能不能并发写入" class="header-anchor">#</a> HDFS能不能并发写入</h3> <ol><li>不能，并发写入：对于同一个文件来讲只能有一个在写入</li></ol> <p>扩容、缩容</p> <p>白名单、黑名单</p> <h3 id="hdfs的数据压缩算法"><a href="#hdfs的数据压缩算法" class="header-anchor">#</a> HDFS的数据压缩算法</h3> <ul><li>snappy。。。</li></ul> <h2 id="mapreduce"><a href="#mapreduce" class="header-anchor">#</a> MapReduce</h2> <h3 id="请说下mr中shuffle阶段✔"><a href="#请说下mr中shuffle阶段✔" class="header-anchor">#</a> 请说下MR中shuffle阶段✔</h3> <ul><li><p><code>MapTask</code></p></li> <li><ul><li><code>read</code></li> <li><code>map</code></li> <li><strong><code>collect</code></strong></li> <li><strong><code>spill</code></strong></li> <li><strong><code>combine</code></strong></li></ul></li> <li><p><code>ReduceTask</code></p></li> <li><ul><li><strong><code>copy</code></strong></li> <li><strong><code>Merge</code></strong></li> <li><strong><code>Sort</code></strong></li> <li><code>Reduce</code></li></ul></li></ul> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20230911111523509.png" alt="image-20230911111523509"></p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20230911111606386.png" alt="image-20230911111606386"></p> <p>shuffle 是 Mapreduce 的核心，它分布在 Mapreduce 的 map 阶段和 reduce 阶段。一般把从 Map 产生输出开始到 Reduce 取得数据作为输入之前的过程称作 shuffle</p> <ol><li><strong>Collect阶段</strong>：将MapTask的结果输出到默认大小为 100M 的环形缓冲区， 保存的是 key/value，Partition 分区信息等</li> <li><strong>Spill 阶段</strong>：当内存中的数据量达到一定的阀值的时候，就会将数据写入本地磁盘，在将数据写入磁盘之前需要对数据进行一次排序的操作，如果配置了 combiner，还会将有相同分区号和 key 的数据进行排序。</li> <li><strong>MapTask阶段的Merge</strong>：把所有溢出的临时文件进行一次合并操作，以确保一个 MapTask 最终只产生一个中间数据</li> <li><strong>Copy阶段</strong>：ReduceTask 启动 Fetcher 线程到已经完成 MapTask 的节点上复制一份属于自己的数据，<strong>这些数据默认会保存在内存的缓冲区中，当内存的缓冲区达到一定的阀值的时候，就会将数据写到磁盘之上。</strong></li> <li><strong>ReduceTask阶段的Merge</strong>：在ReduceTask 远程复制数据的同时，会在后台开启两个线程对内存到本地的数据文件进行合并操作。</li> <li><strong>Sort阶段</strong>：在对数据进行合并的同时，会进行排序操作，由于 MapTask 阶段已经对数据进行了局部的排序，ReduceTask 只需保证 Copy 的数据的最终整体有效性即可。</li></ol> <h3 id="shuffle阶段是数据压缩机制了解吗✔"><a href="#shuffle阶段是数据压缩机制了解吗✔" class="header-anchor">#</a> shuffle阶段是数据压缩机制了解吗✔</h3> <ul><li>GZip</li> <li>LZO</li> <li>Zippy/<strong>Snappy</strong>（常用）</li></ul> <h3 id="_21-在写mr时-什么情况下可以使用规约"><a href="#_21-在写mr时-什么情况下可以使用规约" class="header-anchor">#</a> 21.在写MR时，什么情况下可以使用规约</h3> <p>规约（combiner）是不能够影响任务的运行结果的局部汇总，适用于求和类，不适用于求平均值，</p> <p>如果reduce的输入参数类型和输出参数类型是一样的，则规约的类可以使用reduce类</p> <h3 id="_22-谈谈hadoop序列化和反序列化及自定义bean对象实现序列化"><a href="#_22-谈谈hadoop序列化和反序列化及自定义bean对象实现序列化" class="header-anchor">#</a> 22.谈谈Hadoop序列化和反序列化及自定义bean对象实现序列化</h3> <ul><li>序列化就是把内存中的对象，转换成字节序列</li> <li>反序列化就是将字节序列或硬盘持久化的数据转换成内存中的对象</li> <li>Java的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带很多额外的信息（各种校验信息，header，继承体系等），不便于在网络中高效传输。所以，hadoop自己开发了一套序列化机制（Writable），精简、高效。</li></ul> <h3 id="_23-fileinputformat切片机制"><a href="#_23-fileinputformat切片机制" class="header-anchor">#</a> 23.FileInputFormat切片机制</h3> <ul><li>按照文件的内容长度进行切片</li> <li>切片大小默认就是block大小（本地模式32，yarn128，老版本64）</li> <li>不考虑数据集整体，针对每个文件单独切片</li></ul> <blockquote><p>​    比如待处理数据有两个文件：</p> <p>​    file1.txt    330M</p> <p>​    file2.txt    10M</p> <p>​    经过FileInputFormat的切片机制运算后，形成的切片信息如下：</p> <p>​    file1.txt.split1--  0~128</p> <p>​    file1.txt.split2--  128~256</p> <p>​    file1.txt.split3--  256~330</p> <p>​    file2.txt.split1--  0~10M</p></blockquote> <h3 id="_24-如何判定一个job的map和reduce的数量"><a href="#_24-如何判定一个job的map和reduce的数量" class="header-anchor">#</a> 24.如何判定一个job的map和reduce的数量</h3> <p>1）map数量</p> <p>splitSize=max{minSize,min{maxSize,blockSize}}</p> <p>map数量由处理的数据分成的block数量决定default_num = total_size / split_size;</p> <p>2）reduce数量</p> <p>reduce的数量job.setNumReduceTasks(x);x 为reduce的数量。不设置的话默认为 1。</p> <h3 id="_25-maptask的个数由什么决定"><a href="#_25-maptask的个数由什么决定" class="header-anchor">#</a> 25.Maptask的个数由什么决定</h3> <p>一个job的map阶段MapTask并行度（个数），由客户端提交job时的切片个数决定。</p> <h3 id="_26-maptask和reducetask工作机制-也可回答mapreduce工作原理-✔"><a href="#_26-maptask和reducetask工作机制-也可回答mapreduce工作原理-✔" class="header-anchor">#</a> 26.MapTask和ReduceTask工作机制（也可回答MapReduce工作原理）✔</h3> <ul><li><code>MapTask</code> <ul><li><code>read</code></li> <li><code>map</code></li> <li><code>collect</code>（快排）</li> <li><code>spill</code></li> <li><code>combine</code>（归并）</li></ul></li></ul> <p>（1）<strong>Read阶段</strong>：Map Task通过用户编写的RecordReader，从输入InputSplit中解析出一个个key/value。</p> <p>（2）<strong>Map阶段</strong>：该节点主要是将解析出的key/value交给用户编写map()函数处理，并产生一系列新的key/value。</p> <p>（3）<strong>Collect收集阶段</strong>：在用户编写map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果。在该函数内部，它会将生成的key/value分区（调用Partitioner），并写入一个环形内存缓冲区中。</p> <p>（4）<strong>Spill阶段</strong>：即“溢写”，当环形缓冲区满后，MapReduce会将数据写到本地磁盘上，生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。</p> <p>（5）<strong>Combine阶段</strong>：当所有数据处理完成后，MapTask对所有临时文件进行一次合并，以确保最终只会生成一个数据文件。</p> <ul><li><code>ReduceTask</code> <ul><li><code>copy</code></li> <li><code>Merge</code></li> <li><code>Sort</code>（归并）</li> <li><code>Reduce</code></li></ul></li></ul> <p>（1）<strong>Copy阶段</strong>：ReduceTask从各个MapTask上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</p> <p>（2）<strong>Merge阶段</strong>：在远程拷贝数据的同时，ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。</p> <p>（3）<strong>Sort阶段</strong>：按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据。为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略。 由于各个MapTask已经实现对自己的处理结果进行了局部排序，因此，ReduceTask只需对所有数据进行一次归并排序即可。</p> <p>（4）<strong>Reduce阶段</strong>：reduce()函数将计算结果写到HDFS上。</p> <h3 id="_27-描述mapreduce有几种排序及排序发生的阶段"><a href="#_27-描述mapreduce有几种排序及排序发生的阶段" class="header-anchor">#</a> 27.描述mapReduce有几种排序及排序发生的阶段</h3> <ul><li>阶段
<ul><li>map发生后在spill后partition前</li> <li>reduce发生在copy后reduce前</li></ul></li></ul> <h3 id="_28-描述mapreduce中combiner的作用是什么-一般使用情景-哪些情况不需要-及和reduce的区别"><a href="#_28-描述mapreduce中combiner的作用是什么-一般使用情景-哪些情况不需要-及和reduce的区别" class="header-anchor">#</a> 28.描述mapReduce中combiner的作用是什么，一般使用情景，哪些情况不需要，及和reduce的区别</h3> <ul><li>对每一个MapTask的输出进行局部汇总，减小网络传输量</li> <li>适用场景：combiner的输出kv应该跟reduce的输入kv类型对应</li> <li>区别：位置不同</li></ul> <h3 id="_29-如果没有定义partitioner-那数据在被送达reducer前是如何被分"><a href="#_29-如果没有定义partitioner-那数据在被送达reducer前是如何被分" class="header-anchor">#</a> 29.如果没有定义partitioner，那数据在被送达reducer前是如何被分</h3> <ul><li>默认partition算法，根据每一条数据的key的hashCode值模运算（%）reduce的数量，得到的数字就是“分区号”</li></ul> <h3 id="_30-mapreduce出现单点负载多大-怎么负载平衡"><a href="#_30-mapreduce出现单点负载多大-怎么负载平衡" class="header-anchor">#</a> 30.MapReduce出现单点负载多大，怎么负载平衡</h3> <ul><li>通过partitioner实现</li></ul> <h3 id="_31-hadoop的缓存机制-distributedcache"><a href="#_31-hadoop的缓存机制-distributedcache" class="header-anchor">#</a> 31.Hadoop的缓存机制（Distributedcache）</h3> <ul><li>分布式缓存
<ul><li>eg：一个大表一个小表，将小表进行广播处理，每个计算节点上都存一份，然后进行map端的连接操作（效率大于reduce端join）</li></ul></li></ul> <h3 id="_32-如何使用mapreduce实现两个表的join"><a href="#_32-如何使用mapreduce实现两个表的join" class="header-anchor">#</a> 32.如何使用mapReduce实现两个表的join</h3> <ul><li><code>reduce side join</code>map阶段同时读取两个文件</li> <li><code>map side join</code>小表直接放入内存，在每个maptask都存一份</li></ul> <blockquote><p>1）reduce side join : 在map阶段，map函数同时读取两个文件File1和File2，为了区分两种来源的key/value数据对，对每条数据打一个标签（tag）,比如：tag=0 表示来自文件File1，tag=2 表示来自文件File2。</p> <p>2）map side join : Map side join 是针对以下场景进行的优化：两个待连接表中，有一个表非常大，而另一个表非常小，以至于小表可以直接存放到内存中。这样，我们可以将小表复制多份，让每个map task 内存中存在一份（比如存放到hash table 中），然后只扫描大表：对于大表中的每一条记录key/value，在hash table 中查找是否有相同的key 的记录，如果有，则连接后输出即可。</p></blockquote> <h3 id="_33-什么样的计算不能用mr来提速"><a href="#_33-什么样的计算不能用mr来提速" class="header-anchor">#</a> 33.什么样的计算不能用mr来提速</h3> <ul><li>数据量很小</li> <li>繁杂的小文件</li> <li>索引是更好的存取机制的时候</li> <li>事务处理</li> <li>只有一台机器的时候</li></ul> <h3 id="_34-etl是哪三个单词的缩写"><a href="#_34-etl是哪三个单词的缩写" class="header-anchor">#</a> 34.ETL是哪三个单词的缩写</h3> <p>Extraction-Transformation-Loading的缩写，中文名称为数据提取、转换和加载。</p> <h3 id="mapreduce2-0容错性"><a href="#mapreduce2-0容错性" class="header-anchor">#</a> MapReduce2.0容错性</h3> <ul><li>MRApplicationMaster	&lt;--	RM</li> <li>MapTask、ReduceTask	&lt;--	AM</li></ul> <h3 id="mapreduce跑得慢的原因"><a href="#mapreduce跑得慢的原因" class="header-anchor">#</a> MapReduce跑得慢的原因</h3> <ul><li><p>计算机性能</p> <ul><li>CPU、磁盘、网络、内存</li></ul></li> <li><p>IO操作优化</p> <ul><li>数据倾斜</li> <li>map、reduce数不合理</li> <li>小文件</li> <li>。。。</li></ul></li></ul> <h3 id="mapreduce优化方法-图-✔"><a href="#mapreduce优化方法-图-✔" class="header-anchor">#</a> MapReduce优化方法(图)✔</h3> <ul><li><p>数据输入</p> <ul><li>合并小文件</li> <li>不影响实际业务的前提下使用combinFileInputFormat，减少map端数据</li></ul></li> <li><p>Map阶段</p> <ul><li>提高环形缓冲区的大小</li> <li>提高环形缓冲区溢出阈值,可以有效减少磁盘IO</li> <li>增加Merge次数，默认10，从而缩短mr处理时间</li> <li>增大mapTask内存、堆内存、CPU核数、重试次数</li></ul></li> <li><p>Reduce阶段</p> <ul><li>合理设置map和reduce数量</li> <li>设置map、reduce共存，减少reduce等待时间</li> <li>提高从map端拉取数据的并行数，默认5</li> <li>提高数据写入磁盘的比例</li> <li>提高reduceTask内存、堆内存、CPU、重试次数</li></ul></li> <li><p><strong>数据倾斜问题</strong></p></li> <li><p>IO传输</p></li></ul> <h2 id="yarn"><a href="#yarn" class="header-anchor">#</a> Yarn</h2> <h3 id="_35-yarn集群的架构和工作原理知道多少✔"><a href="#_35-yarn集群的架构和工作原理知道多少✔" class="header-anchor">#</a> 35.Yarn集群的架构和工作原理知道多少✔</h3> <ul><li><p><code>ResourceManager</code></p> <ul><li>负责整个系统的资源管理和分配，由调度器和应用程序管理器组成</li></ul></li> <li><p><code>ApplicationMaster</code></p> <ul><li>与RM调度器协商以获得资源</li> <li>将得到的任务进一步分配给内部的任务</li> <li>与NodeManager通信以启动/停止任务</li> <li>监控所有的内部任务状态，并在任务运行失败的时候重新为任务申请资源以重启任务</li></ul></li> <li><p><code>NodeManager</code></p> <ul><li>定期向RM汇报本节点上的资源使用情况和各个Container的运行状态</li> <li>接收来自AM的Container启动和停止请求</li></ul></li> <li><p><code>Container</code></p> <ul><li>一个应用程序会分配一个Container</li></ul></li></ul> <h3 id="_36-yarn的任务提交流程是怎样的✔"><a href="#_36-yarn的任务提交流程是怎样的✔" class="header-anchor">#</a> 36.YARN的任务提交流程是怎样的✔</h3> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20230912120745956.png" alt="image-20230912120745956"></p> <ol><li><p>用户向YARN提交一个应用程序，并指定ApplicationMaster程序、启动ApplicationMaster的命令、用户程序。</p></li> <li><p>RM为这个应用程序分配第一个Container，并与之对应的NM通讯，要求它在这个Container中启动应用程序ApplicationMaster</p></li> <li><p>ApplicationMaster向RM注册，然后拆分为内部各个子任务，为各个内部任务申请资源，并监控这些任务的运行，直到结束。</p></li> <li><p>AM采用轮询的方式向RM申请和领取资源</p></li> <li><p>RM为AM分配资源，以Container形式返回</p></li> <li><p>AM申请到资源后，便与之对应的NM通讯，要求NM启动任务。</p></li> <li><p>NodeManager为任务设置好运行环境，将任务启动命令写到一个脚本中，并通过运行这个脚本启动任务。</p></li> <li><p>各个任务向AM汇报自己的状态和进度，以便当任务失败时可以重启任务。</p></li> <li><p>应用程序完成后，ApplicationMaster向ResourceManager注销并关闭自己</p></li></ol> <h3 id="_37-yarn的资源调度三种模型了解吗✔"><a href="#_37-yarn的资源调度三种模型了解吗✔" class="header-anchor">#</a> 37.YARN的资源调度三种模型了解吗✔</h3> <ol><li>FIFO调度器：先进先出，先提交的先分配资源执行</li> <li>容量调度器：多队列，每个队列都是FIFO，可以借用空闲队列的资源</li> <li>公平调度器：多队列，每个队列公平享有资源，按照缺额和权重分配，并发最高</li></ol> <h3 id="_38-简述hadoop1与hadoop2的架构异同"><a href="#_38-简述hadoop1与hadoop2的架构异同" class="header-anchor">#</a> 38.简述hadoop1与hadoop2的架构异同</h3> <ul><li>加入了<code>yarn</code>解决了资源调度的问题</li> <li>加入了对<code>ZooKeeper</code>的支持实现比较可靠的高可用</li></ul> <h3 id="_39-为什么会产生yarn-它解决了什么问题-有什么优势"><a href="#_39-为什么会产生yarn-它解决了什么问题-有什么优势" class="header-anchor">#</a> 39.为什么会产生yarn,它解决了什么问题，有什么优势</h3> <ul><li>解决运行的用户程序与<code>yarn</code>框架完全解耦</li> <li>可以运行各种类型的分布式运算程序</li></ul> <h3 id="yarn调优参数✔"><a href="#yarn调优参数✔" class="header-anchor">#</a> Yarn调优参数✔</h3> <ul><li>NodeManager的资源：内存、CPU</li> <li>容器的资源：最小、最大的 内存、CPU</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/learn-ceiling/handbook/Interview/10-Linux.html" class="prev">
        Linux
      </a></span> <span class="next"><a href="/learn-ceiling/handbook/Interview/12-Hive.html">
        Hive
      </a>
      →
    </span></p></div> </main></div> <div class="footer" data-v-34d4abe6><div id="footer-info" data-v-34d4abe6><div class="footer-left" data-v-34d4abe6>
      © 2023-2024
      <span data-v-34d4abe6><a href="https://github.com/25122lxy/" target="_blank">lxy25122</a></span></div> <div class="footer-right" data-v-34d4abe6>Theme:<a href="https://github.com/JoeyBling/vuepress-theme-yilia-plus" target="_blank">vuepress-theme-yilia-plus</a> by Litten</div></div> <!----></div></main><div class="global-ui"><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/learn-ceiling/assets/js/app.235538a9.js" defer></script><script src="/learn-ceiling/assets/js/2.c7d2b1f7.js" defer></script><script src="/learn-ceiling/assets/js/19.ea21c3cf.js" defer></script>
  </body>
</html>
