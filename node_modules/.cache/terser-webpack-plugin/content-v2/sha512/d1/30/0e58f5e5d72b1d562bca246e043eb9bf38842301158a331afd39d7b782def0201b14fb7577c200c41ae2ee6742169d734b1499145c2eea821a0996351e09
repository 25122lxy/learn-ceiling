{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{416:function(_,v,s){\"use strict\";s.r(v);var e=s(2),a=Object(e.a)({},(function(){var _=this,v=_._self._c;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":_.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"redis\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis\"}},[_._v(\"#\")]),_._v(\" Redis\")]),_._v(\" \"),v(\"h2\",{attrs:{id:\"redis概述\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis概述\"}},[_._v(\"#\")]),_._v(\" Redis概述\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_1-redis是什么-简述它的优缺点\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-redis是什么-简述它的优缺点\"}},[_._v(\"#\")]),_._v(\" 1.Redis是什么？简述它的优缺点？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"redis是一个key-value 类型的内存数据库，很像Memcached，整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存。\")]),_._v(\" \"),v(\"li\",[_._v(\"优点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"读写性能极高，110000次/s,81000次/s\")]),_._v(\" \"),v(\"li\",[_._v(\"支持数据持久化（AOF、RDB）\")]),_._v(\" \"),v(\"li\",[_._v(\"支持事务\")]),_._v(\" \"),v(\"li\",[_._v(\"数据结构丰富，string、list、hash、set、sortset\")]),_._v(\" \"),v(\"li\",[_._v(\"支持主从复制\")]),_._v(\" \"),v(\"li\",[_._v(\"。。\")])])]),_._v(\" \"),v(\"li\",[_._v(\"缺点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"不适用于海量数据的高性能读写\")]),_._v(\" \"),v(\"li\",[_._v(\"主从架构，降低了系统的可用性（主机宕机造成的数据不一致问题）\")])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_2-redis为什么这么快\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-redis为什么这么快\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"2.Redis为什么这么快？\")])],1),_._v(\" \"),v(\"ol\",[v(\"li\",[_._v(\"内存存储，没有磁盘IO上的开销。\")]),_._v(\" \"),v(\"li\",[_._v(\"单线程实现，Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。\")]),_._v(\" \"),v(\"li\",[_._v(\"非阻塞IO\")]),_._v(\" \"),v(\"li\",[_._v(\"优化的数据结构\")]),_._v(\" \"),v(\"li\",[_._v(\"使用底层模型不同，Redis直接自己构建了 VM (虚拟内存)机制\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_3-redis相比memcached有哪些优势\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-redis相比memcached有哪些优势\"}},[_._v(\"#\")]),_._v(\" 3.Redis相比Memcached有哪些优势？\")]),_._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[_._v(\"数据类型\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"Memcached所有的值均是简单的字符串，Redis支持更为丰富的数据类型，支持string(字符串)，list(列表)，Set(集合)、Sorted Set(有序集合)、Hash(哈希)等。\")])])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"持久化\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"Redis支持数据落地持久化存储，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 memcache不支持数据持久存储 。\")])])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"集群模式\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"Redis提供主从同步机制，以及 Cluster集群部署能力，能够提供高可用服务。Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据\")])])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"性能对比\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"网络IO模型\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"Redis使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞IO模式。\")])])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"redis支持服务器端的数据操作\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。\")]),_._v(\" \"),v(\"p\",[_._v(\"这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。\")])])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_4-为什么要用redis做缓存\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-为什么要用redis做缓存\"}},[_._v(\"#\")]),_._v(\" 4.为什么要用redis做缓存？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"高并发\\n\"),v(\"ul\",[v(\"li\",[_._v(\"将部分数据缓存到redis上，避免请求数据库，导致数据库压力过大\")])])]),_._v(\" \"),v(\"li\",[_._v(\"高性能\\n\"),v(\"ul\",[v(\"li\",[_._v(\"第一次请求数据库是从硬盘读取，速度较慢\")]),_._v(\" \"),v(\"li\",[_._v(\"使用Redis后，直接操作内存，速度较快\")])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_5-为什么要用redis而不用map-guava做缓存\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-为什么要用redis而不用map-guava做缓存\"}},[_._v(\"#\")]),_._v(\" 5.为什么要用redis而不用map/guava做缓存？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"速度\")]),_._v(\" \"),v(\"li\",[_._v(\"数量\")]),_._v(\" \"),v(\"li\",[_._v(\"持久化\")]),_._v(\" \"),v(\"li\",[_._v(\"主从\")]),_._v(\" \"),v(\"li\",[_._v(\"稳定性\")]),_._v(\" \"),v(\"li\",[_._v(\"数据类型\")]),_._v(\" \"),v(\"li\",[_._v(\"Redis可单独部署，多个项目之间可以共享，本地内存无法共享\")]),_._v(\" \"),v(\"li\",[_._v(\"Redis有专门的管理工具可以查看缓存数据\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_6-redis的常用场景有哪些\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-redis的常用场景有哪些\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"6.Redis的常用场景有哪些？\")])],1),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"技术上\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"strong\",[_._v(\"缓存：穿透、击穿、雪崩、双写一致、持久化、数据过期、淘汰策略\")])]),_._v(\" \"),v(\"li\",[v(\"strong\",[_._v(\"分布式锁：setnx、redisson\")])]),_._v(\" \"),v(\"li\",[_._v(\"计数器\")]),_._v(\" \"),v(\"li\",[v(\"strong\",[_._v(\"保存token：数据类型\")])]),_._v(\" \"),v(\"li\",[_._v(\"消息队列：数据类型\")]),_._v(\" \"),v(\"li\",[_._v(\"延迟队列：数据类型\")])])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"业务上\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"缓存\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"排行榜\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"计数器\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"分布式会话\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"分布式锁\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"社交网络\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"最新列表\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"消息系统\")])])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_7-redis的数据类型有哪些\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-redis的数据类型有哪些\"}},[_._v(\"#\")]),_._v(\" 7.Redis的数据类型有哪些？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"五种常用的数据类型\\n\"),v(\"ul\",[v(\"li\",[_._v(\"String\")]),_._v(\" \"),v(\"li\",[_._v(\"Hash\")]),_._v(\" \"),v(\"li\",[_._v(\"List\")]),_._v(\" \"),v(\"li\",[_._v(\"Set\")]),_._v(\" \"),v(\"li\",[_._v(\"SortSet\")])])]),_._v(\" \"),v(\"li\",[_._v(\"三种特殊的数据类型\\n\"),v(\"ul\",[v(\"li\",[v(\"code\",[_._v(\"Bitmap\")])]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"Hyperloglog\")])]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"Geospatial\")])])])])]),_._v(\" \"),v(\"h2\",{attrs:{id:\"持久化\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#持久化\"}},[_._v(\"#\")]),_._v(\" 持久化\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_8-redis持久化机制\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-redis持久化机制\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"8.Redis持久化机制\")])],1),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[v(\"code\",[_._v(\"RDB\")]),_._v(\"快照 【Redis Database Backup file（Redis数据备份文件）】\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[v(\"strong\",[_._v(\"简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据（宕机会丢失最后一次快照后的数据）\")])]),_._v(\" \"),v(\"p\",[_._v(\"Redis主动备份\")]),_._v(\" \"),v(\"div\",{staticClass:\"language-shell extra-class\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[v(\"code\",[_._v(\"save \"),v(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[_._v(\"#由Redis主进程来执行RDB，会阻塞所有命令\")]),_._v(\"\\nbgsave \"),v(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[_._v(\"#开启子进程执行RDB，避免主进程受到影响\")]),_._v(\"\\n\")])])]),v(\"p\",[_._v(\"Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：\")]),_._v(\" \"),v(\"div\",{staticClass:\"language-shell extra-class\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[v(\"code\",[v(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[_._v(\"# 900秒内，如果至少有1个key被修改，则执行bgsave \")]),_._v(\"\\nsave \"),v(\"span\",{pre:!0,attrs:{class:\"token number\"}},[_._v(\"900\")]),_._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token number\"}},[_._v(\"1\")]),_._v(\"  \\nsave \"),v(\"span\",{pre:!0,attrs:{class:\"token number\"}},[_._v(\"300\")]),_._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token number\"}},[_._v(\"10\")]),_._v(\"  \\nsave \"),v(\"span\",{pre:!0,attrs:{class:\"token number\"}},[_._v(\"60\")]),_._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token number\"}},[_._v(\"10000\")]),_._v(\" \\n\")])])])])])]),_._v(\" \"),v(\"li\",[v(\"p\",[v(\"code\",[_._v(\"AOF\")]),_._v(\"追加文件【Append Only File（追加文件）】\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"将redis中所有写指令记录写下来，以日志的方式追加后面\")]),_._v(\" \"),v(\"p\",[v(\"strong\",[_._v(\"就是说当redis操作写命令的时候，都会存储这个文件中， 当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复 数据\")])])])])])]),_._v(\" \"),v(\"p\",[_._v(\"RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用AOF来恢复 数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF 文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_9-如何选择合适的持久化方式\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_9-如何选择合适的持久化方式\"}},[_._v(\"#\")]),_._v(\" 9.如何选择合适的持久化方式\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"数据不敏感\\n\"),v(\"ul\",[v(\"li\",[_._v(\"可以关闭持久化\")])])]),_._v(\" \"),v(\"li\",[_._v(\"数据比较重要\\n\"),v(\"ul\",[v(\"li\",[_._v(\"使用\"),v(\"code\",[_._v(\"rdb\")])])])]),_._v(\" \"),v(\"li\",[_._v(\"做内存数据库，使用Redis的持久化\\n\"),v(\"ul\",[v(\"li\",[v(\"code\",[_._v(\"rdb+aof\")])])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_10-redis持久化数据和缓存怎么做扩容\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_10-redis持久化数据和缓存怎么做扩容\"}},[_._v(\"#\")]),_._v(\" 10.Redis持久化数据和缓存怎么做扩容？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。\")]),_._v(\" \"),v(\"li\",[_._v(\"如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。\")])]),_._v(\" \"),v(\"h2\",{attrs:{id:\"过期键的删除策略、淘汰策略\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#过期键的删除策略、淘汰策略\"}},[_._v(\"#\")]),_._v(\" 过期键的删除策略、淘汰策略\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_11-redis过期键的删除策略\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_11-redis过期键的删除策略\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"11.Redis过期键的删除策略\")])],1),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"定时删除\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"过期时间到来时，对其执行删除\")]),_._v(\" \"),v(\"li\",[_._v(\"对CPU不友好，对内存友好\")])])]),_._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[_._v(\"惰性删除\")])]),_._v(\" \"),v(\"p\",[_._v(\"在设置该key过期时间后，我们不去管它，当需要该key 时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"当需要该key时，检查是否过期\")]),_._v(\" \"),v(\"li\",[_._v(\"对内存不友好，对CPU友好\")])])]),_._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[_._v(\"定期删除\")])]),_._v(\" \"),v(\"p\",[_._v(\"就是说每隔一段时间，我们就对一些key进行检查，删 除里面过期的key\")]),_._v(\" \"),v(\"p\",[_._v(\"1、slow模式是定时任务\")]),_._v(\" \"),v(\"p\",[_._v(\"2、fast模式执行频率不固定\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"每隔一段时间，对key进行检查\")]),_._v(\" \"),v(\"li\",[_._v(\"双刃剑\\n\"),v(\"ul\",[v(\"li\",[_._v(\"可以通过限制删除操作执行的时长和频率来减少删除操作对Cpu的影响。另外定期删除，也能有效释放过期键占用的内存\")]),_._v(\" \"),v(\"li\",[_._v(\"难以确定删除操作执行的时长和频率\")])])])])])]),_._v(\" \"),v(\"p\",[_._v(\"惰性删除\\t+\\t定期删除两种策略进行配合使用。\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_12-redis-key的过期时间和永久有效分布怎么设置\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_12-redis-key的过期时间和永久有效分布怎么设置\"}},[_._v(\"#\")]),_._v(\" 12.Redis key的过期时间和永久有效分布怎么设置？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"expire\")]),_._v(\" \"),v(\"li\",[_._v(\"pexpire\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_13-redis内存淘汰策略-缓存过多-内存是有限的-内存被占满了怎么办\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_13-redis内存淘汰策略-缓存过多-内存是有限的-内存被占满了怎么办\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"13.Redis内存淘汰策略\")]),_._v(\"（缓存过多，内存是有限的，内存被占满了怎么办）\")],1),_._v(\" \"),v(\"p\",[_._v(\"当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。\")]),_._v(\" \"),v(\"p\",[_._v(\"Redis支持8种不同策略来选择要删除的key：\")]),_._v(\" \"),v(\"ol\",[v(\"li\",[_._v(\"noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。\")]),_._v(\" \"),v(\"li\",[_._v(\"volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰\")]),_._v(\" \"),v(\"li\",[_._v(\"allkeys-random：对全体key ，随机进行淘汰。\")]),_._v(\" \"),v(\"li\",[_._v(\"volatile-random：对设置了TTL的key ，随机进行淘汰。\")]),_._v(\" \"),v(\"li\",[_._v(\"allkeys-lru： 对全体key，基于LRU算法进行淘汰\")]),_._v(\" \"),v(\"li\",[_._v(\"volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰\")]),_._v(\" \"),v(\"li\",[_._v(\"allkeys-lfu： 对全体key，基于LFU算法进行淘汰\")]),_._v(\" \"),v(\"li\",[_._v(\"volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰\")])]),_._v(\" \"),v(\"blockquote\",[v(\"p\",[v(\"strong\",[_._v(\"LRU\")]),_._v(\"（\"),v(\"strong\",[_._v(\"L\")]),_._v(\"east \"),v(\"strong\",[_._v(\"R\")]),_._v(\"ecently \"),v(\"strong\",[_._v(\"U\")]),_._v(\"sed）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。\")]),_._v(\" \"),v(\"p\",[v(\"strong\",[_._v(\"LFU\")]),_._v(\"（\"),v(\"strong\",[_._v(\"L\")]),_._v(\"east \"),v(\"strong\",[_._v(\"F\")]),_._v(\"requently \"),v(\"strong\",[_._v(\"U\")]),_._v(\"sed）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。\")]),_._v(\" \"),v(\"p\",[v(\"strong\",[_._v(\"数据淘汰策略-使用建议\")])]),_._v(\" \"),v(\"p\",[_._v(\"1.优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。\")]),_._v(\" \"),v(\"p\",[_._v(\"2.如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 allkeys-random，随机选择淘汰。\")]),_._v(\" \"),v(\"p\",[_._v(\"3.如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。\")]),_._v(\" \"),v(\"p\",[_._v(\"4.如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。、\")]),_._v(\" \"),v(\"p\",[v(\"strong\",[_._v(\"关于数据淘汰策略其他的面试问题\")])]),_._v(\" \"),v(\"p\",[_._v(\"1.数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ?\")]),_._v(\" \"),v(\"p\",[_._v(\"使用allkeys-lru(挑选最近最少使用的数据淘汰)淘汰策略，留下来的都是经常访问的热点数据\")]),_._v(\" \"),v(\"p\",[_._v(\"2.Redis的内存用完了会发生什么？\")]),_._v(\" \"),v(\"p\",[_._v(\"主要看数据淘汰策略是什么？如果是默认的配置（ noeviction ），会直接报错\")])]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"code\",[_._v(\"allkeys-lru：\")]),_._v(\"移除最近最少使用的key\")])]),_._v(\" \"),v(\"h2\",{attrs:{id:\"缓存异常\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#缓存异常\"}},[_._v(\"#\")]),_._v(\" 缓存异常\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_14-如何保证缓存与数据库双写时的数据一致性\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_14-如何保证缓存与数据库双写时的数据一致性\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"14.如何保证缓存与数据库双写时的数据一致性\")])],1),_._v(\" \"),v(\"p\",[_._v(\"当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致\")]),_._v(\" \"),v(\"p\",[_._v(\"读操作：\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间\")])]),_._v(\" \"),v(\"p\",[_._v(\"写操作：\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"延迟双删【有脏数据风险】\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"先删除缓存，后更新数据库\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"先更新数据库，后删除缓存\")]),_._v(\" \"),v(\"p\",[_._v(\"延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新 数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。\")])])])]),_._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[_._v(\"Redisson读写锁【强一致、性能低】\")])]),_._v(\" \"),v(\"p\",[_._v(\"在读的时候添加共享锁，可以保证读 读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读 读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免 了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。\\n排他锁底层使用也是setnx，保证了同时只能有一个线程操作 锁住的方法\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"强一致性的，采用Redisson提供的读写锁\")]),_._v(\" \"),v(\"p\",[_._v(\"①共享锁：读锁readLock，加锁之后，其他线程可以共享读操作\")]),_._v(\" \"),v(\"p\",[_._v(\"②排他锁：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作\")])])])]),_._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[_._v(\"异步的方案同步的数据\")]),_._v(\"【最终一致】\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"允许延时一致的业务，采用异步通知\")]),_._v(\" \"),v(\"p\",[_._v(\"①使用MQ中间件，更新数据之后，通知缓存删除\")]),_._v(\" \"),v(\"p\",[_._v(\"②利用canal中间件，不需要修改业务代码，部署 一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据 更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据， 更新缓存即可。\")])])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_15-先删除缓存-后更新数据库\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_15-先删除缓存-后更新数据库\"}},[_._v(\"#\")]),_._v(\" 15.先删除缓存，后更新数据库\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_16-先更新数据库-后删除缓存\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_16-先更新数据库-后删除缓存\"}},[_._v(\"#\")]),_._v(\" 16.先更新数据库，后删除缓存\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_17-什么是缓存击穿\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_17-什么是缓存击穿\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"17.什么是缓存击穿\")])],1),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"高并发访问，某个热点的key失效，无数的请求访问，引起数据库的压力并发。\")]),_._v(\" \"),v(\"p\",[_._v(\"就是说给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过 期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能 会瞬间把 DB 压垮。\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"解决方案\")]),_._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[_._v(\"互斥锁\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"当缓存失效时，不立即去load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db的操作并回设缓存，否则重试get缓存的方法\")]),_._v(\" \"),v(\"li\",[_._v(\"优点：强一致\")]),_._v(\" \"),v(\"li\",[_._v(\"缺点：性能差\")])])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"设置永不过期\")]),_._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[_._v(\"物理不过期，针对热点key不设置过期时间\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"逻辑过期\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"①：在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前 key设置过期时间\")]),_._v(\" \"),v(\"p\",[_._v(\"②：当查询的时候，从redis取出数据后判断时间是否过期\")]),_._v(\" \"),v(\"p\",[_._v(\"③：如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据， 这个数据不是最新\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"优点：高可用，性能优\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"缺点：不能保证数据绝对一致\")])])])])])])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_18-什么是缓存穿透\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_18-什么是缓存穿透\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"18.什么是缓存穿透\")])],1),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"缓存中不存在，数据库中也不存在\")]),_._v(\" \"),v(\"p\",[_._v(\"就是说查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求查数据库\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"解决方案\")]),_._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[_._v(\"缓存空数据\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"查询返回的数据为空，仍把这个空结果进行缓存，将无效的key存放进redis中\")]),_._v(\" \"),v(\"li\",[_._v(\"优点：实现简单，\")]),_._v(\" \"),v(\"li\",[_._v(\"缺点：销毁内存，可能发送不一致的问题\")])])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"使用布隆过滤器\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"查询布隆过滤器，不存在，直接返回，存在（缓存预热时，预热布隆过滤器）查Redis，命中直接放回结果，查不到，查数据库，查到结果，存到Redis并返回结果。\")]),_._v(\" \"),v(\"p\",[_._v(\"布隆过滤器主要是用于检索一个元素是否在一个集合中。\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"优点：内存占用较小，没有多余key\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"缺点：实现复制，存在误判\")])])])])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_19-什么是缓存雪崩\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_19-什么是缓存雪崩\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"19.什么是缓存雪崩\")])],1),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[_._v(\"某一个时刻出现大规模的key失效或Redis宕机，导致大量请求到达数据库，带来巨大压力\")]),_._v(\" \"),v(\"p\",[_._v(\"就是说设置缓存时采用了相同的过期时间，导致缓存在某一时刻同 时失效，请求全部转发到DB，DB 瞬时压力过重雪崩。与缓存击穿的区别： 雪崩是很多key，击穿是某一个key缓存。\")])]),_._v(\" \"),v(\"li\",[v(\"p\",[_._v(\"解决方案\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"strong\",[_._v(\"给不同的key的TTL添加随机值\")]),_._v(\"（主要）\\n\"),v(\"ul\",[v(\"li\",[_._v(\"缓存失效时间分散开，比如可以在原有的失效时间基 础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重 复率就会降低，就很难引发集体失效的事件\")])])]),_._v(\" \"),v(\"li\",[_._v(\"利用Redis集群提高服务的可用性\")]),_._v(\" \"),v(\"li\",[_._v(\"给缓存业务添加降级限流策略\")]),_._v(\" \"),v(\"li\",[_._v(\"给业务添加多级缓存\")])])])]),_._v(\" \"),v(\"p\",[_._v(\"注意：\"),v(\"strong\",[_._v(\"降级限流可做为系统的保底策略，适用于穿透、击穿、雪崩\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_20-什么是缓存预热\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_20-什么是缓存预热\"}},[_._v(\"#\")]),_._v(\" 20.什么是缓存预热\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"指系统上线后，提前将相关的缓存数据加载到缓存系统\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_21-什么是缓存降级\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_21-什么是缓存降级\"}},[_._v(\"#\")]),_._v(\" 21.什么是缓存降级\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"在缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。\")])]),_._v(\" \"),v(\"h2\",{attrs:{id:\"线程模型\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程模型\"}},[_._v(\"#\")]),_._v(\" 线程模型\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_22-redis为何选择单线程\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_22-redis为何选择单线程\"}},[_._v(\"#\")]),_._v(\" 22.Redis为何选择单线程？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"Redis是基于内存操作，执行速度非常快，Redis真正的性能瓶颈在于网络I/O\")]),_._v(\" \"),v(\"li\",[_._v(\"选择单线程的原因\\n\"),v(\"ol\",[v(\"li\",[_._v(\"避免过多的上下文切换开销\\n\"),v(\"ul\",[v(\"li\",[_._v(\"如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。\")])])]),_._v(\" \"),v(\"li\",[_._v(\"简单可维护\\n\"),v(\"ul\",[v(\"li\",[_._v(\"如果 Redis使用多线程模式，那么所有的底层数据结构都必须实现成线程安全的，这无疑又使得 Redis的实现变得更加复杂。\")])])]),_._v(\" \"),v(\"li\",[_._v(\"避免同步机制的开销\\n\"),v(\"ul\",[v(\"li\",[_._v(\"如果 Redis选择多线程模型，又因为 Redis是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，而我们知道 Redis不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等其他丰富的数据结构，而不同的数据结构对同步访问的加锁粒度又不尽相同，可能会导致在操作数据过程中带来很多加锁解锁的开销，增加程序复杂度的同时还会降低性能。\")])])])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_23-redis真的是单线程\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_23-redis真的是单线程\"}},[_._v(\"#\")]),_._v(\" 23.Redis真的是单线程？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"Redis6.0引入多线程I/O，只是用来处理网络数据的读写和协议的解析，而执行命令依旧是单线 程。\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_24-redis6-0为何引入多线程\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_24-redis6-0为何引入多线程\"}},[_._v(\"#\")]),_._v(\" 24.Redis6.0为何引入多线程？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"Redis的单线程模式会导致系统消耗很多CPU，在网络I/O上从而降低吞吐量\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_25-redis6-0采用多线程后-性能提升效果如何\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_25-redis6-0采用多线程后-性能提升效果如何\"}},[_._v(\"#\")]),_._v(\" 25.Redis6.0采用多线程后，性能提升效果如何？\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_26-介绍下redis的线程模型\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_26-介绍下redis的线程模型\"}},[_._v(\"#\")]),_._v(\" 26.介绍下Redis的线程模型\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_27-redis-6-0-多线程的实现机制\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_27-redis-6-0-多线程的实现机制\"}},[_._v(\"#\")]),_._v(\" 27.Redis 6.0 多线程的实现机制？\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_28-redis6-0开启多线程后-是否会存在线程并发安全问题\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_28-redis6-0开启多线程后-是否会存在线程并发安全问题\"}},[_._v(\"#\")]),_._v(\" 28.Redis6.0开启多线程后，是否会存在线程并发安全问题？\")]),_._v(\" \"),v(\"p\",[_._v(\"（不考虑线程安全问题）\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"Redis多线程部分知识用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_29-redis6-0与memcached多线程模型的对比\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_29-redis6-0与memcached多线程模型的对比\"}},[_._v(\"#\")]),_._v(\" 29.Redis6.0与Memcached多线程模型的对比\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"相同点：都采用了Master线程-worker线程的模型\")]),_._v(\" \"),v(\"li\",[_._v(\"不同点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"Memcached执行逻辑也是在worker线程里，模型更加简单，符合线程隔离\")]),_._v(\" \"),v(\"li\",[_._v(\"Redis执行逻辑交给Master线程，增加了模型复杂度，解决了线程并发安全等问题\")])])])]),_._v(\" \"),v(\"h2\",{attrs:{id:\"事务\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事务\"}},[_._v(\"#\")]),_._v(\" 事务\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_30-redis事务的概念\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_30-redis事务的概念\"}},[_._v(\"#\")]),_._v(\" 30.Redis事务的概念\")]),_._v(\" \"),v(\"p\",[_._v(\"1.Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。 鉴于这个原因，所以**说Redis的事务严格意义上来说是不具备原子性的。 **\")]),_._v(\" \"),v(\"ol\",{attrs:{start:\"2\"}},[v(\"li\",[_._v(\"Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送 来的命令请求所打断。\")]),_._v(\" \"),v(\"li\",[_._v(\"在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句 都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务 中的所有命令都会被服务器执行。\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_31-redis事务的三个阶段\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_31-redis事务的三个阶段\"}},[_._v(\"#\")]),_._v(\" 31.Redis事务的三个阶段\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"code\",[_._v(\"multi\")]),_._v(\"开启事务\")]),_._v(\" \"),v(\"li\",[_._v(\"大量指令入队\")]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"exec\")]),_._v(\"执行事务块内命令（截止此处，一个事务已经结束）\")]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"discard\")]),_._v(\"取消事务\")]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"watch\")]),_._v(\"监视一个或多个key，如果事务执行前key被改动，事务将打断，\"),v(\"code\",[_._v(\"unwatch\")]),_._v(\"取消监视。\")]),_._v(\" \"),v(\"li\",[_._v(\"【如果执行过程中，服务端收到其他命令请求，会将请求放入到队列中排队】\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_32-redis事务相关命令\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_32-redis事务相关命令\"}},[_._v(\"#\")]),_._v(\" 32.Redis事务相关命令\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"code\",[_._v(\"Watch\")]),_._v(\"监控一个或多个键，持续到EXEC命令\")]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"Multi\")])]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"Exec\")])]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"Discard\")])]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"UnWatch\")]),_._v(\"取消对所有key的监控\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_33-redis事务支持隔离性吗\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_33-redis事务支持隔离性吗\"}},[_._v(\"#\")]),_._v(\" 33.Redis事务支持隔离性吗？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"Redis是单线程程序，Redis事务总数带有隔离性的\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_34-redis为什么不支持事务回滚\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_34-redis为什么不支持事务回滚\"}},[_._v(\"#\")]),_._v(\" 34.Redis为什么不支持事务回滚？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"strong\",[_._v(\"Redis命令只会因为错误的语法而失败\")]),_._v(\"，或是命令用在了错误类型的键上面，失败的命令是由编程错误造成的，而这些错误应该在开发过程中被发现，而不应该出现在生产环境中\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_35-redis事务其他实现\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_35-redis事务其他实现\"}},[_._v(\"#\")]),_._v(\" 35.Redis事务其他实现\")]),_._v(\" \"),v(\"h2\",{attrs:{id:\"主从、哨兵、集群\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#主从、哨兵、集群\"}},[_._v(\"#\")]),_._v(\" 主从、哨兵、集群\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_36-redis常见使用方式有哪些\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_36-redis常见使用方式有哪些\"}},[_._v(\"#\")]),_._v(\" 36.Redis常见使用方式有哪些？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"单副本\\n\"),v(\"ul\",[v(\"li\",[_._v(\"数据量少适用\")])])]),_._v(\" \"),v(\"li\",[_._v(\"多副本（主从）\\n\"),v(\"ul\",[v(\"li\",[_._v(\"可用性不高，基本不用（master节点挂掉之后需要手动指定新的master）\")])])]),_._v(\" \"),v(\"li\",[_._v(\"Sentinel（哨兵）\\n\"),v(\"ul\",[v(\"li\",[_._v(\"数据量不是很多，集群规模不是很大，需要自动容错的时候适用\")])])]),_._v(\" \"),v(\"li\",[_._v(\"Cluster\\n\"),v(\"ul\",[v(\"li\",[_._v(\"海量数据+高并发+高可用的场景\")])])]),_._v(\" \"),v(\"li\",[_._v(\"自研\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_37-介绍下redis的单副本\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_37-介绍下redis的单副本\"}},[_._v(\"#\")]),_._v(\" 37.介绍下Redis的单副本\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"单个Redis节点部署架构\")]),_._v(\" \"),v(\"li\",[_._v(\"优点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"部署简单\")]),_._v(\" \"),v(\"li\",[_._v(\"性价比高\")]),_._v(\" \"),v(\"li\",[_._v(\"高性能\")])])]),_._v(\" \"),v(\"li\",[_._v(\"缺点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"不能保证数据的可靠性，没有备用节点\")]),_._v(\" \"),v(\"li\",[_._v(\"适合操作命令简单、排序、计算较少的场景\")])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_38-介绍下redis多副本-主从\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_38-介绍下redis多副本-主从\"}},[_._v(\"#\")]),_._v(\" 38.介绍下Redis多副本（主从）\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"主从部署架构，提高数据持久化和备份策略\")]),_._v(\" \"),v(\"li\",[_._v(\"优点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"可靠性高\")]),_._v(\" \"),v(\"li\",[_._v(\"读写分离\")])])]),_._v(\" \"),v(\"li\",[_._v(\"缺点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"故障恢复复杂\")]),_._v(\" \"),v(\"li\",[_._v(\"主库写能力和存储能力受到单机的线程\")])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_39-介绍下redis-sentinel-哨兵\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_39-介绍下redis-sentinel-哨兵\"}},[_._v(\"#\")]),_._v(\" 39.介绍下Redis Sentinel（哨兵）\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"优点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"部署简单\")]),_._v(\" \"),v(\"li\",[_._v(\"高可用\")]),_._v(\" \"),v(\"li\",[_._v(\"可扩展\")]),_._v(\" \"),v(\"li\",[_._v(\"可以实现Sentinel监控\")])])]),_._v(\" \"),v(\"li\",[_._v(\"缺点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"部署相比中从模式要复杂\")]),_._v(\" \"),v(\"li\",[_._v(\"资料浪费\")]),_._v(\" \"),v(\"li\",[_._v(\"不能解决读写分离问题，实现起来相对复杂\")])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_40-介绍下redis-cluster\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_40-介绍下redis-cluster\"}},[_._v(\"#\")]),_._v(\" 40.介绍下Redis Cluster\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"优点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"节点数据共享\")]),_._v(\" \"),v(\"li\",[_._v(\"可扩展\")]),_._v(\" \"),v(\"li\",[_._v(\"高可用\")]),_._v(\" \"),v(\"li\",[_._v(\"降低运维成本\")])])]),_._v(\" \"),v(\"li\",[_._v(\"缺点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"实现复杂\")]),_._v(\" \"),v(\"li\",[_._v(\"。。\")])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_41-介绍下redis自研\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_41-介绍下redis自研\"}},[_._v(\"#\")]),_._v(\" 41.介绍下Redis自研\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"优点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"高可靠、高可用性\")]),_._v(\" \"),v(\"li\",[_._v(\"自主可控性高\")]),_._v(\" \"),v(\"li\",[_._v(\"贴切业务实际需求，可缩性好，兼容性好\")])])]),_._v(\" \"),v(\"li\",[_._v(\"缺点\\n\"),v(\"ul\",[v(\"li\",[_._v(\"实现复杂，开发成本高\")]),_._v(\" \"),v(\"li\",[_._v(\"需要建立配套设施\")]),_._v(\" \"),v(\"li\",[_._v(\"维护成本高\")])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_42-redis高可用方案具体怎么实施\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_42-redis高可用方案具体怎么实施\"}},[_._v(\"#\")]),_._v(\" 42.Redis高可用方案具体怎么实施？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"使用官方推荐的哨兵（sentinel）机制\")]),_._v(\" \"),v(\"li\",[_._v(\"四个功能\\n\"),v(\"ul\",[v(\"li\",[_._v(\"集群监控，负责监控Redis master和slave进程是否正常工作。\")]),_._v(\" \"),v(\"li\",[_._v(\"消息通知，如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。\")]),_._v(\" \"),v(\"li\",[_._v(\"故障转移，如果master node挂掉了，会自动转移到slave node上。\")]),_._v(\" \"),v(\"li\",[_._v(\"配置中心，如果故障转移发生了，通知client客户端新的master地址。\")])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_43-了解主从复制原理吗\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_43-了解主从复制原理吗\"}},[_._v(\"#\")]),_._v(\" 43.了解主从复制原理吗？\")]),_._v(\" \"),v(\"ol\",[v(\"li\",[_._v(\"主从架构的核心原理\\n\"),v(\"ul\",[v(\"li\",[_._v(\"master会启动一个后台线程，开始生成一份RDB快照文件，同时还 会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给 slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命 令发送给slave，slave也会同步这些数据。\")])])]),_._v(\" \"),v(\"li\",[_._v(\"主从复制的断点续传\")]),_._v(\" \"),v(\"li\",[_._v(\"无磁盘化复制\")]),_._v(\" \"),v(\"li\",[_._v(\"过期key处理\\n\"),v(\"ul\",[v(\"li\",[_._v(\"slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。\")])])])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_44-由于主从延迟导致读取到过期数据怎么处理\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_44-由于主从延迟导致读取到过期数据怎么处理\"}},[_._v(\"#\")]),_._v(\" 44.由于主从延迟导致读取到过期数据怎么处理？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"scan（相当于访问该key）\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_45-主从复制的过程中-如果因为网络原因停止复制了会怎么样\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_45-主从复制的过程中-如果因为网络原因停止复制了会怎么样\"}},[_._v(\"#\")]),_._v(\" 45.主从复制的过程中，如果因为网络原因停止复制了会怎么样？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"断点续传，可以接着上次 复制的地方，继续复制下去，而不是从头开始复制一份\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_46-redis主从架构数据会丢失吗-为什么\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_46-redis主从架构数据会丢失吗-为什么\"}},[_._v(\"#\")]),_._v(\" 46.Redis主从架构数据会丢失吗，为什么？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"异步复制导致数据库丢失\")]),_._v(\" \"),v(\"li\",[_._v(\"脑裂导致的数据丢失\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_47-如何解决主从架构数据丢失的问题\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_47-如何解决主从架构数据丢失的问题\"}},[_._v(\"#\")]),_._v(\" 47.如何解决主从架构数据丢失的问题？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[v(\"code\",[_._v(\"min-skaves-to-write 1\")])]),_._v(\" \"),v(\"li\",[v(\"code\",[_._v(\"min-slaves-max-lag 10\")])]),_._v(\" \"),v(\"li\",[_._v(\"至少有一个slave，数据复制和同步的延迟不能超过10秒，否则master就不会再接收任何请求了\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_48-redis哨兵是怎么工作的\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_48-redis哨兵是怎么工作的\"}},[_._v(\"#\")]),_._v(\" 48.Redis哨兵是怎么工作的？\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_49-故障转移时会从剩下的slave选举一个新的master-被选举为master的标准是什么\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_49-故障转移时会从剩下的slave选举一个新的master-被选举为master的标准是什么\"}},[_._v(\"#\")]),_._v(\" 49.故障转移时会从剩下的slave选举一个新的master，被选举为master的标准是什么？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"跟master断开连接的时长\")]),_._v(\" \"),v(\"li\",[_._v(\"slave优先级\")]),_._v(\" \"),v(\"li\",[_._v(\"复制offset\")]),_._v(\" \"),v(\"li\",[_._v(\"run id\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_50-同步配置的时候其他哨兵根据什么更新自己的配置呢\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_50-同步配置的时候其他哨兵根据什么更新自己的配置呢\"}},[_._v(\"#\")]),_._v(\" 50.同步配置的时候其他哨兵根据什么更新自己的配置呢？\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_51-为什么redis哨兵集群只有2个节点无法正常工作\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_51-为什么redis哨兵集群只有2个节点无法正常工作\"}},[_._v(\"#\")]),_._v(\" 51. 为什么Redis哨兵集群只有2个节点无法正常工作？\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_52-redis-cluster中是如何实现数据分布式的-这种方式有什么优点\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_52-redis-cluster中是如何实现数据分布式的-这种方式有什么优点\"}},[_._v(\"#\")]),_._v(\" 52.Redis cluster中是如何实现数据分布式的？这种方式有什么优点？\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_53-redis-cluster节点间通信是什么机制\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_53-redis-cluster节点间通信是什么机制\"}},[_._v(\"#\")]),_._v(\" 53.Redis cluster节点间通信是什么机制？\")]),_._v(\" \"),v(\"h2\",{attrs:{id:\"分布式问题\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分布式问题\"}},[_._v(\"#\")]),_._v(\" 分布式问题\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_54-什么是分布式锁-为什么用分布式锁\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_54-什么是分布式锁-为什么用分布式锁\"}},[_._v(\"#\")]),_._v(\" 54.什么是分布式锁？为什么用分布式锁？\")]),_._v(\" \"),v(\"p\",[_._v(\"锁在程序中的作用就是同步工具，保证共享资源在同一时刻只能被一个线程访问，Java中的锁我们都很熟悉了，像synchronized 、Lock都是我们经常使用的，但是Java的锁只能保证单机的时候有效，分布式集群环境就无能为力了，这个时候我们就需要用到分布式锁。\")]),_._v(\" \"),v(\"p\",[_._v(\"分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源。\")]),_._v(\" \"),v(\"p\",[_._v(\"思路是：在整个系统提供一个\"),v(\"strong\",[_._v(\"全局、唯一\")]),_._v(\"的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。至于这个“东西”，可以是Redis、Zookeeper，也可以是数据库。\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_55-常见的分布式锁有哪些解决方案\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_55-常见的分布式锁有哪些解决方案\"}},[_._v(\"#\")]),_._v(\" 55.常见的分布式锁有哪些解决方案？\")]),_._v(\" \"),v(\"p\",[_._v(\"实现分布式锁目前有三种流行方案，即基于关系型数据库、Redis、ZooKeeper 的方案\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_56-redis实现分布式锁\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_56-redis实现分布式锁\"}},[_._v(\"#\")]),_._v(\" \"),v(\"font\",{attrs:{color:\"00dd00\"}},[_._v(\"56.Redis实现分布式锁\")])],1),_._v(\" \"),v(\"blockquote\",[v(\"p\",[_._v(\"在redis中提供了一个命令setnx(SET if not exists)\")]),_._v(\" \"),v(\"p\",[_._v(\"由于redis的单线程的，用了命令之后，只能有一个客户端对某一个key设置值，在没有过期或删除key的时候是其他客户端是不能设置这个key的\")]),_._v(\" \"),v(\"p\",[v(\"strong\",[_._v(\"如何控制Redis实现分布式锁有效时长呢？\")])]),_._v(\" \"),v(\"p\",[_._v(\"redis的setnx指令不好控制这个问题，我们当时采用的redis的一个框架redisson实现的。\")]),_._v(\" \"),v(\"p\",[_._v(\"在redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在redisson中引入了一个看门狗机制，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了\")]),_._v(\" \"),v(\"p\",[_._v(\"还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户1持有锁的时候，客户2来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。\")]),_._v(\" \"),v(\"p\",[v(\"strong\",[_._v(\"redisson实现的分布式锁是可重入的吗？\")])]),_._v(\" \"),v(\"p\",[_._v(\"是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减一。在存储数据的时候采用的hash结构，大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数\")]),_._v(\" \"),v(\"p\",[v(\"strong\",[_._v(\"redisson实现的分布式锁能解决主从一致性的问题吗\")])]),_._v(\" \"),v(\"p\",[_._v(\"这个是不能的，比如，当线程1加锁成功后，master节点数据会异步复制到slave节点，此时当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。\")]),_._v(\" \"),v(\"p\",[_._v(\"我们可以利用redisson提供的红锁来解决这个问题，它的主要作用是，不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁，并且要求在大多数redis节点上都成功创建锁，红锁中要求是redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。\")]),_._v(\" \"),v(\"p\",[_._v(\"但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁\")]),_._v(\" \"),v(\"p\",[_._v(\"​\\t\"),v(\"strong\",[_._v(\"如果业务非要保证数据的强一致性，这个该怎么解决呢？\")])]),_._v(\" \"),v(\"p\",[_._v(\"redis本身就是支持高可用的，做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用zookeeper实现的分布式锁，它是可以保证强一致性的。\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_57-了解redlock吗\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_57-了解redlock吗\"}},[_._v(\"#\")]),_._v(\" 57.了解RedLock吗？\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_58-redlock的原理\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_58-redlock的原理\"}},[_._v(\"#\")]),_._v(\" 58.RedLock的原理？\")]),_._v(\" \"),v(\"h2\",{attrs:{id:\"其他\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#其他\"}},[_._v(\"#\")]),_._v(\" 其他\")]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_59-redis如何做内存优化\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_59-redis如何做内存优化\"}},[_._v(\"#\")]),_._v(\" 59.Redis如何做内存优化？\")]),_._v(\" \"),v(\"ul\",[v(\"li\",[_._v(\"控制key的数量\")]),_._v(\" \"),v(\"li\",[_._v(\"缩减键值对象（key、value的长度）\")]),_._v(\" \"),v(\"li\",[_._v(\"编码优化\")])]),_._v(\" \"),v(\"h3\",{attrs:{id:\"_60-如果现在有个读超高并发的系统-用redis来抗住大部分读请求-你会怎么设计\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_60-如果现在有个读超高并发的系统-用redis来抗住大部分读请求-你会怎么设计\"}},[_._v(\"#\")]),_._v(\" 60.如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？\")])])}),[],!1,null,null,null);v.default=a.exports}}]);","extractedComments":[]}