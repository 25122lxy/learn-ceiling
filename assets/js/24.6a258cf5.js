(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{338:function(n,t,e){"use strict";e.r(t);var r=e(1),a=Object(r.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"c-小案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#c-小案例"}},[n._v("#")]),n._v(" C++小案例")]),n._v(" "),t("h2",{attrs:{id:"小案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小案例"}},[n._v("#")]),n._v(" 小案例")]),n._v(" "),t("h3",{attrs:{id:"逻辑运算符的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#逻辑运算符的应用"}},[n._v("#")]),n._v(" 逻辑运算符的应用")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(' //案例：从一组数里找出只出现一次的那个数\nint i1 = 5, i2 = 12, i3 = 12, i4 = 9, i5 = 5;\ncout << "只出现一次的那个数为：" << (i1 ^ i2 ^ i3 ^ i4 ^ i5) << endl;\n')])])]),t("h3",{attrs:{id:"if、三元运算符的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#if、三元运算符的应用"}},[n._v("#")]),n._v(" if、三元运算符的应用")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\nint main() {\n    // 输入用户年龄，判断后显示欢迎信息\n    cout << "请输入您的芳龄：" << endl;\n    int age;\n    cin >> age;\n    // 单分支和双分支\n    if (age >= 18) {\n        cout << "欢迎您，成年人！" << endl;\n    } else {\n        cout << "本程序不欢迎未成年人！" << endl;\n    }\n\n    // 使用条件运算符进行实现\n    cout << (age >= 18 ? "欢迎您，成年人！" : "本程序不欢迎未成年人！") << endl;\n}\n')])])]),t("h3",{attrs:{id:"九九乘法表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#九九乘法表"}},[n._v("#")]),n._v(" 九九乘法表")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 使用双重for循环输出九九乘法表\n// i表示行号，j表示列行\nfor (int i = 1; i <= 9; i++) {\n    for (int j = 1; j <= i; j++) {\n        cout << j << "×" << i << "=" << i * j << " ";\n    }\n    cout << endl;\n}\n')])])]),t("h3",{attrs:{id:"判断质数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断质数"}},[n._v("#")]),n._v(" 判断质数")]),n._v(" "),t("p",[n._v("质数也叫素数，是指一个大于1的自然数，因数只有1和它自身。")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\n//  定义一个判断质数的函数，用return返回判断结果\nbool isPrime(int num) {\n    int i = 2;\n    while (i < num) {\n        if (num % i == 0) {\n            return false;\n        }\n        i++;\n        return true;\n    }\n}\n\nvoid prime() {\n    cout << "请输入一个自然数（不超过20亿）" << endl;\n    int num;\n    cin >> num; \n    //指定一个标志数\n    //根据标志位判断结果\n    if (isPrime(num)) {\n        cout << num << "是质数！" << endl;\n    } else {\n        cout << num << "不是质数！" << endl;\n    }\n\n}\t\t\t\n')])])]),t("h3",{attrs:{id:"猜数字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#猜数字"}},[n._v("#")]),n._v(" 猜数字")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\nvoid guess_num() {\n\n    cout << "===========猜数字游戏===========" << endl;\n    cout << "规则：输入0~100的整数，有5次机会\\n" << endl;\n    //猜的次数\n    int n = 0;\n    // 以当前时间为随机数种子，生成一个0~100的伪随机数\n    srand(time(0));\n    int target = rand() % 100;\n\n\n    cout << "请输入0~100的整数：" << endl;\n    int number;\n    while (n < 5) {\n\n        cin >> number;\n        if (number == target) {\n            cout << "恭喜你，猜对了！幸运数字是：" << target << endl;\n        }\n        else if (number < target) {\n            cout << "数字太小了！再猜一遍！" << endl;\n        }\n        else if (number > target) {\n            cout << "数字太大了！再猜一遍！" << endl;\n        }\n        n++;\n    }\n\n    if (n == 5) {\n        cout << "已经猜过5遍，没有猜中！幸运数字是：" << target << "，欢迎下次再来！" << endl;\n    }\n    //cin.get();\n\n\n}\n')])])]),t("h3",{attrs:{id:"爱心曲线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#爱心曲线"}},[n._v("#")]),n._v(" 爱心曲线")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\nvoid heart_fun() {\n\n    // 爱心曲线方程 (x^2+y^2-a)^3 - x^2 y^3 = 0\n    int a = 1;\n    // 定义绘图边界\n    double bound = 1.3 * sqrt(a);\n\n    // x、y坐标变化步长\n    double step = 0.05;\n\n    for (double y = bound; y >= -bound; y -= step * 2) {\n        for (double x = -bound; x <= bound; x += step) {\n            double result = pow((pow(x, 2) + pow(y, 2) - a), 3) - pow(x, 2) * pow(y, 3);\n            if (result <= 0)\n                cout << "*";\n            else\n                cout << " ";\n        }\n        cout << endl;\n    }\n\n\n}\n')])])]),t("h3",{attrs:{id:"选择排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[n._v("#")]),n._v(" 选择排序")]),n._v(" "),t("p",[n._v("从0索引位置元素开始，依次和后面元素进行比较，小的放前面")]),n._v(" "),t("p",[n._v("第一轮比较完后，最小值已经确定，第二轮再从索引1位置（第二个元素）开始依次和后面的元素进行比较，以此类推。。。")]),n._v(" "),t("p",[t("code",[n._v("arr[i] < arr[j]")])]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\nvoid arrsort() {\n    int arr[] = { 9, 2, 4, 3, 12, 6, 1, 5, 7 };\n\n    // 获取数组长度\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    //  选择排序\n    for (int i = 0; i < size - 1; i++)\n    {\n        for (int j = i + 1; j < size ; j++)\n        {\n            if (arr[j] < arr[i])\n            {\n                //  如果arr[j]更小，就和arr[i]交换位置\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    //  输出\n    for (int num : arr) {\n        cout << num << "\\t";\n    }\n\n}\n')])])]),t("h3",{attrs:{id:"冒泡排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[n._v("#")]),n._v(" 冒泡排序")]),n._v(" "),t("p",[n._v("从0索引位置元素开始，相邻两个元素依次比较，大的放后面")]),n._v(" "),t("p",[n._v("第一轮比较完后，最大值已经确定，第二轮再从0索引位置元素开始，两个两个进行比较，以此类推。。。")]),n._v(" "),t("p",[t("code",[n._v("arr[j] > arr[j + 1]")])]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('void maopaosort() {\n\tint arr[] = { 9, 2, 4, 3, 12, 6, 1, 5, 7 };\n\n\t// 获取数组长度\n\tint size = sizeof(arr) / sizeof(arr[0]);\n\n\t//  冒泡排序\n\tfor (int i = 0; i < size - 1; i++)\n\t{\n\t\tfor (int j = 0; j < size - 1 -i; j++)\n\t\t{\n\t\t\tif (arr[j] > arr[j + 1])\n\t\t\t{\n\t\t\t\t//  如果arr[j]更小，就和arr[i]交换位置\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\t//  输出\n\tfor (int num : arr) {\n\t\tcout << num << "\\t";\n\t}\n}\n')])])]),t("h3",{attrs:{id:"读取文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读取文件"}},[n._v("#")]),n._v(" 读取文件")]),n._v(" "),t("p",[n._v("标准库中提供了iostream，可以使用内置的cin对象，调用重载的输入操作符>>来读取键盘输入")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//1、逐词读取\nstring str;\n//读取键盘输入，遇到空白符停止\ncin >> str;\ncout << str;\n//如果我们想读取更多的输入信息，就需要使用更多的string对象来获取\nstring str1, str2;\ncin >> str1 >> str2;\ncout << str1 << str2 << endl;\n\n//2、逐行读取\nstring str3;\ngetline(cin, str3);\ncout << "str3 = " << str3 << endl;\n\n//3、逐字符读取\nchar ch;\nch = cin.get();         // 将捕获到的字符赋值给ch\ncin.get(ch);            // 直接将ch作为参数传给get\n\n// get读取一整行\nchar str4[20];\ncin.get(str4, 20);\ncout << "str4 = " << str4 << endl;\n// get读取一个字符\ncin.get();    // 先读取之前留下的回车符\ncin.get();    // 再等待下一次输入\n\n')])])]),t("p",[n._v("C++的IO库中提供了专门用于文件输入的ifstream类和用于文件输出的ofstream类，要使用它们需要引入头文件fstream。ifstream用于读取文件内容，跟istream的用法类似；也可以通过输入操作符>>来读“单词”（空格分隔），通过getline函数来读取一行，通过get函数来读取一个字符")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('ifstream input("input.txt");\n\n// 逐词读取\nstring word;\nwhile (input >> word) \n    cout << word << endl;\n\n// 逐行读取\nstring line;\nwhile (getline(input, line))\n    cout << line << endl;\n\n// 逐字符读取\nchar ch;\nwhile (input.get(ch))\n    cout << ch << endl;\n//写入文件也可以通过使用输出运算符 << 来实现\nofstream output("output.txt");\noutput << word << endl;\n\n')])])]),t("h3",{attrs:{id:"翻转数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#翻转数组"}},[n._v("#")]),n._v(" 翻转数组")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\n\nvoid reserve() {\n\tconst int n = 8;\n\tint arr[n] = { 1,2,3,4,5,6,7,8 };\n\n\t// 方式一：直接创建一个新数组，遍历元素反向填入\n\tint newArr[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tnewArr[n - i - 1] = arr[i];\n\t}\n\t// 遍历新数组\n\tfor (int num : newArr) {\n\t\tcout << num << "\\t";\n\t}\n\tcout << endl;\n\n\t// 方式二：双指针分别指向数组头尾，元素对调\n\t//定义头指针head，尾指针tail，分别指向第一个元素(arr[0])和最后一个元素(arr[(sizeof arr) - 1])\n\tint head = 0, tail = n - 1; \n\twhile (head < tail) {\n\t\t// 调换位置\n\t\tint temp = arr[head];\n\t\tarr[head] = arr[tail];\n\t\tarr[tail] = temp;\n\n\t\t// 指针向中间移动\n\t\t++head;\n\t\t--tail;\n\t}\n\n\t// 遍历原数组\n\tfor (int num : arr) {\n\t\tcout << num << "\\t";\n\t}\n\n}\n')])])]),t("h3",{attrs:{id:"检验幻方"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#检验幻方"}},[n._v("#")]),n._v(" 检验幻方")]),n._v(" "),t("p",[n._v("“幻方”是数学上一个有趣的问题，它让一组不同的数字构成一个方阵，并且每行、每列、每个对角线的所有数之和相等。比如最简单的三阶幻方，就是把1~9的数字填到九宫格里，要求横看、竖看、斜着看和都是15。")]),n._v(" "),t("p",[n._v("口诀：二四为肩，六八为足，左三右七，戴九履一，五居中央。")]),n._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[n._v("4")]),n._v("\t"),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("9")]),n._v("\t"),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("2")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("3")]),n._v("\t"),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("5")]),n._v("\t"),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("7")]),n._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("8")]),n._v("\t"),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("1")]),n._v("\t"),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("6")]),n._v("\n")])])]),t("p",[n._v("我们可以给定一个n×n的矩阵，也就是二维数组，然后判断它是否是一个幻方")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\nvoid magic() {\n\n\tconst int n = 3;\n\tint arr[n][n] = {\n\t\t{4, 9, 2},\n\t\t{3, 5, 7},\n\t\t{8, 1, 6}\n\t};\n\t// 目标和\n\tint target = (1 + n * n) * n / 2;\n\tbool isMagic = true;\n\n\t// 检验每一行\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tsum += arr[i][j];\n\t\t}\n\t\t// 如果和不是target，说明不是幻方\n\t\tif (sum != target)\n\t\t{\n\t\t\tisMagic = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// 检验每一列\n\tfor (int j = 0; j < n; j++)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tsum += arr[i][j];\n\t\t}\n\t\tif (sum != target)\n\t\t{\n\t\t\tisMagic = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// 检验两个对角线\n\tint sumDiag1 = 0;\n\tint sumDiag2 = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tsumDiag1 += arr[i][i];//左对角线\n\t\tsumDiag2 += arr[i][n - i - 1];//对角线\n\t}\n\tif (sumDiag1 != target || sumDiag2 != target)\n\t{\n\t\tisMagic = false;\n\t}\n\t// 判断结果\n\tcout << "给定的矩阵arr" << (isMagic ? "是" : "不是") << n << "阶幻方！" << endl;\n\n}\n')])])]),t("h3",{attrs:{id:"大整数相加"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大整数相加"}},[n._v("#")]),n._v(" 大整数相加")]),n._v(" "),t("p",[n._v("实际应用中，有时会遇到非常大的整数，可能会超过long、甚至long long的范围。这时就需要用不限长度的字符串保存数据，然后进行计算。")]),n._v(" "),t("p",[n._v("最简单的需求就是“大整数相加”，即给定两个字符串形式的非负大整数 num1 和num2 ，计算它们的和。")]),n._v(" "),t("p",[n._v("我们可以把字符串按每个字符一一拆开，相当于遍历整数上的每一个数位，然后通过“乘10叠加”的方式，就可以整合起来了。这相当于算术中的“竖式加法”。")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\nvoid bigintAdd() {\n\tstring num1 = "32535943020935527435432875";\n\tstring num2 = "9323298429842985843509";\n\n\t// 用一个空字符串保存结果\n\tstring result;\n\n\t// 获取两数个位的索引\n\tint p1 = num1.size() - 1;\n\tint p2 = num2.size() - 1;\n\n\t// 设置一个进位标志\n\tint carry = 0;\n\n\twhile (p1 >= 0 || p2 >= 0 || carry > 0)\t{\n\t\tint x = (p1 >= 0) ? (num1[p1] - \'0\') : 0;//num1的每一位的值\n\t\tint y = (p2 >= 0) ? (num2[p2] - \'0\') : 0;//num2的每一位的值\n\n\t\tint sum = x + y + carry;//将两个数的同一位置的数值进行相加\n\t\tresult += (sum % 10 + \'0\');    // 和的个位写入结果\n\t\tcarry = sum / 10;              // 和的十位保存在进位上\n\n\t\t// 继续遍历下一位\n\t\t--p1;\n\t\t--p2;\n\t}\n\n\t// 结果需要做翻转\n\tint i = 0, j = result.size() - 1;\n\twhile (i < j) {\n\t\tchar temp = result[j];\n\t\tresult[j] = result[i];\n\t\tresult[i] = temp;\n\n\t\t++i;\n\t\t--j;\n\t}\n\n\tcout << num1 << " + " << num2 << endl << endl;\n\tcout << " = " << result;\n\n}\n')])])]),t("h3",{attrs:{id:"旋转图像"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#旋转图像"}},[n._v("#")]),n._v(" 旋转图像")]),n._v(" "),t("p",[n._v("我们可以给定一个二维数组，用来表示一个图像，然后将它顺时针旋转90°。")]),n._v(" "),t("p",[n._v("根据数学上矩阵的特性，可以把矩阵A先做转置得到AT，然后再翻转每一行就可以了。")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\n//旋转图像 顺时针旋转90°\nvoid roate_image() {\n\n    const int n = 4;\n    int image[n][n] = {\n        { 5, 1, 9, 11},\n        { 2, 4, 8, 10},\n        { 13, 3, 6, 7},\n        { 15, 14, 12, 16}\n    };\n    // 矩阵转置\n    for (int i = 0; i < n; i++)\t{\n        for (int j = 0; j <= i; j++){\n            // 以对角线为对称轴，两边互换\n            int tmp = image[i][j];\n            image[i][j] = image[j][i];\n            image[j][i] = tmp;\n        }\n    }\n\n    //每一行翻转\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n/2; j++) {\n            // 以对角线为对称轴，两边互换\n            int tmp = image[i][j];\n            image[i][j] = image[i][n - 1 - j];\n            image[i][n - 1 - j] = tmp;\n        }\n    }\n\n    //打印输出\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\t{\n            cout << image[i][j] << "\\t";\n        }\n        cout << endl;\n    }\n\n}\n')])])]),t("h3",{attrs:{id:"翻转链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#翻转链表"}},[n._v("#")]),n._v(" 翻转链表")]),n._v(" "),t("p",[n._v("链表（Linked List）是一种常见的基础数据结构，它是一种线性表，但是并不会像数组那样按顺序存储数据，而是在每一个节点里存指向下一个节点的指针")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("head\t头结点\t\t\t  中间节点\t。。。\t 尾节点\n[]--\x3e\t[data|next]--\x3e\t[data|next]--\x3e\t[data|null] 空指针：表示链表结尾\n")])])]),t("p",[n._v("对于数组，可以通过下标访问每个元素；如果想要翻转一个数组，只要不停地把头尾元素互换就可以了。")]),n._v(" "),t("p",[n._v("而链表并没有“下标”，所以想要访问元素只能依次遍历；如果要翻转一个链表，关键就在于“next”指针需要反向")]),n._v(" "),t("p",[n._v("可以先定义一个结构体类型ListNode，用来表示链表中的每个节点")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("#pragma once\nstruct ListNode\n{\n\tint value;//当前值\n\tListNode* next;//执行下一个节点的指针（下一个节点的地址）\n};\n")])])]),t("p",[n._v("将结构体TreeNode的定义放在里面，这样之后如果需要使用它，就可以直接引入，实现链表翻转的过程")]),n._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\n#include "list_node.h"//引入头文件\nusing namespace std;\n\n//翻转链表\nvoid reverse() {\n\n    // 定义一个链表 1->2->3->4->5->NULL\n    ListNode node5 = { 5, nullptr };\n    ListNode node4 = { 4, &node5 };\n    ListNode node3 = { 3, &node4 };\n    ListNode node2 = { 2, &node3 };\n    ListNode node1 = { 1, &node2 };\n    ListNode* list = &node1;//指向头结点的 指针（头结点的地址）\n\n    //打印链表\n    ListNode* np = list;//指向第一个节点，\n    while (np) {\n        cout << (*np).value << "->"; //取下一个节点的值\n        np = (*np).next;//取下一个节点的指针\n    }\n    cout << "null" << endl;\n\n    //定义两个指针，一个指向当前遍历的节点，另一个指向之前的节点(上一个)\n    ListNode* curr = list;\n    ListNode* prev = nullptr;\n\n    //翻转链表\n    while (curr) {\n        //先临时保存指向下一个节点的指针\n        ListNode* temp = (*curr).next;\n        //把当前指针指向上一个节点\n        (*curr).next = prev;//第一次 是把头结点的指针指向空值\n        //两个指针都向前移动\n        prev = curr;//把当前的指针给到之前的指针\n        curr = temp;//把下一个指针给到当前的指针\n    }\n    //翻转后的链表 的头结点\n    ListNode* newList = prev;\n    //打印链表\n    np = newList;//指向第一个节点，\n    while (np) {\n        cout << (*np).value << "->"; //取下一个节点的值\n        np = (*np).next;//取下一个节点的指针\n    }\n    cout << "null" << endl;\n\n}\n')])])]),t("h3",{attrs:{id:"二分查找"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二分查找"}},[n._v("#")]),n._v(" 二分查找")]),n._v(" "),t("p",[n._v("核心：每次排除一半的查找范围")]),n._v(" "),t("p",[n._v("1、数据必须是有序的（前提）")]),n._v(" "),t("p",[n._v("2、查找过程：")]),n._v(" "),t("ul",[t("li",[n._v("min和max表示当前要查找的范围")]),n._v(" "),t("li",[n._v("mid在min和max中间的")]),n._v(" "),t("li",[n._v("如果要查找的元素在mid的左边，在缩小范围的时候，min不变，max等于mid减1")]),n._v(" "),t("li",[n._v("如果要查找的元素在mid的右边，在缩小范围的时候，max不变，min等于mid加1")])]),n._v(" "),t("p",[n._v("以下是递归方式：")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\n\n/* \n * 定义一个二分查找函数，递归调用\n * 参数：查找数组、起始位置索引值、结束位置索引值、目标值\n * 返回目标值所在的索引值（位置）\n */\nint binarySearch(const int(&arr)[10], int start, int end, int target) {\n\t\n\t// 基准情况：目标值超出范围，或者start > end，说明没有找到;\n\tif (target < arr[start] || target > arr[end] || start > end)\n\t\treturn -1;\n\n\t// 取二分的中间坐标\n\tint mid = (start + end) / 2;\n\t// 比较中间值和目标值的大小\n\tif (arr[mid] == target)\n\t\treturn mid;        // 找到了\n\telse if (arr[mid] > target)\n\n\t\treturn binarySearch(arr, start, mid - 1, target);    // 比目标值大，在更小的部分找\n\telse\n\t\treturn binarySearch(arr, mid + 1, end, target);      // 比目标值小，在更大的部分找\n\n}\n\n//结果打印\nvoid result() {\n\tint arr[10] = { 1,2,3,4,5,6,9,12,25,38 };\n\n\tint key = 25;\n\tint size = sizeof(arr) / sizeof(arr[0]);\n\tint result = binarySearch(arr, 0, size - 1, key);\n\n\tresult == -1\n\t\t? cout << "在数组中没有找到" << key << "!" << endl\n\t\t: cout << "在数组中找到" << key << "，索引下标为：" << result << endl;\n}\n')])])]),t("h3",{attrs:{id:"快速排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[n._v("#")]),n._v(" 快速排序")]),n._v(" "),t("p",[n._v("第一轮：把0索引的数字作为基准数，确定基准数在数组中正确的位置。比基准数小的全部在左边，比基准数大的全部在右边")]),n._v(" "),t("p",[n._v("后续递归操作，完成排序")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\nusing namespace std;\n\n//声明函数\nint partition(int(&)[10], int, int);\nvoid quickSort(int(&)[10], int, int);\n\nvoid swap(int(&)[10], int, int);\nvoid printArray(const int(&)[10]);\n\n\nvoid quickSort(int(&a)[10], int start, int end) {\n\n\t// 基准情况\n\tif (start >= end)\n\t\treturn;\n\n\tint mid = partition(a, start, end);\n\n\t// 递归调用，分别对两部分继续排序\n\tquickSort(a, start, mid - 1);\n\tquickSort(a, mid + 1, end);\n}\n\n// 按照支点分区的函数\nint partition(int(&a)[10], int start, int end) {\n\t// 选取支点\n\tint pivot = a[start];\n\n\t// 指定指向数组头尾元素的“指针”\n\tint left = start, right = end;\n\n\t// 如果左右指针没有相遇，就继续移动\n\twhile (left < right) {\n\t\t// 左指针不停右移，直到找到一个比支点大的值；右指针不停左移，直到找到一个小的值\n\t\twhile (a[left] <= pivot && left < right)\n\t\t\t++left;\n\t\twhile (a[right] >= pivot && left < right)\n\t\t\t--right;\n\n\t\t// 左右互换\n\t\tswap(a, left, right);\n\t}\n\n\t// 判断指针相遇位置的值，跟支点值的大小关系\n\tif (a[left] <= pivot) {\n\t\t// 比支点值小，就直接换到数组的头位置\n\t\tswap(a, start, left);\n\t\treturn left;\n\t} else if (a[left] > pivot)\t{\n\t\t// 比支点值大，就将前一个位置的元素直接换到数组的头位置\n\t\tswap(a, start, left - 1);\n\t\treturn left - 1;\n\t}\n}\n\n// 交换数组中的两个元素\nvoid swap(int(&a)[10], int i, int j)\n{\n\tint temp = a[i];\n\ta[i] = a[j];\n\ta[j] = temp;\n}\n\n// 打印输出数组\nvoid printArray(const int(&a)[10]) {\n\tfor (int num : a)\n\t\tcout << num << "\\t";\n\n\tcout << endl;\n}\n\nvoid quickSortResult() {\n\tint arr[10] = { 23, 45, 18, 6, 11, 19, 22, 18, 12, 9 };\n\n\tprintArray(arr);\n\n\tint size = sizeof(arr) / sizeof(arr[0]);\n\tquickSort(arr, 0, size - 1);\n\n\tprintArray(arr);\n\n}\n')])])]),t("h3",{attrs:{id:"遍历二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历二叉树"}},[n._v("#")]),n._v(" 遍历二叉树")]),n._v(" "),t("p",[n._v("跟数组不同，树是一种非线性的数据结构，是由n（n >=0）个节点组成的有限集合。如果n==0，树为空树。如果n>0，树有一个特定的节点，叫做根节点（root）。")]),n._v(" "),t("p",[n._v("对于树这种数据结构，使用最频繁的是二叉树。每个节点最多只有2个子节点的树，叫做二叉树。二叉树中，每个节点的子节点作为根的两个子树，一般叫做节点的左子树和右子树。")]),n._v(" "),t("p",[n._v("自定义一个头文件tree_node.h，将结构体TreeNode的定义放在里面：")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("#pragma once\n#include<string>\nusing namespace std;\n\nstruct TreeNode\n{\n\tstring name;\n\tTreeNode* left;\n\tTreeNode* right;\n};\n\nvoid printTreePreOrder(TreeNode* root);\nvoid printTreeInOrder(TreeNode* root);\nvoid printTreePostOrder(TreeNode* root);\n\n")])])]),t("p",[n._v("对于树的遍历，主要有这样三种方式：")]),n._v(" "),t("ul",[t("li",[n._v("先序遍历：先访问根节点，再访问左子树，最后访问右子树；（根、左、右）")]),n._v(" "),t("li",[n._v("中序遍历：先访问左子树，再访问根节点，最后访问右子树；（左、根、右）")]),n._v(" "),t("li",[n._v("后序遍历：先访问左子树，再访问右子树，最后访问根节点。（左、右、根）")])]),n._v(" "),t("p",[n._v("这种遍历方式就隐含了“递归”的思路：左右子树本身又是一棵树，同样需要按照对应的规则来遍历。")]),n._v(" "),t("p",[n._v("实现二叉树的遍历方法")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\n#include "tree_node.h"\n\n// 先序遍历打印二叉树\nvoid printTreePreOrder(TreeNode* root)\n{\n\t// 基准情况，如果是空树，直接返回\n\tif (root == nullptr)    return;\n\n\t//cout << (*root).name << "\\t";\n\tcout << root->name << "\\t";\n\n\t// 递归打印左右子树\n\tprintTreePreOrder(root->left);\n\tprintTreePreOrder(root->right);\n}\n\n// 中序遍历打印二叉树\nvoid printTreeInOrder(TreeNode* root)\n{\n\t// 基准情况，如果是空树，直接返回\n\tif (root == nullptr)    return;\n\n\tprintTreeInOrder(root->left);\n\tcout << root->name << "\\t";\n\tprintTreeInOrder(root->right);\n}\n\n// 后序遍历打印二叉树\nvoid printTreePostOrder(TreeNode* root)\n{\n\t// 基准情况，如果是空树，直接返回\n\tif (root == nullptr)    return;\n\n\tprintTreePostOrder(root->left);\n\tprintTreePostOrder(root->right);\n\tcout << root->name << "\\t";\n}\n\n')])])]),t("p",[n._v("举例定义二叉树调用方法进行遍历")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/tjlxy/img/raw/master/image-20231227183710981.png",alt:"image-20231227183710981"}})]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\n#include "tree_node.h"\n\nint main()\n{\n\t// 定义一棵二叉树\n\tTreeNode nodeG = {"G", nullptr, nullptr};\n\tTreeNode nodeF = { "F", nullptr, nullptr };\n\tTreeNode nodeE = { "E", &nodeG, nullptr };\n\tTreeNode nodeD = { "D", nullptr, nullptr };\n\tTreeNode nodeC = { "C", nullptr, &nodeF};\n\tTreeNode nodeB = { "B", &nodeD, &nodeE };\n\tTreeNode nodeA = { "A", &nodeB, &nodeC };\n\n\tTreeNode* tree = &nodeA;\n\n\tprintTreePreOrder(tree);\n\n\tcout << endl << endl;\n\n\tprintTreeInOrder(tree);\n\n\tcout << endl << endl;\n\n\tprintTreePostOrder(tree);\n\n\tcin.get();\n}\n\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);