(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{331:function(a,r,t){"use strict";t.r(r);var e=t(1),_=Object(e.a)({},(function(){var a=this,r=a._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"spark"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spark"}},[a._v("#")]),a._v(" Spark")]),a._v(" "),r("h2",{attrs:{id:"spark入门"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spark入门"}},[a._v("#")]),a._v(" Spark入门")]),a._v(" "),r("h3",{attrs:{id:"_1-spark的运行流程✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-spark的运行流程✔"}},[a._v("#")]),a._v(" 1.Spark的运行流程✔")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/29617954/1673686098022-0ad1a544-3cc9-468a-a73b-35d659359eab.png#averageHue=%23f6eadc&clientId=u3b80b119-e69c-4&from=paste&height=365&id=u2ea949d8&originHeight=456&originWidth=713&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66950&status=done&style=none&taskId=ub037ff62-02d1-4702-84f8-a512c6da568&title=&width=570.4",alt:"image.png"}})]),a._v(" "),r("ol",[r("li",[a._v("SparkContext向资源管理器注册并向资源管理器申请运行Executor")]),a._v(" "),r("li",[a._v("资源管理器分配Executor，然后资源管理器启动Executor")]),a._v(" "),r("li",[a._v("Executor发送心跳至资源管理器")]),a._v(" "),r("li",[a._v("SparkContext构建DAG有向无环图")]),a._v(" "),r("li",[a._v("将DAG分解成Stage（TaskSet）")]),a._v(" "),r("li",[a._v("把Stage发送给TaskScheduler")]),a._v(" "),r("li",[a._v("Executor向SparkContext申请Task")]),a._v(" "),r("li",[a._v("TaskScheduler将Task发送给Executor运行")]),a._v(" "),r("li",[a._v("同时SparkContext将应用程序代码发放给Executor")]),a._v(" "),r("li",[a._v("Task在Executor上运行，运行完毕释放所有资源")])]),a._v(" "),r("h3",{attrs:{id:"_2-spark有哪些组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-spark有哪些组件"}},[a._v("#")]),a._v(" 2.Spark有哪些组件")]),a._v(" "),r("ul",[r("li",[a._v("master：管理集群和节点，不参与计算。")]),a._v(" "),r("li",[a._v("worker：计算节点，进程本身不参与计算，和master汇报。")]),a._v(" "),r("li",[a._v("driver：运行程序的main方法，创建sparkcontext对象。")]),a._v(" "),r("li",[a._v("sparkcontext：控制整个application的生命周期，包括dagsheduler和taskscheduler等组件。")]),a._v(" "),r("li",[a._v("clinet：用户提交程序的入口。")])]),a._v(" "),r("h3",{attrs:{id:"spark的使用场景✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spark的使用场景✔"}},[a._v("#")]),a._v(" Spark的使用场景✔")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("hive on spark")]),a._v(" "),r("p",[a._v("只把它当作引擎，写的还是hivesql，编译器、解析器、都是hive，只由优化器、执行器是spark")])]),a._v(" "),r("li",[r("p",[a._v("spark on hive")]),a._v(" "),r("p",[a._v("sparksql 去读写 hive 表，只用到了 hive 的元数据，其他编译、解析、优化、执行都是spark自己的")])])]),a._v(" "),r("h3",{attrs:{id:"_33-spark的有几种部署模式-每种模式特点✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_33-spark的有几种部署模式-每种模式特点✔"}},[a._v("#")]),a._v(" 33.spark的有几种部署模式，每种模式特点✔")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("local，测试")]),a._v(" "),r("ul",[r("li",[a._v("将 Spark 应用以多线程的方式之间运行在本地（local:启动一个executor。local[k]:启动k歌executor。local[*]：启动跟CPU数目相同的executor）")])])]),a._v(" "),r("li",[r("p",[a._v("standalone，自己管资源")]),a._v(" "),r("ul",[r("li",[a._v("分布式部署集群，自带完整服务，资源管理和任务监控是Spark自己监控")])])]),a._v(" "),r("li",[r("p",[r("strong",[a._v("yarn")]),a._v("，yarn管资源")]),a._v(" "),r("ul",[r("li",[a._v("client，driver在提交节点启动，适合生产")]),a._v(" "),r("li",[a._v("cluster，driver由yarn决定在哪启动，适合调试")])])]),a._v(" "),r("li",[r("p",[a._v("mesos，国外用")])]),a._v(" "),r("li",[r("p",[a._v("k8s，未来趋势")])])]),a._v(" "),r("h3",{attrs:{id:"_104-spark-常用端口号✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_104-spark-常用端口号✔"}},[a._v("#")]),a._v(" 104.Spark 常用端口号✔")]),a._v(" "),r("p",[r("strong",[a._v("1）4040 spark-shell任务端口")]),a._v("\n2）7077 内部通讯端口。类比Hadoop的8020\n3）8080 查看任务执行情况端口。类比Hadoop的8088\n"),r("strong",[a._v("4）18080 历史服务器。类比Hadoop的19888")]),a._v("\n注意：由于Spark只负责计算，所有并没有Hadoop中存储数据的端口50070")]),a._v(" "),r("h2",{attrs:{id:"sparkcore"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sparkcore"}},[a._v("#")]),a._v(" SparkCore")]),a._v(" "),r("h3",{attrs:{id:"_3-spark中rdd机制理解吗✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-spark中rdd机制理解吗✔"}},[a._v("#")]),a._v(" 3.Spark中RDD机制理解吗✔")]),a._v(" "),r("ul",[r("li",[a._v("数据结构、hdfs文件、集合")]),a._v(" "),r("li",[a._v("分布式弹性数据集")])]),a._v(" "),r("p",[r("strong",[a._v("rdd分布式弹性数据集，简单的理解成一种数据结构")]),a._v("，是spark框架上的通用货币。所有算子都是基于rdd来执行的，不同的场景会有不同的rdd实现类，但是都可以进行互相转换。rdd执行过程中会形成dag图，然后形成lineage保证容错性等。 从物理的角度来看rdd存储的是block和node之间的映射。"),r("strong",[a._v("RDD是spark提供的核心抽象，全称为弹性分布式数据集")]),a._v("。")]),a._v(" "),r("p",[r("strong",[a._v("RDD在逻辑上是一个hdfs文件，在抽象上是一种元素集合，包含了数据。它是被分区的，分为多个分区，每个分区分 布在集群中的不同结点上，从而让RDD中的数据可以被并行操作（分布式数据集）")])]),a._v(" "),r("p",[a._v("比如有个RDD有90W数据，3个partition，则每个分区上有30W数据。RDD通常通过Hadoop上的文件，即HDFS或 者HIVE表来创建，还可以通过应用程序中的集合来创建；"),r("strong",[a._v("RDD最重要的特性就是容错性，可以自动从节点失败中恢复过来")]),a._v("。即如果某个结点上的RDDpartition因为节点故障，导致数据丢失，那么RDD可以通过自己的数据来源重新计算该 partition。这一切对使用者都是透明的。")]),a._v(" "),r("p",[r("strong",[a._v("RDD的数据默认存放在内存中，但是当内存资源不足时，spark会自动将RDD数据写入磁盘")]),a._v("。比如某结点内存只能处理20W数据，那么这20W数据就会放入内存中计算，剩下10W放到磁盘中。"),r("strong",[a._v("RDD的弹性体现在于RDD上自动进行内存和磁盘之间权衡和切换的机制")]),a._v("。")]),a._v(" "),r("h3",{attrs:{id:"_4-rdd中reducebykey与groupbykey那个性能好-为什么✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-rdd中reducebykey与groupbykey那个性能好-为什么✔"}},[a._v("#")]),a._v(" 4.RDD中reduceByKey与groupByKey那个性能好，为什么✔")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("reduceByKey")]),a._v("发生在Map阶段，具有预聚合操作，既对数据重分区，也根据reduce 逻辑聚合，会shuffle")]),a._v(" "),r("li",[a._v("groupByKey发生在Reduce阶段，具有预聚合操作，只对数据重分区，不计算，会shuffle")])]),a._v(" "),r("p",[r("strong",[a._v("reduceByKey")]),a._v("：reduceByKey会在结果发送至reducer之前会对每个mapper在本地进行merge，有点类似于在 MapReduce中的combiner。这样做的好处在于，在map端进行一次reduce之后，数据量会大幅度减小，从而减小传输， 保证reduce端能够更快的进行结果计算。")]),a._v(" "),r("p",[r("strong",[a._v("groupByKey")]),a._v("：groupByKey会对每一个RDD中的value值进行聚合形成一个序列(Iterator)，此操作发生在reduce端，所以 势必会将所有的数据通过网络进行传输，造成不必要的浪费。同时如果数据量十分大，可能还会造成 OutOfMemoryError。所以在进行大量数据的reduce操作时候建议使用reduceByKey。不仅可以提高速度，还可以防止使 用groupByKey造成的内存溢出问题。")]),a._v(" "),r("h3",{attrs:{id:"_5-介绍一下cogrouprdd实现原理-你再什么场景下用过这个rdd"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-介绍一下cogrouprdd实现原理-你再什么场景下用过这个rdd"}},[a._v("#")]),a._v(" 5.介绍一下cogroupRdd实现原理，你再什么场景下用过这个rdd")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("cogroupRdd（合并RDD）")]),a._v(" "),r("ul",[r("li",[a._v("对多个（2~4）RDD中的KV元素，每个RDD中相同key中的元素分别聚合成一个集合。")]),a._v(" "),r("li",[a._v("与reduceByKey不同的是：reduceByKey针对一个RDD中相同的key进行合并。而"),r("strong",[a._v("cogroup针对多个RDD中相同的key的 元素进行合并。")])])])]),a._v(" "),r("li",[r("p",[a._v("使用场景：表关联查询或处理重复的key")])])]),a._v(" "),r("h3",{attrs:{id:"_6-如何区分rdd的宽窄依赖✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-如何区分rdd的宽窄依赖✔"}},[a._v("#")]),a._v(" 6.如何区分RDD的宽窄依赖✔")]),a._v(" "),r("p",[a._v("窄依赖：父RDD的一个分区只会被子RDD的一个分区依赖；")]),a._v(" "),r("p",[a._v("宽依赖：父RDD的一个分区会被子RDD的多个分区依赖("),r("strong",[a._v("涉及到shuffle")]),a._v(")。")]),a._v(" "),r("h3",{attrs:{id:"_7-为什么要设计宽窄依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-为什么要设计宽窄依赖"}},[a._v("#")]),a._v(" 7.为什么要设计宽窄依赖")]),a._v(" "),r("p",[a._v("对于窄依赖： 窄依赖的多个分区可以并行计算； 窄依赖的一个分区的数据如果丢失只需要重新计算对应的分区的数据就可以了。")]),a._v(" "),r("p",[a._v("对于宽依赖： 划分Stage(阶段)的依据:对于宽依赖,必须等到上一阶段计算完成才能计算下一阶段")]),a._v(" "),r("h3",{attrs:{id:"_8-dag是什么-localhost-4040-✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-dag是什么-localhost-4040-✔"}},[a._v("#")]),a._v(" 8.DAG是什么（localhost:4040）✔")]),a._v(" "),r("p",[a._v("DAG(DirectedAcyclicGraph有向无环图)指的是数据转换执行的过程，有方向，无闭环("),r("strong",[a._v("其实就是RDD执行的流程")]),a._v(")；")]),a._v(" "),r("p",[r("strong",[a._v("原始的RDD通过一系列的转换操作就形成了DAG有向无环图")]),a._v("，任务执行时，可以按照DAG的描述，执行真正的计算 (数据被操作的一个过程)。")]),a._v(" "),r("h3",{attrs:{id:"_9-dag中为什么要划分stage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-dag中为什么要划分stage"}},[a._v("#")]),a._v(" 9.DAG中为什么要划分Stage")]),a._v(" "),r("p",[r("strong",[a._v("并行计算")])]),a._v(" "),r("p",[a._v("一个复杂的业务逻辑如果有shuffle，那么就意味着前面阶段产生结果后，才能执行下一个阶段，即下一个阶段的计算要依 赖上一个阶段的数据。那么我们按照shuffle进行划分(也就是按照宽依赖进行划分)，就可以将一个DAG划分成多个Stage/ 1. 2. 1. 阶段，在同一个Stage中，会有多个算子操作，可以形成一个pipeline流水线，流水线内的多个平行的分区可以并行执行。")]),a._v(" "),r("h3",{attrs:{id:"_10-如何划分dag的stage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-如何划分dag的stage"}},[a._v("#")]),a._v(" 10.如何划分DAG的stage")]),a._v(" "),r("p",[r("strong",[a._v("对于窄依赖")]),a._v("，partition的转换处理在stage中完成计算，不划分(将窄依赖尽量放在在同一个stage中，可以实现流水线计算)。")]),a._v(" "),r("p",[r("strong",[a._v("对于宽依赖")]),a._v("，由于有shuffle的存在，只能在父RDD处理完成后，才能开始接下来的计算，也就是说需要要划分stage。")]),a._v(" "),r("h3",{attrs:{id:"_11-spark中的oom的问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-spark中的oom的问题"}},[a._v("#")]),a._v(" 11.Spark中的OOM的问题")]),a._v(" "),r("ul",[r("li",[a._v("Map类型算子\n"),r("ul",[r("li",[a._v("增加堆内内存")]),a._v(" "),r("li",[a._v("减少每个task处理的数量")])])]),a._v(" "),r("li",[a._v("Shuffle后\n"),r("ul",[r("li",[a._v("修改实际代码")])])]),a._v(" "),r("li",[a._v("Driver\n"),r("ul",[r("li",[a._v("将大对象转换成Executor端加载，增加driver端内存")])])])]),a._v(" "),r("h3",{attrs:{id:"_12-spark中数据的位置被谁管理的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-spark中数据的位置被谁管理的"}},[a._v("#")]),a._v(" 12.Spark中数据的位置被谁管理的")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("blockManger")])])]),a._v(" "),r("p",[a._v("每个数据分片都对于具体物理位置，"),r("strong",[a._v("数据的位置是被blockManager管理")]),a._v("，无论数据是在磁盘，内存还是tacyan，都是由blockManager管理。")]),a._v(" "),r("h3",{attrs:{id:"_13-spark程序执行-有时候默认为什么会产生很多task-怎么修改默认task执行个数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_13-spark程序执行-有时候默认为什么会产生很多task-怎么修改默认task执行个数"}},[a._v("#")]),a._v(" 13.Spark程序执行，有时候默认为什么会产生很多task，怎么修改默认task执行个数")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("SPARK_HOME/conf/spark-default.conf")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("spark.sql.shuffle.partitions=50")])]),a._v(" "),r("li",[r("code",[a._v("spark.default.paralleism=10")])])])])]),a._v(" "),r("h3",{attrs:{id:"_14-spark与mapreduce的shuffle的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_14-spark与mapreduce的shuffle的区别"}},[a._v("#")]),a._v(" 14.Spark与MapReduce的Shuffle的区别")]),a._v(" "),r("ul",[r("li",[a._v("MapReduce默认排序，Spark不排序，可以使用sortByKey")]),a._v(" "),r("li",[a._v("MapReduce只有Map和Reduce两个阶段，比较局限，Spark更灵活")]),a._v(" "),r("li",[a._v("MapReduce落盘，spark不落盘")])]),a._v(" "),r("h3",{attrs:{id:"_17-通常来说-spark与mapreduce相比-spark运行效率更高。请说明效率更高来源于spark内置的哪些机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-通常来说-spark与mapreduce相比-spark运行效率更高。请说明效率更高来源于spark内置的哪些机制"}},[a._v("#")]),a._v(" 17.通常来说，Spark与MapReduce相比，Spark运行效率更高。请说明效率更高来源于Spark内置的哪些机制")]),a._v(" "),r("ul",[r("li",[a._v("DAG")]),a._v(" "),r("li",[a._v("Linage")]),a._v(" "),r("li",[a._v("基于内存")])]),a._v(" "),r("h3",{attrs:{id:"_18-hadoop和spark的相同点和不同点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_18-hadoop和spark的相同点和不同点"}},[a._v("#")]),a._v(" 18.Hadoop和Spark的相同点和不同点")]),a._v(" "),r("ul",[r("li",[a._v("Hadoop\n"),r("ul",[r("li",[a._v("基于MapReduce架构的计算框架")]),a._v(" "),r("li",[a._v("只有map和reduce两种操作，表达能力比较欠缺")]),a._v(" "),r("li",[a._v("适合高延迟环境下批处理计算")])])]),a._v(" "),r("li",[a._v("Spark\n"),r("ul",[r("li",[a._v("基于内存的分布式计算框架")]),a._v(" "),r("li",[a._v("有丰富的算子，比较灵活")]),a._v(" "),r("li",[a._v("适合低延迟环境下的计算")])])])]),a._v(" "),r("h3",{attrs:{id:"_19-hadoop和spark使用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_19-hadoop和spark使用场景"}},[a._v("#")]),a._v(" 19.Hadoop和Spark使用场景")]),a._v(" "),r("ul",[r("li",[a._v("离线计算\n"),r("ul",[r("li",[a._v("Hadoop：单次数据量特别大")]),a._v(" "),r("li",[a._v("Spark：单次数据量不是特别大")])])])]),a._v(" "),r("h3",{attrs:{id:"_20-spark如何保证宕机迅速恢复"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_20-spark如何保证宕机迅速恢复"}},[a._v("#")]),a._v(" 20.Spark如何保证宕机迅速恢复")]),a._v(" "),r("ul",[r("li",[a._v("增加master备节点")]),a._v(" "),r("li",[a._v("编写shell脚本，时刻检测存活状态，定期"),r("strong",[a._v("重启")])])]),a._v(" "),r("h3",{attrs:{id:"_21-rdd持久化-缓存-原理✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_21-rdd持久化-缓存-原理✔"}},[a._v("#")]),a._v(" 21.RDD持久化（缓存）原理✔")]),a._v(" "),r("ul",[r("li",[a._v("将数据持久化到内存上")]),a._v(" "),r("li",[r("code",[a._v("cache（） -> persist()")])]),a._v(" "),r("li",[r("code",[a._v("un cache（）")])])]),a._v(" "),r("h3",{attrs:{id:"_22-checkpoint检查点机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-checkpoint检查点机制"}},[a._v("#")]),a._v(" 22.Checkpoint检查点机制")]),a._v(" "),r("ul",[r("li",[a._v("把应用数据存储到HDFS等可靠文件系统中（三个步骤）\n"),r("ul",[r("li",[r("code",[a._v("setCheckPointDIR()")])]),a._v(" "),r("li",[r("code",[a._v("CheckPoint()")])]),a._v(" "),r("li",[a._v("写入")])])])]),a._v(" "),r("h3",{attrs:{id:"缓存和检查点区别✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存和检查点区别✔"}},[a._v("#")]),a._v(" 缓存和检查点区别✔")]),a._v(" "),r("p",[a._v("1）"),r("strong",[a._v("Cache缓存只是将数据保存起来，不切断血缘依赖。Checkpoint检查点切断血缘依赖")]),a._v("。")]),a._v(" "),r("p",[a._v("2）Cache缓存的数据通常存储在磁盘、内存等地方，可靠性低。Checkpoint的数据通常存储在HDFS等容错、高可用的文件系统，可靠性高。")]),a._v(" "),r("p",[a._v("3）建议对checkpoint()的RDD使用Cache缓存，这样checkpoint的job只需从Cache缓存中读取数据即可，否则需要再从头计算一次RDD。")]),a._v(" "),r("h3",{attrs:{id:"_23-checkpoint和持久化机制的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_23-checkpoint和持久化机制的区别"}},[a._v("#")]),a._v(" 23.Checkpoint和持久化机制的区别")]),a._v(" "),r("ul",[r("li",[a._v("RDD")]),a._v(" "),r("li",[a._v("安全性")]),a._v(" "),r("li",[a._v("建议对checkpoint()的RDD使用Cache缓存，这样checkpoint的job只需从Cache缓存中读取数据即可，否则需要再从头计算一次RDD。")])]),a._v(" "),r("h3",{attrs:{id:"_32-rdd有哪些缺陷"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_32-rdd有哪些缺陷"}},[a._v("#")]),a._v(" 32.RDD有哪些缺陷？")]),a._v(" "),r("ul",[r("li",[a._v("不支持细粒度的写和更新操作")]),a._v(" "),r("li",[a._v("不支持迭代计算")])]),a._v(" "),r("h3",{attrs:{id:"_34-spark为什么比mapreduce快"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_34-spark为什么比mapreduce快"}},[a._v("#")]),a._v(" 34.Spark为什么比mapreduce快")]),a._v(" "),r("ul",[r("li",[a._v("内存")]),a._v(" "),r("li",[a._v("DAG")]),a._v(" "),r("li",[a._v("Lineage（血缘）")])]),a._v(" "),r("h3",{attrs:{id:"_35-数据本地性是在哪个环节确定的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_35-数据本地性是在哪个环节确定的"}},[a._v("#")]),a._v(" 35.数据本地性是在哪个环节确定的")]),a._v(" "),r("ul",[r("li",[a._v("DAG划分stage时")])]),a._v(" "),r("h3",{attrs:{id:"_36-rdd的弹性表现在哪几点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_36-rdd的弹性表现在哪几点"}},[a._v("#")]),a._v(" 36.RDD的弹性表现在哪几点")]),a._v(" "),r("ul",[r("li",[a._v("内存磁盘，task、stage失败重试，checkpoint、persis缓存。。")])]),a._v(" "),r("h3",{attrs:{id:"_37-spark的数据本地性有哪几种"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_37-spark的数据本地性有哪几种"}},[a._v("#")]),a._v(" 37. Spark的数据本地性有哪几种")]),a._v(" "),r("ul",[r("li",[a._v("读取本地节点的数据")]),a._v(" "),r("li",[a._v("读取本地硬盘的数据")]),a._v(" "),r("li",[a._v("读取非本地节点的数据（一般不用）")])]),a._v(" "),r("h3",{attrs:{id:"_38-spark为什么要持久化-一般什么场景下要进行persist操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_38-spark为什么要持久化-一般什么场景下要进行persist操作"}},[a._v("#")]),a._v(" 38.Spark为什么要持久化，一般什么场景下要进行persist操作")]),a._v(" "),r("ul",[r("li",[a._v("Spark默认存放在内存中，分布式系统中出现错误，如果没有rdd依赖关系，需要从头计算")]),a._v(" "),r("li",[a._v("计算非常耗时")]),a._v(" "),r("li",[a._v("计算链条非常长，重新恢复要算很多步骤")]),a._v(" "),r("li",[a._v("checkpoint前需要进行持久化，下次就不需要重新计算")]),a._v(" "),r("li",[a._v("shuffle之前要进行持久化persist，将数据持久化到磁盘")])]),a._v(" "),r("h3",{attrs:{id:"_39-描述yarn执行一个任务的过程-☆☆☆☆☆-【hadoop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_39-描述yarn执行一个任务的过程-☆☆☆☆☆-【hadoop"}},[a._v("#")]),a._v(" 39.描述Yarn执行一个任务的过程？（☆☆☆☆☆）【hadoop")]),a._v(" "),r("h3",{attrs:{id:"_40-spark-on-yarn-模式有哪些优点-☆☆☆☆☆-√"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_40-spark-on-yarn-模式有哪些优点-☆☆☆☆☆-√"}},[a._v("#")]),a._v(" 40.Spark on Yarn 模式有哪些优点？（☆☆☆☆☆）√")]),a._v(" "),r("ul",[r("li",[a._v("与其他计算框架共享集群资源")]),a._v(" "),r("li",[a._v("Yarn的资源分配更加细致")]),a._v(" "),r("li",[a._v("Application部署简化")]),a._v(" "),r("li",[a._v("资源弹性管理")])]),a._v(" "),r("h3",{attrs:{id:"_41-谈谈你对container的理解-☆☆☆☆☆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_41-谈谈你对container的理解-☆☆☆☆☆"}},[a._v("#")]),a._v(" 41.谈谈你对container的理解？（☆☆☆☆☆）")]),a._v(" "),r("ul",[r("li",[a._v("资源分配和调度的基本单位")]),a._v(" "),r("li",[a._v("由谁申请")]),a._v(" "),r("li",[a._v("由谁执行")])]),a._v(" "),r("h3",{attrs:{id:"_42-spark使用parquet文件存储格式能带来哪些好处-☆☆☆☆☆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_42-spark使用parquet文件存储格式能带来哪些好处-☆☆☆☆☆"}},[a._v("#")]),a._v(" 42.Spark使用parquet文件存储格式能带来哪些好处？（☆☆☆☆☆）")]),a._v(" "),r("ul",[r("li",[a._v("速度更快")]),a._v(" "),r("li",[a._v("压缩计算非常稳定出色")]),a._v(" "),r("li",[a._v("极大的减少磁盘I/O")]),a._v(" "),r("li",[a._v("可以极大的优化spark的调度和执行")])]),a._v(" "),r("h3",{attrs:{id:"_43-介绍parition和block有什么关联关系-☆☆☆☆☆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_43-介绍parition和block有什么关联关系-☆☆☆☆☆"}},[a._v("#")]),a._v(" 43.介绍parition和block有什么关联关系？（☆☆☆☆☆）")]),a._v(" "),r("ul",[r("li",[a._v("Spark，partition是rdd的最小单位，大小不固定，位于计算空间")]),a._v(" "),r("li",[a._v("HDFS，block是分布式存储的最小单位，大小固定，位于存储空间")])]),a._v(" "),r("h3",{attrs:{id:"_44-不需要排序的hash-shuffle是否一定比需要排序的sort-shuffle速度快"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_44-不需要排序的hash-shuffle是否一定比需要排序的sort-shuffle速度快"}},[a._v("#")]),a._v(" 44.不需要排序的hash shuffle是否一定比需要排序的sort shuffle速度快？")]),a._v(" "),r("ul",[r("li",[a._v("数据规模大时，sort shuffle 速度快于hash shuffle")])]),a._v(" "),r("h3",{attrs:{id:"_45-sort-based-shuffle的缺陷-☆☆☆☆☆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_45-sort-based-shuffle的缺陷-☆☆☆☆☆"}},[a._v("#")]),a._v(" 45.Sort-based shuffle的缺陷? （☆☆☆☆☆）")]),a._v(" "),r("ul",[r("li",[a._v("数量过大，会产生很多小文件")])]),a._v(" "),r("h3",{attrs:{id:"_46-spark-storage-memoryfraction参数的含义-实际生产中如何调优"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_46-spark-storage-memoryfraction参数的含义-实际生产中如何调优"}},[a._v("#")]),a._v(" 46.spark.storage.memoryFraction参数的含义,实际生产中如何调优？")]),a._v(" "),r("p",[a._v("（☆☆☆☆☆）")]),a._v(" "),r("ul",[r("li",[a._v("RDD持久化在Executor内存中的占比（默认0.6）")])]),a._v(" "),r("h3",{attrs:{id:"_47-介绍一下你对unified-memory-management内存管理模型的理解-☆☆☆☆☆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_47-介绍一下你对unified-memory-management内存管理模型的理解-☆☆☆☆☆"}},[a._v("#")]),a._v(" 47.介绍一下你对Unified Memory Management内存管理模型的理解？（☆☆☆☆☆）")]),a._v(" "),r("h3",{attrs:{id:"_48-spark有哪两种算子✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_48-spark有哪两种算子✔"}},[a._v("#")]),a._v(" 48.Spark有哪两种算子✔")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("action算子")])])]),a._v(" "),r("p",[a._v("（1）reduce\n（2）collect\n（3）count\n（4）first\n（5）take\n（6）takeOrdered\n（7）aggregate\n（8）fold\n（9）countByKey\n（10）save\n（11）foreach")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("Transformation")])])]),a._v(" "),r("p",[a._v("1）单Value\n（1）map\n（2）mapPartitions\n（3）mapPartitionsWithIndex\n（4）flatMap\n（5）glom\n（6）groupBy\n（7）filter\n（8）sample\n（9）distinct\n（10）coalesce\n（11）repartition\n（12）sortBy\n（13）pipe\n2）双vlaue\n（1）intersection\n（2）union\n（3）subtract\n（4）zip\n3）Key-Value\n（1）partitionBy\n（2）reduceByKey\n（3）groupByKey\n（4）aggregateByKey\n（5）foldByKey\n（6）combineByKey\n（7）sortByKey\n（8）mapValues\n（9）join\n（10）cogroup")]),a._v(" "),r("h3",{attrs:{id:"_49-spark有哪些聚合类的算子-我们应该尽量避免什么类型的算子"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_49-spark有哪些聚合类的算子-我们应该尽量避免什么类型的算子"}},[a._v("#")]),a._v(" 49.Spark有哪些聚合类的算子,我们应该尽量避免什么类型的算子？")]),a._v(" "),r("ul",[r("li",[a._v("reduceByKey，join，distinct，reparation")]),a._v(" "),r("li",[r("strong",[a._v("避免有shuffle的算子·：reduceBykey，groupByKey，ByKey:")])])]),a._v(" "),r("h3",{attrs:{id:"_50-rdd创建有哪几种方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_50-rdd创建有哪几种方式"}},[a._v("#")]),a._v(" 50.RDD创建有哪几种方式？")]),a._v(" "),r("ul",[r("li",[a._v("基于本地、集合、hdfs、数据库、非关系型数据库。。。")])]),a._v(" "),r("h3",{attrs:{id:"_51-spark并行度怎么设置比较合适"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_51-spark并行度怎么设置比较合适"}},[a._v("#")]),a._v(" 51.Spark并行度怎么设置比较合适？")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("partition")]),a._v("=（"),r("strong",[a._v("2~4")]),a._v("）x "),r("strong",[a._v("core")])])]),a._v(" "),r("h3",{attrs:{id:"_52-spark如何处理不能被序列化的对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_52-spark如何处理不能被序列化的对象"}},[a._v("#")]),a._v(" 52.Spark如何处理不能被序列化的对象？")]),a._v(" "),r("ul",[r("li",[a._v("封装成object对象")])]),a._v(" "),r("h3",{attrs:{id:"_53-collect功能是什么-其底层是怎么实现的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_53-collect功能是什么-其底层是怎么实现的"}},[a._v("#")]),a._v(" 53.collect功能是什么，其底层是怎么实现的？")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("把各个节点的数据收集过来\tArray->Tuple(k,v)")])])]),a._v(" "),r("h3",{attrs:{id:"_54-为什么spark-application在没有获得足够的资源-job就开始执行了-可能会导致什么问题发生"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_54-为什么spark-application在没有获得足够的资源-job就开始执行了-可能会导致什么问题发生"}},[a._v("#")]),a._v(" 54.为什么Spark Application在没有获得足够的资源，job就开始执行了，可能会导致什么问题发生？")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("导致job结束也没有分配足够的资源")])]),a._v(" "),r("li",[r("strong",[a._v("task的调度线程和Executor资源申请是异步的")])])]),a._v(" "),r("h3",{attrs:{id:"_55-map与flatmap的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_55-map与flatmap的区别"}},[a._v("#")]),a._v(" 55.map与flatMap的区别？")]),a._v(" "),r("ul",[r("li",[a._v("map\n"),r("ul",[r("li",[a._v("将一行数据转换成一个数组对象")])])]),a._v(" "),r("li",[a._v("flatMap\n"),r("ul",[r("li",[a._v("将所有对象合并成一个对象")])])])]),a._v(" "),r("h3",{attrs:{id:"_56-spark-on-mesos中-什么是的粗粒度分配-什么是细粒度分配-各自的优点和缺点是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_56-spark-on-mesos中-什么是的粗粒度分配-什么是细粒度分配-各自的优点和缺点是什么"}},[a._v("#")]),a._v(" 56.Spark on Mesos中，什么是的粗粒度分配，什么是细粒度分配，各自的优点和缺点是什么？")]),a._v(" "),r("ul",[r("li",[a._v("粗粒度\n"),r("ul",[r("li",[a._v("启动时就分配好资源")]),a._v(" "),r("li",[a._v("优点：复用率高")]),a._v(" "),r("li",[a._v("缺点：资源浪费")])])]),a._v(" "),r("li",[a._v("细粒度\n"),r("ul",[r("li",[a._v("用资源的时候分配")]),a._v(" "),r("li",[a._v("优点：用完就回收，不浪费")]),a._v(" "),r("li",[a._v("缺点：启动一次分配一次，比较麻烦")])])])]),a._v(" "),r("h3",{attrs:{id:"_57-driver的功能是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_57-driver的功能是什么"}},[a._v("#")]),a._v(" 57.driver的功能是什么？")]),a._v(" "),r("h3",{attrs:{id:"_58-spark技术栈有哪些组件-每个组件都有什么功能-适合什么应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_58-spark技术栈有哪些组件-每个组件都有什么功能-适合什么应用场景"}},[a._v("#")]),a._v(" 58.Spark技术栈有哪些组件，每个组件都有什么功能，适合什么应用场景？")]),a._v(" "),r("h3",{attrs:{id:"_59-spark中worker的主要工作是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_59-spark中worker的主要工作是什么"}},[a._v("#")]),a._v(" 59.Spark中Worker的主要工作是什么？")]),a._v(" "),r("h3",{attrs:{id:"_60-cache和pesist的区别✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_60-cache和pesist的区别✔"}},[a._v("#")]),a._v(" 60.cache和pesist的区别✔")]),a._v(" "),r("ul",[r("li",[a._v("cache调用pesist")])]),a._v(" "),r("p",[a._v("cache和persist都是用于将一个RDD进行缓存的，这样在之后使用的过程中就不需要重新计算了，可以大大节省程序运 行时间")]),a._v(" "),r("p",[a._v("1） cache只有一个默认的缓存级别MEMORY_ONLY ，cache调用了persist，而persist可以根据情况设置其它的缓存级别；")]),a._v(" "),r("p",[a._v("2）executor执行的时候，默认60%做cache，40%做task操作，persist是最根本的函数，最底层的函数。")]),a._v(" "),r("h3",{attrs:{id:"_61-cache后面能不能接其他算子-它是不是action操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_61-cache后面能不能接其他算子-它是不是action操作"}},[a._v("#")]),a._v(" 61.cache后面能不能接其他算子,它是不是action操作")]),a._v(" "),r("ul",[r("li",[a._v("可以，但是起不到缓存的效果")]),a._v(" "),r("li",[a._v("不是")])]),a._v(" "),r("h3",{attrs:{id:"_62-reducebykey是不是action"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_62-reducebykey是不是action"}},[a._v("#")]),a._v(" 62.reduceByKey是不是action？")]),a._v(" "),r("ul",[r("li",[a._v("不是，reduce是")])]),a._v(" "),r("h3",{attrs:{id:"_63-rdd通过linage-记录数据更新-的方式为何很高效"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_63-rdd通过linage-记录数据更新-的方式为何很高效"}},[a._v("#")]),a._v(" 63.RDD通过Linage（记录数据更新）的方式为何很高效？")]),a._v(" "),r("ul",[r("li",[a._v("lazy记录了数据的来源")]),a._v(" "),r("li",[a._v("记录原数据")]),a._v(" "),r("li",[a._v("简化复杂度")])]),a._v(" "),r("h3",{attrs:{id:"_64-为什么要进行序列化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_64-为什么要进行序列化"}},[a._v("#")]),a._v(" 64.为什么要进行序列化？")]),a._v(" "),r("ul",[r("li",[a._v("减少存储空间，存储体积，高效存储和传输")]),a._v(" "),r("li",[a._v("缺点：非常耗费CPU，需要进行反序列化")])]),a._v(" "),r("h3",{attrs:{id:"kryo序列化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kryo序列化"}},[a._v("#")]),a._v(" Kryo序列化")]),a._v(" "),r("p",[a._v("Kryo序列化比Java序列化更快更紧凑，但Spark默认的序列化是Java序列化并不是Spark序列化，因为Spark并不支持所有序列化类型，而且每次使用都必须进行注册。注册只针对于RDD。在DataFrames和DataSet当中自动实现了Kryo序列化。")]),a._v(" "),r("h3",{attrs:{id:"_65-yarn中的container是由谁负责销毁的-在hadoop-mapreduce中container可以复用么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_65-yarn中的container是由谁负责销毁的-在hadoop-mapreduce中container可以复用么"}},[a._v("#")]),a._v(" 65. Yarn中的container是由谁负责销毁的，在Hadoop Mapreduce中container可以复用么？")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("ApplicationMaster")])]),a._v(" "),r("li",[a._v("mr中不可复用，spark on yarn 中可以复用")])]),a._v(" "),r("h3",{attrs:{id:"_66-提交任务时-如何指定spark-application的运行模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_66-提交任务时-如何指定spark-application的运行模式"}},[a._v("#")]),a._v(" 66.提交任务时，如何指定Spark Application的运行模式？")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("./spark-submit --class xx.xx.xx --master yarn --deploy-mode **cluster** xx.jar")])]),a._v(" "),r("li",[r("code",[a._v("./spark-submit --class xx.xx.xx --master yarn --deploy-mode **client** xx.jar")])])]),a._v(" "),r("h3",{attrs:{id:"_67-不启动spark集群master和work服务-可不可以运行spark程序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_67-不启动spark集群master和work服务-可不可以运行spark程序"}},[a._v("#")]),a._v(" 67.不启动Spark集群Master和work服务，可不可以运行Spark程序？")]),a._v(" "),r("ul",[r("li",[a._v("可以，只有资源管理器由第三方管理就可以，如Yarn。resourceManager相当于master，NodeManager相当于Worker，做计算的是Executor，所以只要安装JVM就可以。")])]),a._v(" "),r("h3",{attrs:{id:"_68-spark-on-yarn-cluster-模式下-applicationmaster和driver是在同一个进程么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_68-spark-on-yarn-cluster-模式下-applicationmaster和driver是在同一个进程么"}},[a._v("#")]),a._v(" 68.spark on yarn Cluster 模式下，ApplicationMaster和driver是在同一个进程么？")]),a._v(" "),r("ul",[r("li",[a._v("是")])]),a._v(" "),r("h3",{attrs:{id:"_69-运行在yarn中application有几种类型的container"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_69-运行在yarn中application有几种类型的container"}},[a._v("#")]),a._v(" 69.运行在yarn中Application有几种类型的container？")]),a._v(" "),r("ul",[r("li",[a._v("运行ApplicationMaster的Container")]),a._v(" "),r("li",[a._v("运行各类任务的Container")])]),a._v(" "),r("h3",{attrs:{id:"_70-executor启动时-资源通过哪几个参数指定"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_70-executor启动时-资源通过哪几个参数指定"}},[a._v("#")]),a._v(" 70.Executor启动时，资源通过哪几个参数指定？")]),a._v(" "),r("ul",[r("li",[a._v("Executor\n"),r("ul",[r("li",[r("code",[a._v("num-executors")]),a._v("是executor的数量，默认2")]),a._v(" "),r("li",[r("code",[a._v("executor-memory")]),a._v("是每个executor使用的内存，默认1G")]),a._v(" "),r("li",[r("code",[a._v("executor-cores")]),a._v("是每个executor分配的CPU，默认1，官方建议2")])])]),a._v(" "),r("li",[a._v("Driver\n"),r("ul",[r("li",[r("code",[a._v("driver-cores")]),a._v(" driver使用内核数，默认为1")]),a._v(" "),r("li",[r("code",[a._v("diver-memory")]),a._v(" driver内存大小，默认512M")])])])]),a._v(" "),r("h3",{attrs:{id:"_71-导致executor产生full-gc-的原因-可能导致什么问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_71-导致executor产生full-gc-的原因-可能导致什么问题"}},[a._v("#")]),a._v(" 71.导致Executor产生FULL gc 的原因，可能导致什么问题？")]),a._v(" "),r("ul",[r("li",[a._v("导致"),r("code",[a._v("executor")]),a._v("僵死问题")])]),a._v(" "),r("h3",{attrs:{id:"_72-spark累加器有哪些特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_72-spark累加器有哪些特点"}},[a._v("#")]),a._v(" 72.Spark累加器有哪些特点？")]),a._v(" "),r("ul",[r("li",[a._v("全局唯一，自增不减")]),a._v(" "),r("li",[a._v("executor端修改，driver端读取")]),a._v(" "),r("li",[a._v("executor级别共享")])]),a._v(" "),r("h3",{attrs:{id:"_73-spark-hashparitioner的弊端是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_73-spark-hashparitioner的弊端是什么"}},[a._v("#")]),a._v(" 73.spark hashParitioner的弊端是什么？")]),a._v(" "),r("ul",[r("li",[a._v("数据倾斜")])]),a._v(" "),r("h3",{attrs:{id:"_74-rangepartitioner分区的原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_74-rangepartitioner分区的原理"}},[a._v("#")]),a._v(" 74.RangePartitioner分区的原理？")]),a._v(" "),r("ul",[r("li",[a._v("尽量保证每个分区中数据量的均匀，分区与分区之间有序，分区内无序")])]),a._v(" "),r("h3",{attrs:{id:"_75-rangepartioner分区器特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_75-rangepartioner分区器特点"}},[a._v("#")]),a._v(" 75.rangePartioner分区器特点？")]),a._v(" "),r("h3",{attrs:{id:"_76-如何理解standalone模式下-spark资源分配是粗粒度的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_76-如何理解standalone模式下-spark资源分配是粗粒度的"}},[a._v("#")]),a._v(" 76.如何理解Standalone模式下，Spark资源分配是粗粒度的？")]),a._v(" "),r("ul",[r("li",[a._v("在提交时就分配好资源")])]),a._v(" "),r("h3",{attrs:{id:"_77-union操作是产生宽依赖还是窄依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_77-union操作是产生宽依赖还是窄依赖"}},[a._v("#")]),a._v(" 77.union操作是产生宽依赖还是窄依赖？")]),a._v(" "),r("ul",[r("li",[a._v("窄依赖")])]),a._v(" "),r("h3",{attrs:{id:"_78-窄依赖父rdd的partition和子rdd的parition是不是都是一对一的关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_78-窄依赖父rdd的partition和子rdd的parition是不是都是一对一的关系"}},[a._v("#")]),a._v(" 78.窄依赖父RDD的partition和子RDD的parition是不是都是一对一的关系？")]),a._v(" "),r("ul",[r("li",[a._v("不一定")])]),a._v(" "),r("h3",{attrs:{id:"_79-hadoop中-mapreduce操作的mapper和reducer阶段相当于spark中的哪几个算子"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_79-hadoop中-mapreduce操作的mapper和reducer阶段相当于spark中的哪几个算子"}},[a._v("#")]),a._v(" 79.Hadoop中，Mapreduce操作的mapper和reducer阶段相当于spark中的哪几个算子？")]),a._v(" "),r("ul",[r("li",[a._v("map")]),a._v(" "),r("li",[a._v("reduceByKey")])]),a._v(" "),r("h3",{attrs:{id:"_80-什么是shuffle-以及为什么需要shuffle"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_80-什么是shuffle-以及为什么需要shuffle"}},[a._v("#")]),a._v(" 80.什么是shuffle，以及为什么需要shuffle？")]),a._v(" "),r("ul",[r("li",[a._v("将具有共同特征是数据聚合到同一个计算节点上进行计算")])]),a._v(" "),r("h3",{attrs:{id:"_81-spark中的hashshufle的有哪些不足"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_81-spark中的hashshufle的有哪些不足"}},[a._v("#")]),a._v(" 81.Spark中的HashShufle的有哪些不足？")]),a._v(" "),r("ul",[r("li",[a._v("产生大量小文件在磁盘上")]),a._v(" "),r("li",[a._v("内存不够用")]),a._v(" "),r("li",[a._v("数据倾斜")])]),a._v(" "),r("h3",{attrs:{id:"_82-conslidate是如何优化hash-shuffle时在map端产生的小文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_82-conslidate是如何优化hash-shuffle时在map端产生的小文件"}},[a._v("#")]),a._v(" 82.conslidate是如何优化Hash shuffle时在map端产生的小文件？")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("conslidate")]),a._v("是根据CPU的个数决定每个task shuffle map 端产生多少个文件")]),a._v(" "),r("li",[r("code",[a._v("Hash shuffle")]),a._v("是根据reduce数量决定每个task shuffle map 端产生多少个文件")])]),a._v(" "),r("h3",{attrs:{id:"_83-spark-default-parallelism这个参数有什么意义-实际生产中如何设置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_83-spark-default-parallelism这个参数有什么意义-实际生产中如何设置"}},[a._v("#")]),a._v(" 83.spark.default.parallelism这个参数有什么意义，实际生产中如何设置？")]),a._v(" "),r("ul",[r("li",[a._v("stage是默认task个数")])]),a._v(" "),r("h3",{attrs:{id:"_84-spark-shuffle-memoryfraction参数的含义-以及优化经验"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_84-spark-shuffle-memoryfraction参数的含义-以及优化经验"}},[a._v("#")]),a._v(" 84.spark.shuffle.memoryFraction参数的含义，以及优化经验？")]),a._v(" "),r("ul",[r("li",[a._v("shuffle从上一个task拉取数据过来，要在Executor进行聚 合操作，聚合操作时使用Executor内存的比例由该参数决定")])]),a._v(" "),r("h3",{attrs:{id:"_85-spark中standalone模式特点-有哪些优点和缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_85-spark中standalone模式特点-有哪些优点和缺点"}},[a._v("#")]),a._v(" 85.Spark中standalone模式特点，有哪些优点和缺点？")]),a._v(" "),r("ul",[r("li",[a._v("特点\n"),r("ul",[r("li",[a._v("主从架构")]),a._v(" "),r("li",[a._v("FIFO调度")]),a._v(" "),r("li",[a._v("无需依赖其他资源管理系统")])])]),a._v(" "),r("li",[a._v("优点\n"),r("ul",[r("li",[a._v("无需依赖其他资源管理系统")]),a._v(" "),r("li",[a._v("部署简单")])])]),a._v(" "),r("li",[a._v("缺点\n"),r("ul",[r("li",[a._v("一个应用程序会占用所有可用节点的资源")]),a._v(" "),r("li",[a._v("容易出现单点故障，需要配置HA")])])])]),a._v(" "),r("h3",{attrs:{id:"_86-常见的数压缩方式-你们生产集群采用了什么压缩方式-提升了多少效率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_86-常见的数压缩方式-你们生产集群采用了什么压缩方式-提升了多少效率"}},[a._v("#")]),a._v(" 86.常见的数压缩方式，你们生产集群采用了什么压缩方式，提升了多少效率？")]),a._v(" "),r("ul",[r("li",[a._v("GZ\t压缩率最高，压缩和解压速度最慢")]),a._v(" "),r("li",[a._v("LZO")]),a._v(" "),r("li",[a._v("snappy")])]),a._v(" "),r("h3",{attrs:{id:"_87-使用scala代码实现wordcount"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_87-使用scala代码实现wordcount"}},[a._v("#")]),a._v(" 87.使用scala代码实现WordCount？")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("new SparkContext( new Sparkconf() )")])]),a._v(" "),r("li",[r("code",[a._v('.textFlie("XX.txt")')])]),a._v(" "),r("li",[r("code",[a._v('.flatMap(.split(" "))')])]),a._v(" "),r("li",[r("code",[a._v(".map( (,1) )")])]),a._v(" "),r("li",[r("code",[a._v(".reduceByKey(_+_)")])]),a._v(" "),r("li",[r("code",[a._v(".collect()")])]),a._v(" "),r("li",[r("code",[a._v(".foreach(println)")])])]),a._v(" "),r("h3",{attrs:{id:"_89-rdd的数据结构是怎么样的✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_89-rdd的数据结构是怎么样的✔"}},[a._v("#")]),a._v(" 89.RDD的数据结构是怎么样的✔")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/29617954/1677899267708-a79d4ddd-95b4-4f7f-85ef-b53e62fec7d0.png#averageHue=%23f5f2f1&clientId=uaa6c32e4-fb4e-4&from=paste&height=784&id=uf1c59f94&originHeight=980&originWidth=1823&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=362133&status=done&style=none&taskId=ua529e298-06cc-486d-b09b-5545c70b3cf&title=&width=1458.4",alt:"image.png"}})]),a._v(" "),r("h3",{attrs:{id:"_90-rdd算子里操作一个外部map-比如往里面put数据-然后算子外再遍历map-会有什么问题吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_90-rdd算子里操作一个外部map-比如往里面put数据-然后算子外再遍历map-会有什么问题吗"}},[a._v("#")]),a._v(" 90.RDD算子里操作一个外部map，比如往里面put数据，然后算子外再遍历map，会有什么问题吗？")]),a._v(" "),r("h3",{attrs:{id:"_91-说说你对hadoop生态的认识。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_91-说说你对hadoop生态的认识。"}},[a._v("#")]),a._v(" 91.说说你对Hadoop生态的认识。")]),a._v(" "),r("ul",[r("li",[a._v("分布式文件系统")]),a._v(" "),r("li",[a._v("分布式计算引擎")]),a._v(" "),r("li",[a._v("周边工具")])]),a._v(" "),r("h3",{attrs:{id:"_92-hbase-region多大会分区-spark读取hbase数据是如何划分partition的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_92-hbase-region多大会分区-spark读取hbase数据是如何划分partition的"}},[a._v("#")]),a._v(" 92.hbase region多大会分区，spark读取hbase数据是如何划分partition的？")]),a._v(" "),r("ul",[r("li",[a._v("参数默认1G。HBASE有多少个region，spark就会划分几个partition")])]),a._v(" "),r("h3",{attrs:{id:"_93-spark数据倾斜"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_93-spark数据倾斜"}},[a._v("#")]),a._v(" 93.Spark数据倾斜")]),a._v(" "),r("ul",[r("li",[a._v("随机取样\n"),r("ul",[r("li",[a._v("相同key的值进行统计个数，将倾斜的过滤掉")])])]),a._v(" "),r("li",[a._v("两两聚合\n"),r("ul",[r("li",[a._v("给key加随机数，直接聚合，取消随机数，再次聚合")])])]),a._v(" "),r("li",[a._v("大表和小表\n"),r("ul",[r("li",[a._v("reduce join->map join，将小表广播出去，然后大表操作")])])]),a._v(" "),r("li",[a._v("大表和大表\n"),r("ul",[r("li",[a._v("一个大表扩容，一个大表key随机加前缀，将key均匀分布到不同的分区中，并行处理")])])])]),a._v(" "),r("h3",{attrs:{id:"_94-spark中taskschedule的作用是啥"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_94-spark中taskschedule的作用是啥"}},[a._v("#")]),a._v(" 94.Spark中TaskSchedule的作用是啥")]),a._v(" "),r("ul",[r("li",[a._v("taskSchedule将task发送给executor")])]),a._v(" "),r("h3",{attrs:{id:"_95-spark的内存分布"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_95-spark的内存分布"}},[a._v("#")]),a._v(" 95.Spark的内存分布")]),a._v(" "),r("ul",[r("li",[a._v("堆内内存\n"),r("ul",[r("li",[a._v("会发生OOM")])])]),a._v(" "),r("li",[a._v("堆外内存\n"),r("ul",[r("li",[a._v("物理内存")])])])]),a._v(" "),r("h3",{attrs:{id:"_96-spark处理小文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_96-spark处理小文件"}},[a._v("#")]),a._v(" 96.Spark处理小文件")]),a._v(" "),r("ul",[r("li",[a._v("减少分区\n"),r("ul",[r("li",[r("code",[a._v("coalesce")])]),a._v(" "),r("li",[r("code",[a._v("reparation")])])])])]),a._v(" "),r("h3",{attrs:{id:"_97-spark如何实现报警功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_97-spark如何实现报警功能"}},[a._v("#")]),a._v(" 97.spark如何实现报警功能")]),a._v(" "),r("ul",[r("li",[a._v("写代码获取yarn类的spark状态")]),a._v(" "),r("li",[a._v("写代码获取executor、CPU、内存等信息，来判断存活状态")])]),a._v(" "),r("h3",{attrs:{id:"_98-spark的shuffle✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_98-spark的shuffle✔"}},[a._v("#")]),a._v(" 98.Spark的shuffle✔")]),a._v(" "),r("ul",[r("li",[a._v("hashShuffle")]),a._v(" "),r("li",[a._v("sortShuffle")])]),a._v(" "),r("h3",{attrs:{id:"哪些算子会引起shuffle✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#哪些算子会引起shuffle✔"}},[a._v("#")]),a._v(" 哪些算子会引起shuffle✔")]),a._v(" "),r("p",[a._v("一般 xxbykey 会shuffle，因为涉及到数据重分区")]),a._v(" "),r("p",[a._v("repartition：底层调用的就是coalesce，一定会shuffle，一般用于增大分区")]),a._v(" "),r("p",[a._v("coalesce：不一定会shuffle，一般用于缩小分区")]),a._v(" "),r("p",[a._v("合并小文件：启动一个Spark任务，读取，使用coalesce")]),a._v(" "),r("h3",{attrs:{id:"_99-spark中oom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_99-spark中oom"}},[a._v("#")]),a._v(" 99.Spark中OOM")]),a._v(" "),r("h3",{attrs:{id:"_100-reparation和coalesce关系与区别✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_100-reparation和coalesce关系与区别✔"}},[a._v("#")]),a._v(" 100.Reparation和Coalesce关系与区别✔")]),a._v(" "),r("ul",[r("li",[a._v("调整分区（涉及shuffle）")]),a._v(" "),r("li",[a._v("减少分区")])]),a._v(" "),r("p",[a._v("关系:")]),a._v(" "),r("ul",[r("li",[a._v("两者都是用来改变RDD的partition数量的，repartition底层调用的就是coalesce方法:coalesce(numPartitions, shuffle = true)")])]),a._v(" "),r("p",[a._v("区别:")]),a._v(" "),r("ul",[r("li",[a._v("repartition一定会发生shuffle，coalesce根据传入的参数来判断是否发生shuffle")]),a._v(" "),r("li",[a._v("一般情况下增大rdd的partition数量使用repartition，减少partition数量时使用coalesce")])]),a._v(" "),r("h3",{attrs:{id:"_101-yarn-client的提交流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_101-yarn-client的提交流程"}},[a._v("#")]),a._v(" 101.Yarn-client的提交流程")]),a._v(" "),r("ul",[r("li",[a._v("Driver在任务提交的本地运行")])]),a._v(" "),r("h3",{attrs:{id:"_102-yarn-cluster的提交流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_102-yarn-cluster的提交流程"}},[a._v("#")]),a._v(" 102.Yarn-cluster的提交流程")]),a._v(" "),r("ul",[r("li",[a._v("Driver在ApplicationMaster上运行")])]),a._v(" "),r("h3",{attrs:{id:"_103-spark调优原则✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_103-spark调优原则✔"}},[a._v("#")]),a._v(" 103.Spark调优原则✔")]),a._v(" "),r("ul",[r("li",[a._v("避免使用重复RDD")]),a._v(" "),r("li",[a._v("尽量使用同一个RDD")]),a._v(" "),r("li",[a._v("避免使用有shuffle的算子")]),a._v(" "),r("li",[a._v("对多次使用的RDD进行持久化")]),a._v(" "),r("li",[a._v("mapSide预聚合")]),a._v(" "),r("li",[a._v("使用高性能是算子")]),a._v(" "),r("li",[a._v("广播大变量")])]),a._v(" "),r("h3",{attrs:{id:"_105-map和mappartitions区别✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_105-map和mappartitions区别✔"}},[a._v("#")]),a._v(" 105.map和mapPartitions区别✔")]),a._v(" "),r("p",[a._v("1）map：每次处理一条数据\n2）mapPartitions：每次处理一个分区数据")]),a._v(" "),r("h3",{attrs:{id:"_106-reducebykey、foldbykey、aggregatebykey、combinebykey区别✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_106-reducebykey、foldbykey、aggregatebykey、combinebykey区别✔"}},[a._v("#")]),a._v(" 106. reduceByKey、foldByKey、aggregateByKey、combineByKey区别✔")]),a._v(" "),r("p",[a._v("ReduceByKey     没有初始值         分区内和分区间逻辑相同")]),a._v(" "),r("p",[a._v("foldByKey      有初始值           分区内和分区间逻辑相同")]),a._v(" "),r("p",[a._v("aggregateByKey   有初始值           分区内和分区间逻辑可以不同")]),a._v(" "),r("p",[a._v("combineByKey   初始值可以变化结构  分区内和分区间逻辑不同")]),a._v(" "),r("h3",{attrs:{id:"_107-spark任务的划分✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_107-spark任务的划分✔"}},[a._v("#")]),a._v(" 107.Spark任务的划分✔")]),a._v(" "),r("p",[a._v("（1）Application：初始化一个SparkContext即生成一个Application；")]),a._v(" "),r("p",[a._v("（2）Job：一个Action算子就会生成一个Job；")]),a._v(" "),r("p",[a._v("（3）Stage：Stage等于宽依赖的个数加1；")]),a._v(" "),r("p",[a._v("（4）Task：一个Stage阶段中，最后一个RDD的分区个数就是Task的个数。")]),a._v(" "),r("h3",{attrs:{id:"_108-cache缓存级别✔"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_108-cache缓存级别✔"}},[a._v("#")]),a._v(" 108.cache缓存级别✔")]),a._v(" "),r("p",[a._v("DataFrame的cache默认采用 MEMORY_AND_DISK\nRDD 的cache默认方式采用MEMORY_ONLY")]),a._v(" "),r("h3",{attrs:{id:"_109-spark分区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_109-spark分区"}},[a._v("#")]),a._v(" 109.Spark分区")]),a._v(" "),r("p",[a._v("1）默认采用Hash分区\n缺点：可能导致每个分区中数据量的不均匀，极端情况下会导致某些分区拥有RDD的全部数据。\n2）Ranger分区\n要求RDD中的KEY类型必须可以排序。\n3）自定义分区\n根据需求，自定义分区。")]),a._v(" "),r("h2",{attrs:{id:"sparksql"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sparksql"}},[a._v("#")]),a._v(" SparkSQL")]),a._v(" "),r("h3",{attrs:{id:"_15-sparksql执行的流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_15-sparksql执行的流程"}},[a._v("#")]),a._v(" 15.SparkSql执行的流程")]),a._v(" "),r("h3",{attrs:{id:"_16-saprksql是如何将数据写到hive表的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-saprksql是如何将数据写到hive表的"}},[a._v("#")]),a._v(" 16.SaprkSql是如何将数据写到hive表的")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("SparkRDDApi  -> HDFS\t"),r("strong",[a._v("映射")])])]),a._v(" "),r("li",[r("p",[a._v("SparkSql\t\t-> DataFrame\t->\t缓存表\t"),r("strong",[a._v("直接插入")])])]),a._v(" "),r("li")]),a._v(" "),r("h3",{attrs:{id:"_88-spark-sql为什么比hive快呢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_88-spark-sql为什么比hive快呢"}},[a._v("#")]),a._v(" 88.Spark sql为什么比hive快呢？")]),a._v(" "),r("h3",{attrs:{id:"_110-sparksql中rdd、dataframe、dataset三者的转换-笔试重点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_110-sparksql中rdd、dataframe、dataset三者的转换-笔试重点"}},[a._v("#")]),a._v(" 110.SparkSQL中RDD、DataFrame、DataSet三者的转换（笔试重点）")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/29617954/1677901144741-fbaca06c-0175-4390-aa70-12e31b950bd3.png#averageHue=%23fefdfd&clientId=u8869e584-7142-4&from=paste&height=294&id=uef542093&originHeight=368&originWidth=798&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28132&status=done&style=none&taskId=u1bcf9a38-76ee-42ef-8717-b12af26f863&title=&width=638.4",alt:"image.png"}})]),a._v(" "),r("h2",{attrs:{id:"sparkstreaming"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sparkstreaming"}},[a._v("#")]),a._v(" SparkStreaming")]),a._v(" "),r("h3",{attrs:{id:"_24-sparkstreaming以及基本工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_24-sparkstreaming以及基本工作原理"}},[a._v("#")]),a._v(" 24.SparkStreaming以及基本工作原理？")]),a._v(" "),r("h3",{attrs:{id:"_25-dstream以及基本工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_25-dstream以及基本工作原理"}},[a._v("#")]),a._v(" 25.DStream以及基本工作原理？")]),a._v(" "),r("h3",{attrs:{id:"_26-sparkstreaming整合kafka的两种模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_26-sparkstreaming整合kafka的两种模式"}},[a._v("#")]),a._v(" 26.SparkStreaming整合Kafka的两种模式？")]),a._v(" "),r("ul",[r("li",[a._v("Receiver\n"),r("ul",[r("li",[a._v("主动去SparkExecutor的内存中处理数据")])])]),a._v(" "),r("li",[a._v("Direct\n"),r("ul",[r("li",[a._v("定期查询kafka中的offset，拉取新数据，进行处理")])])])]),a._v(" "),r("h3",{attrs:{id:"_27-spark主备切换原理知道吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_27-spark主备切换原理知道吗"}},[a._v("#")]),a._v(" 27.Spark主备切换原理知道吗？")]),a._v(" "),r("ul",[r("li",[a._v("基于文件系统，手动切换")]),a._v(" "),r("li",[a._v("基于ZooKeeper，自动切换")])]),a._v(" "),r("h3",{attrs:{id:"_28-spark解决了hadoop的哪些问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_28-spark解决了hadoop的哪些问题"}},[a._v("#")]),a._v(" 28.Spark解决了Hadoop的哪些问题？")]),a._v(" "),r("ul",[r("li",[a._v("硬编码")]),a._v(" "),r("li",[a._v("表达局限")]),a._v(" "),r("li",[a._v("一个Job一个MapReduce阶段")]),a._v(" "),r("li",[a._v("存储内存->磁盘")]),a._v(" "),r("li",[a._v("窄依赖并行处理")]),a._v(" "),r("li",[a._v("实时计算")])]),a._v(" "),r("h3",{attrs:{id:"_29-sparkmasterha主从切换过程会不会影响到集群已有的作业的运行-为什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_29-sparkmasterha主从切换过程会不会影响到集群已有的作业的运行-为什么"}},[a._v("#")]),a._v(" 29.SparkMasterHA主从切换过程会不会影响到集群已有的作业的运行，为什么？")]),a._v(" "),r("ul",[r("li",[a._v("不会，已经分配好资源了")])]),a._v(" "),r("h3",{attrs:{id:"_30-sparkmaster使用zookeeper进行ha-有哪些源数据保存到zookeeper里面"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_30-sparkmaster使用zookeeper进行ha-有哪些源数据保存到zookeeper里面"}},[a._v("#")]),a._v(" 30.SparkMaster使用Zookeeper进行HA,有哪些源数据保存到Zookeeper里面？")]),a._v(" "),r("ul",[r("li",[a._v("master的元数据Metastore")])]),a._v(" "),r("h3",{attrs:{id:"_31-如何实现sparkstreaming读取flume中的数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_31-如何实现sparkstreaming读取flume中的数据"}},[a._v("#")]),a._v(" 31.如何实现SparkStreaming读取Flume中的数据？")]),a._v(" "),r("ul",[r("li",[a._v("推模式")]),a._v(" "),r("li",[a._v("拉模式")])])])}),[],!1,null,null,null);r.default=_.exports}}]);