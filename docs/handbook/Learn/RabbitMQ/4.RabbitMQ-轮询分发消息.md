## RabbitMQ-轮询分发消息.md

启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。

在IDEA2021中设置，其他版本类似，Edit Configuration => 选择当前的启动类 => Modify options => 勾选 Allow multiple instances

### 发送线程（控制台输入）

```java
import com.rabbitmq.client.Channel;
import com.sun.rmi.rmid.ExecOptionPermission;
import com.tjetc.utils.RabbitMqUtils;

import java.util.Scanner;

/**
 * @user 25122
 * @date 2023/5/14
 * @time 20:02
 * @description 生产者，发送大量消息
 */
public class Task01 {

    public static final String QUEUE_NAME = "RabbitMQQueue";

    /**
     * 发送大量的消息
     *
     * @param args
     */
    public static void main(String[] args) throws Exception {
        //1.通过工具类 获取信道
        Channel channel = RabbitMqUtils.getChannel();
        /**
         * 生成一个队列
         * 1.队列名称
         * 2.队列里面的消息是否需要持久化（磁盘） 默认情况下消息存储在内存中
         * 3.该队列是否只供一个消费者进行消费 是否进行消息共享，true可以多个消费者消费，false只能一个消费者消费
         * 4.是否自动删除 最一个消费者断开连接后，是否自动删除，true自动删除，false不自动删除
         * 5.其他参数
         */
//        channel.queueDelete(QUEUE_NAME);
        channel.queueDeclare(QUEUE_NAME, false, false, true, null);
        //2.从控制台中接受消息
        //创建Scanner对象
        Scanner scanner = new Scanner(System.in);
        //判断是否有下一个消息
        while (scanner.hasNext()) {
            //获取输入的消息内容
            String message = scanner.next();
            /***
             * 发送一个消费
             * 1.发送到那个交换机
             * 2.路由的key值是那个 本次是队列的名称
             * 3.其他参数信息
             * 4.发送消息的消费体
             */
            channel.basicPublish("", QUEUE_NAME, null ,message.getBytes());
            System.out.println("消息发送完成"+message);
        }

    }
}

```

### 消费线程（启动两个）
```java
import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.tjetc.utils.RabbitMqUtils;

/**
 * @user 25122
 * @date 2023/4/25
 * @time 11:50
 * 这是一个工作线程 (相当于之前消费者)
 */
public class Worker01 {

    //队列名称
    private static final String QUEUE_NAME = "RabbitMQQueue";

    //接收消息
    public static void main(String[] args) throws Exception{
        //利用工具类获取信道
        Channel channel = RabbitMqUtils.getChannel();

        //声明 接收消息 lambda表达式
        DeliverCallback deliverCallback = (consumerTag, message) ->{
            //转换 获取消息体
            System.out.println("接收到的消息：" + new String(message.getBody()));
        };
        //声明 取消消息时的回调
        CancelCallback cancelCallback = (consumerTag) -> {
            System.out.println("消息消费被中断");
        };

        System.out.println("C2等待接收消息。。。。。。");
        /***
         * 消费者消费消息
         * 1.消费那个队列
         * 2.消费成功之后是否要自动应答 true代表自动应答 false代表手动应答
         * 3.消费者未成功消费的回调
         * 4.消费者取消消费者的回调
         */
        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);


    }

}

```

### 结果
通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息

### 注意

声明队列时报错

完整错误信息：

Channel shutdown: channel error; protocol method: #method<channel.close>(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg 'x-dead-letter-routing-key' for queue 'simple.queue' in vhost '/': received the value 'simple' of type 'longstr' but current is none, class-id=50, method-id=10)

错误原因：

RabbitMQ中已存在这个队列，但在启动的项目中对这个队列的属性进行了修改。RabbitMQ中的队列一经声明，其属性不可修改。

解决方法：

删除该队列并重新声明
`channel.queueDelete(QUEUE_NAME);`





