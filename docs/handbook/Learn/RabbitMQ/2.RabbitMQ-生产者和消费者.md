## RabbitMQ-生产者和消费者



### 第一步：添加依赖，代码如下：
```xml
    <!--指定 jdk 编译版本-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <dependencies>
        <!--rabbitmq 依赖客户端-->
        <dependency>
            <groupId>com.rabbitmq</groupId>
            <artifactId>amqp-client</artifactId>
            <version>5.8.0</version>
        </dependency>
        <!--操作文件流的一个依赖-->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.6</version>
        </dependency>
    </dependencies>
```

### 第二步：编写消息生产者，代码如下：

```java
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;


/**
 * @user 25122
 * @date 2023/4/23
 * @time 11:54
 * 生产者：发消息
 */
public class Producer {
    //队列名称
    public static final String QUEUE_NAME = "hello";

    //发消息
    public static void main(String[] args) throws Exception {
        //创建一个连接工厂
        ConnectionFactory connectionFactory = new ConnectionFactory();
        //工厂IP 连接RabbitMQ的队列
        connectionFactory.setHost("192.168.137.50");
        //用户名
        connectionFactory.setUsername("admin");
        //密码
        connectionFactory.setPassword("123");

        //创建连接
        Connection connection = connectionFactory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        /**
         * 生成一个队列
         * 1.队列名称
         * 2.队列里面的消息是否需要持久化（磁盘） 默认情况下消息存储在内存中
         * 3.该队列是否只供一个消费者进行消费 是否进行消息共享，true可以多个消费者消费，false只能一个消费者消费
         * 4.是否自动删除 最一个消费者断开连接后，是否自动删除，true自动删除，false不自动删除
         * 5.其他参数
         */
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        //发消息
        String message = "hello rabbitmq";
        /***
         * 发送一个消费
         * 1.发送到那个交换机
         * 2.路由的key值是那个 本次是队列的名称
         * 3.其他参数信息
         * 4.发送消息的消费体
         */
        channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
        System.out.println("消息发送完毕");

        channel.close();
        connection.close();

    }
}

```

### 第三步：编写消息消费者，代码如下：

```java
import com.rabbitmq.client.*;

/**
 * @user 25122
 * @date 2023/4/23
 * @time 13:46
 * 消费者 接收消息的
 */
public class Consumer {
    //队列的名称
    public static final String QUEUE_NAME = "hello";

    //接受消息
    public static void main(String[] args) throws Exception {
        //创建连接工厂
        ConnectionFactory connectionFactory = new ConnectionFactory();
        //设置工厂IP
        connectionFactory.setHost("192.168.137.50");
        //设置用户名
        connectionFactory.setUsername("admin");
        //设置密码
        connectionFactory.setPassword("123");
        //创建连接
        Connection connection = connectionFactory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();

        //声明 接收消息 lambda表达式
        DeliverCallback deliverCallback = (consumerTag, message) -> {
            //转换 获取消息体
            System.out.println(new String(message.getBody()));
        };
        //声明 取消消息时的回调 消息接收被取消时候 执行下面的内容
        CancelCallback cancelCallback = (consumerTag) -> {
            System.out.println(consumerTag + "消息者取消消费接口回调逻辑");
        };
        /***
         * 消费者消费消息
         * 1.消费那个队列
         * 2.消费成功之后是否要自动应答 true代表自动应答 false代表手动应答
         * 3.消费者未成功消费的回调
         * 4.消费者取消消费者的回调
         */
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);

        channel.close();
        connection.close();
    }

}

```
