## RabbitMQ-不公平分发&预取值

### 1. 不公平分发

在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，
比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2处理速度却很慢，
这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，
而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，
但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。
为了避免这种情况，我们可以设置参数 channel.basicQos(1);

在消费者端
```java
        //设置不公平分发
        int prefetchCount = 1;
        channel.basicQos(prefetchCount);
```

队列持久化在控制台也能看到
centos7:15672->Channels->Prefetch:1

意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，
然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，
当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，
队列有可能就会遇到队列被撑满的情况，
这个时候就只能添加新的 worker 或者改变其他存储任务的策略。

### 2. 预取值

本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息，另外来自消费者的手动确认本质上也是异步的。
因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能**限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。**
这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。
**该值定义通道上允许的未确认消息的最大数量。**一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，
除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何
消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。
消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。
**虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，
从而增加了消费者的 RAM 消耗**(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，
消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，
所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，
并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这将使吞吐量变得很低，
特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。

消费端
```java
        //设置不公平分发
//        int prefetchCount = 1;
        int prefetchCount = 5;//预期值是5
        channel.basicQos(prefetchCount);
```

