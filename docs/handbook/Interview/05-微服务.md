# 微服务

## 基础

### 如何理解微服务✔

微服务是一种架构风格，我们可以把应用程序划分为一组小型的、松散耦合的服务，每个服务都运行在自己的进程里面，并通过轻量级的通信机制，来进行通信，每个服务都可以独立部署、独立扩展、独立更新，从而提高了应用程序的可伸缩性、可维护性、可测试性，由于微服务是属于分布式架构下的一种针对应用架构的一种设计风格，所有我们会面临到分布式架构下的一些服务治理的复杂问题，因此spring官方提供了一套springCloud解决方案，帮助我们快速实现微服务的技术方案落地。

### 常见的远程调用有几种✔

1. 自定义协议实现C/S RPC调用（实现复杂，需解决的问题多）
2. UDP广播类型（常见用于即时通讯类，速度快，但需要二次确认）
3. 目前主流的基于http协议调用（Restful风格的api，springcloud微服务调用使用的就是http）
4. dubbo协议（阿里出品，长连接，二进制封装数据，性能较高）
5. soap协议（古老的webservice系列框架，基于xml实现数据封装，http协议传输）
6. 异步响应式（WebFlux+Spring Data Reactive）
7. 服务器推（不主动调用，常见系统通知类）

**对于有这些外部衔接的方法需要注意哪些问题?请写出注意问题及伪代码**

1. 写好接口文档，方便后续维护和团队协作

2. 统一化的报文结构 

3. 标准化的服务状态码

   1. ```
      status_code 200;//请求成功
      ```

4. 统一化请求日志记录,及异常记录

5. ```
   GlobalExceptionHandler...
   
   logger.error("服务异常"，exception);
   ```

6. 当请求延迟过高，可以快速失败

7. 重试机制

8. ```java
   // 服务列表
   serverList = {ser1,ser2,ser3}
   retrycount = 0;
   retrymax=10;
   maxrequesttime = 200ms；
       getxxoo(){
   
       try{
           // 尝试请求数据
           calldata(serverList)
   
       }catch (请求失败 500类异常 || 请求超时 calldata的网络请求方法中){
   
           //   拦截器记录日志
           serverList.remove(刚才请求的服务器)
               //   重试次数过多
               if (retrycount == retrymax)
                   return "当前访问不可用稍后再试"
   
                   retrycount ++;
           		//递归调用本方法
   
       }
   }
   ```

9. 事务问题，可回滚

10. ```java
    getData(){
        分布式事务开启
    
            get1();
        get2();
        get3();
        事务结束
            要么全成功 要么全失败
            修改数据时使用 tryModify() 临时保存数据或通过Seata类似的框架实现
    }
    ```

11. 数据一致性问题

12. ```java
    //有并发修改数据时，如果需要保证一致性，需要使用分布式锁
        //修改方法
        modifyxx(){
        // 尝试加锁
        boolean haslock = tryLock(id)
    
        if(haslock){
            httppost(url,data)
            releaseLock(id)
        }else{
    
            // 提示用户一会再试试
            // 尝试再次获取锁
        }
    
    }
    ```

### 分布式锁、分布式事务、分布式缓存

## SpringCloud

### Spring Cloud 5大组件有哪些✔

早期我们一般认为的Spring Cloud五大组件是 

- Eureka : 注册中心 

- Ribbon : 负载均衡 

- Feign : 远程调用 

- Hystrix : 服务熔断 

- Zuul/Gateway : 网关

随着SpringCloudAlibba在国内兴起 , 我们项目中使用了一些阿里巴巴的组件是

- 注册中心/配置中心 Nacos 

- 负载均衡 Ribbon 

- 服务调用 Feign 

- 服务保护 sentinel 

- 服务网关 Gateway

### 服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现✔

我理解的是主要三块大功能，分别是服务注册 、服务发现、服务状态监控

我们当时项目采用的eureka作为注册中心，这个也是spring cloud体系中的一 个核心组件 

**服务注册**：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等等 

**服务发现**：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用 

**服务监控**：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果 eureka服务90秒没接收到心跳，从eureka中剔除

### 能说下nacos与eureka的区别✔

我们当时xx项目就是采用的nacos作为注册中心，选择nacos还要一个重要原因就是它支持配置中心，不过nacos作为注册中心，也比eureka要方便好用一些，主要相同不同点在于几点： 

- **共同点** 

Nacos与eureka都支持服务注册和服务拉取，都支持服务提供者心跳方式做健康检测 

- **Nacos与Eureka的区别** 

1、语言支持：Nacos支持多种编程语言，包括Java、Go、Python等，而Eureka主要是为Java开发的。

2、**数据持久化**：Nacos提供了可插拔的存储模块，可以将注册中心的数据持久化到不同的存储介质中（如MySQL、Redis等），并支持数据的持久化和恢复。而Eureka默认将数据存储在内存中，没有提供直接的持久化机制。

3、健康检查：Nacos提供了丰富的健康检查机制，可以根据自定义规则对服务的健康状态进行评估。Eureka则只提供了基本的健康检查。**Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式** ，临时实例心跳不正常会被剔除，非临时实例则不会被剔除 

4、Nacos支持动态配置功能，可以将配置信息集中管理，并支持实时推送配置变更。Eureka没有原生的配置中心功能，通常需要结合其他组件来实现。**Nacos支持服务列表变更的消息推送模式，服务列表更新更及时** 

5、服务网格：Nacos提供了服务网格的支持，可以灵活地管理和配置服务之间的流量。Eureka主要关注于服务的注册与发现，并没有关注服务网格的功能。

6、社区活跃度：目前来说，Eureka的社区相对较小，而Nacos的社区更加活跃，有更多的开发者参与和贡献，因此在功能迭代和问题修复方面更加迅速，并且得到了广泛的应用和贡献

7、Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式； Eureka采用AP方式

8、功能特性：Nacos提供了服务注册、发现、配置管理和动态配置等一体化的解决方案，同时还支持更强大的服务路由、负载均衡和服务治理等功能；Eureka主要专注于服务注册与发现，提供了基本的服务注册和健康检查的功能。

9、支持的服务类型：Nacos不仅支持传统的微服务架构，还支持云原生应用和Kubernetes等容器化环境下的服务注册和发现；Eureka主要针对传统的微服务架构，不太适用于容器化环境。

> AP高可用性和CP数据强一致性的英文全称如下
>
> - AP: Availability and Partition Tolerance
> - CP: Consistency and Partition Tolerance

### 你们项目负载均衡如何实现的✔

在服务调用过程中的负载均衡一般使用SpringCloud的Ribbon 组件实现 , Feign的底层已经自动集成了Ribbon , 使用起来非常简单 

当发起远程调用时，ribbon先从注册中心拉取服务地址列表，然后按照一定的路由策略选择一个发起远程调用，一般的调用策略是轮询

### Ribbon负载均衡策略有哪些✔

- RoundRobinRule：简单轮询服务列表来选择服务器 
- WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小 
- RandomRule：随机选择一个可用的服务器 
- ZoneAvoidanceRule：区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。 而后再对Zone内的多个服务做轮询(默认)

### 如果想自定义负载均衡策略如何实现✔

提供了两种方式： 

1、创建类实现IRule接口，可以指定负载均衡策略，这个是全局的，对所有的远程调用都起作用 

```java
@Bean
public IRule randomRule(){
    return new RandomRule();
}
```

2、在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略，只是对配置的这个服务生效远程调用

```yaml
userservice:
    ribbon:
        NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule# 负载均衡规则 
```

### 什么是服务雪崩，怎么解决这个问题✔

服务雪崩是指一个服务失败，导致整条链路的服务都失败的情形，一般我们在项目解决的话就是两种方案，第一个是服务降级，第二个是服务熔断，如果流量太大的话，可以考虑限流

**服务降级**：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑

**服务熔断**：默认关闭，需要手动打开，如果检测到 10 秒内请求的失败率超过50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求

> 在微服务架构中，服务熔断和服务降级是两种用于提高系统的可用性和稳定性的技术手段。
>
> 1. 服务熔断（Circuit Breaker）：服务熔断是一种故障保护机制，用于防止故障的扩散和影响整个系统的可用性。当某个服务发生故障或超时时，服务熔断器会迅速中断对该服务的调用，并在一段时间内暂停对该服务的请求。通过熔断机制，可以快速失败并快速恢复，避免等待超时导致资源浪费和系统负荷过大。服务熔断器通常会根据预设的条件（如错误率、超时次数等）进行状态转换，并在恢复后重新尝试调用服务。
>
> 2. 服务降级（Fallback）：服务降级是一种优雅地处理故障的方式，当系统出现故障或异常情况时，通过降低部分功能或服务的质量或响应速度来保证整体系统的稳定性。在服务降级中，可以提供备用的实现或者返回缺省值，使得用户在系统故障时依然能够获得一定的可用功能。服务降级可以通过配置或代码逻辑实现，确保关键功能的可用性，并避免系统崩溃或无响应。
>
> 服务熔断和服务降级是面向微服务架构下的分布式系统中的设计原则和实践。通过服务熔断机制可以快速失败并恢复，保护系统的稳定性和可用性；而服务降级机制则通过降低服务的质量或功能来确保整体系统的可用性。这两种技术可以结合使用，提高系统的健壮性和容错性。

### 你们的微服务是怎么监控的✔

我们项目中采用的skywalking进行监控的 

1，skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。 

2，我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目 的bug情况，第一时间修复

### 你们项目中有没有做过限流 ? 怎么做的 ✔

我当时做的xx项目，采用就是微服务的架构，因为xx因为，应该会有突发流量，最大QPS可以达到2000，但是服务支撑不住，我们项目都通过压测最多可以支撑1200QPS。因为我们平时的QPS也就不到100，为了解决这些突发流量，所以采用了限流。 

【版本1】 我们当时采用的nginx限流操作，nginx使用的漏桶算法来实现过滤，让请求以固定的速率处理请求，可以应对突发流量，我们控制的速率是按照ip进行限流，限制的流量是每秒20 

【版本2】 我们当时采用的是spring cloud gateway中支持局部过滤器 RequestRateLimiter来做限流，使用的是令牌桶算法，可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量

### 限流常见的算法有哪些呢✔

比较常见的限流算法有漏桶算法和令牌桶算法 

漏桶算法是把请求存入到桶中，以固定速率从桶中流出，可以让我们的服务做到绝对的平均，起到很好的限流效果 

令牌桶算法在桶中存储的是令牌，按照一定的速率生成令牌，每个请求都要先申请令牌，申请到令牌以后才能正常请求，也可以起到很好的限流作用 

它们的区别是，漏桶和令牌桶都可以处理突发流量，其中漏桶可以做到绝对的平滑，令牌桶有可能会产生突发大量请求的情况，一般nginx限流采用的漏桶，spring cloud gateway中可以支持令牌桶算法

### 什么是CAP理论✔

CAP主要是在分布式项目下的一个理论。包含了三项，一致性、可用性、分区容错性 

- 一致性(Consistency)是指更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致(强一致性)，不能存在中间状态。 
- 可用性(Availability) 是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。 
- 分区容错性(Partition tolerance) 是指分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障

### 为什么分布式系统中无法同时保证一致性和可用性✔

首先一个前提，对于分布式系统而言，分区容错性是一个最基本的要求，因此基本上我们在设计分布式系统的时候只能从一致性（C）和可用性（A）之 间进行取舍。 

如果保证了一致性（C）：对于节点N1和N2，当往N1里写数据时，N2上的操作必须被暂停，只有当N1同步数据到N2时才能对N2进行读写请求，在N2 被暂停操作期间客户端提交的请求会收到失败或超时。显然，这与可用性是相悖的。 

如果保证了可用性（A）：那就不能暂停N2的读写操作，但同时N1在写数据的话，这就违背了一致性的要求。

### 什么是BASE理论✔

嗯，这个也是CAP分布式系统设计理论 

BASE是CAP理论中AP方案的延伸，核心思想是即使无法做到强一致性 （StrongConsistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。它的思想包含三方面： 

1、Basically Available（基本可用）：基本可用是指分布式系统在出现不可预知的故障的时候，允许损失部分可用性，但不等于系统不可用。 

2、Soft state（软状态）：即是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 

3、Eventually consistent（最终一致性）：强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。其本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

### 分布式事务解决方案✔

我们当时是xx项目，主要使用到的seata的at模式解决的分布式事务 seata的AT模型分为两个阶段： 

1、阶段一RM的工作：① 注册分支事务 ② 记录undo-log（数据快照）③ 执行业务sql并提交 ④报告事务状态 

2、阶段二提交时RM的工作：删除undo-log即可 

3、阶段二回滚时RM的工作：根据undo-log恢复数据到更新前 at模式牺牲了一致性，保证了可用性，不过，它保证的是最终一致性

### 分布式服务的接口幂等性如何设计✔

嗯，我们当时有一个xx项目的下单操作，采用的token+redis实现的，流程是这样的 

第一次请求，也就是用户打开了商品详情页面，我们会发起一个请求，在后台生成一个唯一token存入redis，key就是用户的id，value就是这个token， 同时把这个token返回前端 

第二次请求，当用户点击了下单操作会后，会携带之前的token，后台先到 redis进行验证，如果存在token，可以执行业务，同时删除token；如果不存在，则直接返回，不处理业务，就保证了同一个token只处理一次业务，就保证了幂等性 

### xxl-job路由策略有哪些✔

xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、 分片广播… 

### xxl-job任务执行失败怎么解决 ✔

有这么几个操作 

第一：路由策略选择故障转移，优先使用健康的实例来执行任务 

第二，如果还有失败的，我们在创建任务时，可以设置重试次数 

第三，如果还有失败的，就可以查看日志或者配置邮件告警来通知相关负责 人解决 

### 如果有大数据量的任务同时都需要执行，怎么解决✔

我们会让部署多个实例，共同去执行这些批量的任务，其中任务的路由策略是分片广播 

在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行就可以

## Dubbo

### Dubbo是什么

Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。

其核心部分包含：

- 集群容错：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
- 远程通讯：提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。
- 自动发现：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

### Dubbo和Spring Cloud有什么区别

最大的区别：

- Dubbo底层是使用Netty这样的NIO框架，是基于TCP协议传输的，配合以Hession序列化完成RPC通信;
- 而SpringCloud是基于Http协议+rest接口调用远程过程的通信，相对来说，Http请求会有更大的报文，占的带宽也会更多。但是REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。

模块区别：

- Dubbo主要分为服务注册中心，服务提供者，服务消费者，还有管控中心；
- 相比起Dubbo简单的四个模块，SpringCloud则是一个完整的分布式一站式框架，他有着一样的服务注册中心，服务提供者，服务消费者，管控台，断路器，分布式配置服务，消息总线，以及服务追踪等；

