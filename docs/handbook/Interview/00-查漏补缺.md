## Java基础

### 对象的创建过程

1. 类加载：当程序引用一个类时，Java虚拟机（JVM）会通过类加载器查找并加载该类的字节码文件。类加载是将类的字节码文件加载到内存，并在方法区中创建类的Class对象的过程。
2. 分配内存：在内存中为对象分配一块连续的内存空间，用于存储对象的实例变量。
3. 初始化零值：在内存中分配的空间被初始化为默认值，基本类型的实例变量被初始化为0或false，引用类型的实例变量被初始化为null。
4. 设置对象头信息：在对象头中存储对象的元数据，如哈希码、GC 信息、锁状态等。
5. **执行构造方法**：根据对象所属类的构造方法，执行相应的构造逻辑，完成对象的初始化。构造方法的执行会对对象的实例变量进行赋值操作，可以进行自定义的初始化逻辑。
6. **返回对象的引用**：对象创建完成后，返回一个指向该对象的引用，可以通过该引用来访问和操作对象的实例变量和方法。

值得注意的是，Java 中的对象创建是在堆内存中完成的，而不是栈内存。栈内存只存储了对象的引用，而真正的对象实例及其数据是分配在堆内存中的。

另外，如果对象是通过关键字 `new` 创建的，则会在堆内存中分配新的对象；如果是通过反射或克隆等方式创建的对象，则会相应地调用不同的机制来完成对象的创建过程。

### String为什么要设计成不可变的

保证数据的完整性、线程安全性、缓存的利用、安全性、效率优化

1. **保护数据的完整性**：

   不可变性确保了字符串对象的内容不会被修改。这是因为字符串被广泛用作映射关键字、缓存哈希码和网络传输中的标识符等，若可变，可能会导致数据的不一致性。

2. **线程安全性**：

   由于 String 对象的不可变性，多个线程可以共享同一个字符串对象，而无需担心静态条件和并发修改问题。这样简化了在多线程环境下对字符串的使用和处理，提高了线程安全性。

3. **缓存的利用**：

   由于 String 的不可变性，字符串对象可以被缓存，以便在需要时重复使用。例如，Java 中的字符串常量池就可以通过缓存相同的字符串值来提高内存利用率和性能。

4. **安全性**：

   在 Java 中，String 类作为参数传递给其他方法时，由于不可变性，你无需担心参数的值会被修改，从而增加了程序的可靠性和安全性。例如， 网络连接地址URL，文件路径path，反射机制所需要的String参数

5. **效率优化**：

   字符串不可变性允许进行一些额外的优化，加快了字符串的处理速度。例如，可以使用字符串的哈希值进行缓存、通过共享相同的字符串实例来节省内存，并且可以避免重复计算。

因为字符串不可变，所以可以用字符串池缓存，可以大大节省堆内存。而且还可以提前对hashcode进行缓存，更加高效

由于字符串是应用最广泛的数据结构，提高字符串的性能对提高整个应用程序的总体性能有相当大的影响。

### 反射机制的原理是什么

1、获取目标类的Class对象

2、根据Class对象实例获取Construct对象

3、使用Construct对象的newInstance()方法获取反射类对象

4、使用Class对象实例获取Method对象

5、根据Method实例调用invoke()方法

### 实现序列化和反序列化为什么要实现Serializable接口

在Java中实现Serializable这个接口是为了**支持对象的序列化和反序列化操作**，Serializable是Java提供的一个标记接口，它没有定义任何方法，只是起到一个标记的作用，当一个类实现了Serializable接口的时候，**表明这个类的对象可以被序列化成字节流，或者从字节流反序列化还原成对象**。

之所以要对序列化对象实现Serializable这个接口，有以下原因

1、**可以确保只有那些被设计为可序列化的类的对象才能被序列化**，这是一种类型安全性的保障，防止对不可序列化对象进行序列化操作

2、**它规范了类的行为，表示该类的对象可以被序列化**，通过判断对象是否实现了Serializable这个接口，可以遵循该规范，确保对象的序列化操作是否是合法的。

## Redis

### 如何保证缓存与数据库双写时的数据一致性

当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致

读操作：

- 缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间

写操作：

- 延迟双删【有脏数据风险】

  延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。

- **Redisson读写锁【强一致、性能低】**

  在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。
  排他锁底层使用也是setnx，保证了同时只能有一个线程操锁住的方法

  - 强一致性的，采用Redisson提供的读写锁

    ①共享锁：读锁readLock，加锁之后，其他线程可以共享读操作   

    ②排他锁：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作

- **异步的方案同步的数据**【最终一致】

  - 允许延时一致的业务，采用异步通知

    ①使用MQ中间件，更新数据之后，通知缓存删除

    - 数据库写入：当需要对数据库进行写操作时，首先更新数据库中的数据。
    - 发送消息：在数据库数据写入成功后，发送一条消息到消息队列。消息中包含了被更新的数据的标识符或其他必要信息。
    - 消费消息：消息队列中有一个消费者，负责监听并消费这些消息。一旦消费者接收到消息，它将根据消息中的信息执行相应的操作。
    - 更新 Redis 缓存：消费者从消息中获取到被更新的数据标识符后，它将根据标识符从数据库中读取最新的数据，并将这个数据更新到 Redis 缓存中，确保缓存与数据库保持一致。

    通过以上步骤，可以将 Redis 缓存与数据库的数据保持同步。当数据库数据发生变化时，消息队列中的消息将触发消费者执行相应的操作，以更新 Redis 缓存中对应的数据。

    ②利用canal中间件，不需要修改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据， 更新缓存即可。



### 缓存穿透、雪崩、击穿

#### 缓存穿透

- 缓存中不存在，数据库中也不存在

  就是说查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求查数据库

- 解决方案

  1. 缓存空数据

     - 查询返回的数据为空，仍把这个空结果进行缓存，将无效的key存放进redis中
     - 优点：实现简单，
     - 缺点：销毁内存，可能发送不一致的问题

  2. 使用布隆过滤器

     - 查询布隆过滤器，不存在，直接返回，存在（缓存预热时，预热布隆过滤器）查Redis，命中直接放回结果，查不到，查数据库，查到结果，存到Redis并返回结果。

       布隆过滤器主要是用于检索一个元素是否在一个集合中。

     - 优点：内存占用较小，没有多余key

     - 缺点：实现复制，存在误判

#### 缓存雪崩

- 某一个时刻出现大规模的key失效或Redis宕机，导致大量请求到达数据库，带来巨大压力

  就是说设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB 瞬时压力过重雪崩。与缓存击穿的区别： 雪崩是很多key，击穿是某一个key缓存。

- 解决方案

  - **给不同的key的TTL添加随机值**（主要）
    - 缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件
  - 利用Redis集群提高服务的可用性
  - 给缓存业务添加降级限流策略
  - 给业务添加多级缓存

注意：**降级限流可做为系统的保底策略，适用于穿透、击穿、雪崩**

#### 缓存击穿

- 高并发访问，某个热点的key失效，无数的请求访问，引起数据库的压力并发。

  就是说给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。

- 解决方案

  1. 互斥锁

     - 当缓存失效时，不立即去load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db的操作并回设缓存，否则重试get缓存的方法
     - 优点：强一致
     - 缺点：性能差

  2. 设置永不过期

     1. 物理不过期，针对热点key不设置过期时间

     2. 逻辑过期

        - ①：在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前 key设置过期时间 

          ②：当查询的时候，从redis取出数据后判断时间是否过期 

          ③：如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据， 这个数据不是最新

        - 优点：高可用，性能优

        - 缺点：不能保证数据绝对一致

### Redis主从复制的原理

1. 主从架构的核心原理
   - master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给 slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。  
2. 主从复制的断点续传
3. 无磁盘化复制
4. 过期key处理
   - slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。

## MySQL

### Hash索引和B+树索引的区别

### 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树

### 建索引的原则有哪些

## ==mysql-微服务==
