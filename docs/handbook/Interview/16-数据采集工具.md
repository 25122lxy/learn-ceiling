# 数据采集工具

## Flume

### 1.基本组成

1. `taildir source`

   1. 断点续传、多目录
   2. 那个版本：Apache 1.7
   3. 原理：持久化了`offset`到磁盘文件

2. `channel`（file channel /memory channel/kafka channel）

   | channel |               |                                    |
   | ------- | ------------- | ---------------------------------- |
   | memory  | 基于内存      | 效率高、可靠性低，默认100个event   |
   | file    | 基于磁盘      | 效率低、可靠性高，默认100万个event |
   | kafka   | 基于kafka磁盘 | 效率高、可靠性高                   |

   1. `kafka channel`>`memory channel`+`kafka sink`
   2. 有一个bug
      1. `kafkachannel`1.6产生的，有bug，携带header信息，1.7版本的时候解决了bug
   3. 怎么选？
      1. 如果对接`kafka`优先`kafka channel`
      2. 如果对接不是kafka
         1. 一般企业、普通日志，选效率高的：`memory`
         2. 金融、相关数据，选可靠性高的：`file`
      3. 

3. `hdfs sink`

   1. 小文件
      1. 滚动数据：半小时
      2. 滚动大小：128m（块大小）
      3. event 数量：0，表示禁用，每个event大小不一

4. 事务

   1. `source` -> `channel` ：put 事务
   2. `channel `-> `sink`：take事务



### 2.三个器（拦截器、选择器、监控器）

1. flume 拦截器
   1. eg
      1. ETL拦截器：采集log 的 flume，用来轻度清洗 JSON 格式不完整的数据
      2. 时间拦截器：消费kafka 的 flume，解决零点漂移的问题
   2. 实现` Interceptor`，重写4个方法
      1. 初始化
      2. 单 event 处理：处理逻辑，fastjson 转成 jsonobject， try catch
      3. 多 event 处理
      4. 关闭
   3. 实现静态内部类 Builder
   4. 打成 jar 包 -> 上传到flume 的 lib 下 -> 配置文件指定 全类名￥Builder‘
2. flume channel 选择器
   1. replicating：默认，一个 event 事件，发往所有的channel （广播）
   2. multiplexing：一个 event，发往指定的channel （分流）
   3. 默认用replicating
3. flume 监控器
   1. ganglia：
      1. 事务尝试提交的次数、事务成功提交的次数
      2. 如果两者差值较大，说明发生大量重试，有问题 -->优化

### 3.优化

1. 提高内存：默认不设置flume-env就是 20m，提高 4~6G（修改flume-env）
2. 增加台数：重大节日提高增加日志服务器
3. filechannel：指定多目录（多磁盘）



### 4.挂了

1. 尝试重启：
2. 影响范围：
   1. 丢数：
      1. `taildirsource` 有断点续传
      2. `channel`如果是 memory，会丢
      3. 事务
   2. 重复：`taildirsource`可能重复
   3. 最终保障：日志服务器的日志文件，保存30天
3. 定位问题：看日志
4. 解决问题：eg：OOM -> 加内存



## DataX



### 1.使用场景

- 采集MySQL的数据
- 首次加载历史数据、全量同步策略的表（主要是维表，数据量小，除了用户表）

​	

### 2.遇到的问题

1、空值问题

mysql		hive

null			\N

1）hive建表时，指定null的格式为''

2）改源码，增加 null 值转 \N 的逻辑

​		改 hdfswriter插件：代码增加了对 null 值的转换处理，如果是 NULL 值，转换成 \N

​		重新编译打包 hdfswriter 插件

​		替换掉原来的 hdfswriter 插件



### 3.优化

1、内存：4—8G，

2、并发：

调整 channel 数，3~5

3、channel 的速率：1M/S --> 5M/S



### 4.几点开始跑，跑多久

几个G（维表的全量：包含历史数据和增量数据）

每个的业务数据增量有多少？

​	百万日活、10-20万订单对应10条数据，每条数据平均1K

​	20万*10条*1K = 2G



### 5.DataX有什么缺陷？与Sqoop的区别

Sqoop：已经停止维护

DataX：单进程多线程，单机的，不是分布式

数据量大时候，DataX  x1、x2、x3



## Maxwell

### 1.原理

伪装成 MySQL 的从库，同步主库的 binlog 

binlog 的解析格式：row 。。。



### 2.为什么要用它

DataX不能做增量吗？---可以，通过时间字段筛选，create time、update time

未来实时要用，同步的是事实表，用户表



### 3.Maxwell 和 Canal 为什么用 Maxwell

支持历史数据同步

格式更轻量

支持断点还原



### 4.Maxwell 同步历史数据的时候，怎么保证一致性

只能保证至少一次（可能重复）

比如：同步历史数据的过程中，原表新增了数据，Bootstrap会拿到，Maxwell 监听 binlog 也会拿到



## Sqoop

### 1.Sqoop参数

```sh
/opt/module/sqoop/bin/sqoop import \
--connect \
--username \
--password \
--target-dir \
--delete-target-dir \
--num-mappers \
--fields-terminated-by  \
--query  "$2" ' and $CONDITIONS;'
```



### 2. Sqoop导入导出Null存储一致性问题

Hive中的Null在底层是以“\N”来存储，而MySQL中的Null在底层就是Null，为了保证数据两端的一致性。在导出数据时采用--input-null-string和--input-null-non-string两个参数。导入数据时采用--null-string和--null-non-string。

### 3. Sqoop数据导出一致性问题

场景1：如Sqoop在导出到Mysql时，使用4个Map任务，过程中有2个任务失败，那此时MySQL中存储了另外两个Map任务导入的数据，此时老板正好看到了这个报表数据。而开发工程师发现任务失败后，会调试问题并最终将全部数据正确的导入MySQL，那后面老板再次看报表数据，发现本次看到的数据与之前的不一致，这在生产环境是不允许的。

官网：http://sqoop.apache.org/docs/1.4.6/SqoopUserGuide.html

Since Sqoop breaks down export process into multiple transactions, it is possible that a failed export job may result in partial data being committed to the database. This can further lead to subsequent jobs failing due to insert collisions in some cases, or lead to duplicated data in others. You can overcome this problem by specifying a staging table via the --staging-table option which acts as an auxiliary table that is used to stage exported data. The staged data is finally moved to the destination table in a single transaction.

–staging-table方式

sqoop export --connect jdbc:mysql://192.168.137.10:3306/user_behavior --username root --password 123456 --table app_cource_study_report --columns watch_video_cnt,complete_video_cnt,dt --fields-terminated-by "\t" --export-dir "/user/hive/warehouse/tmp.db/app_cource_study_analysis_${day}" --staging-table app_cource_study_report_tmp --clear-staging-table --input-null-string '\N'

### 4. Sqoop底层运行的任务是什么

只有Map阶段，没有Reduce阶段的任务。默认是4个MapTask。

### 5. Sqoop一天导入多少数据

100万日活=》10万订单，1人10条，每天1g左右业务数据

Sqoop每天将1G的数据量导入到数仓。

### 6. Sqoop数据导出的时候一次执行多长时间

每天晚上00:10开始执行，Sqoop任务一般情况20-30分钟的都有。取决于数据量（11.11，6.18等活动在1个小时左右）。

### 7. Sqoop在导入数据的时候数据倾斜

Sqoop参数撇嘴： split-by：按照自增主键来切分表的工作单元。

num-mappers：启动N个map来并行导入数据，默认4个；

### 8. Sqoop数据导出Parquet（项目中遇到的问题）

Ads层数据用Sqoop往MySql中导入数据的时候，如果用了orc（Parquet）不能导入，需转化成text格式

（1）创建临时表，把Parquet中表数据导入到临时表，把临时表导出到目标表用于可视化

（2）ads层建表的时候就不要建Parquet表

### 举例说明

```sh
#从hdfs上导入本地mysql中

sqoop export --connect jdbc:mysql://192.168.137.1/yd --username root -password 123456 --export-dir /bigdata/hivedata/movie1/000000_0 -m 1 --table m1 --fields-terminated-by '\t'

sqoop export --connect jdbc:mysql://192.168.137.1/yd --username root -password 123456 --export-dir /bigdata/hivedata/movie2/000000_0 -m 1 --table m2 --fields-terminated-by '\t'


sqoop export --connect jdbc:mysql://192.168.137.1/yd --username root -password 123456 --export-dir /bigdata/hivedata/university1/000000_0 -m 1 --table u1 --fields-terminated-by '\t'

sqoop export --connect jdbc:mysql://192.168.137.1/yd --username root -password 123456 --export-dir /bigdata/hivedata/university2/000000_0 -m 1 --table u2 --fields-terminated-by '\t'

sqoop export --connect jdbc:mysql://192.168.137.1/yd --username root -password 123456 --export-dir /bigdata/hivedata/university3/000000_0 -m 1 --table u3 --fields-terminated-by '\t'


```

