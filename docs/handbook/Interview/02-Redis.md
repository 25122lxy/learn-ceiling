# Redis

## Redis基础

### Redis是什么？简述它的优缺点✔❗

- redis是一个key-value 类型的内存数据库，很像Memcached，<font color=red>**整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存**</font>

- **优点**
  
  - 1、读写性能极高，110000次/s，81000次/s
  
  - 2、支持数据持久化（AOF、RDB）
  
  - 3、**支持事务**
  
    Redis 提供了简单的事务支持，通过 MULTI 和 EXEC 命令可以对一批命令进行原子性的执行。这意味着在一个事务中的多个命令要么全部执行成功，要么全部执行失败。这样可以确保在并发环境下保持数据的一致性。
  
  - 4、数据结构丰富，string、list、hash、set、sortset
  
  - 5、支持主从复制
  
  - 6、发布订阅功能
  
    Redis 支持发布与订阅模式，可以轻松实现消息队列系统。发布者可以将消息发送到特定的频道，而订阅者则可以订阅感兴趣的频道并接收消息。这种发布订阅模式使得 Redis 可以用于构建实时消息系统、实时推送系统等。
  
  - 7、分布式锁支持
  
    Redis 中的分布式锁机制能够帮助解决并发场景下的资源竞争问题。利用 Redis 提供的原子性操作和 SETNX（SET if Not eXists）命令，可以实现简单而可靠的分布式锁，从而保证了数据访问的互斥性。
  
- 缺点

  - 1、不适用于海量数据的高性能读写
  - 2、主从架构，降低了系统的可用性（主机宕机造成的数据不一致问题）

### Redis为什么这么快✔❗

- 1、基于内存存储，没有磁盘上的开销
- 2、单线程实现，单线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销
- **3、非阻塞IO，使得处理大量并发请求而不会出现阻塞情况**
- 4、提供了多种数据结构，并对每种数据结构进行了高度优化
- 5、内部使用的底层模式不同，实现了多种优化机制

> - **阻塞IO**
>
> 顾名思义，阻塞IO就是两个阶段都必须阻塞等待
>
> - **非阻塞IO**
>
> 顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。
>
> **解释一下I/O多路复用模型？** 
>
> I/O多路复用是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I/O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。
>
> 其中Redis的网络模型就是使用I/O多路复用结合事件的处理器来应对多个Socket请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；
>
> 在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程
>
> **IO多路复用**：是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。
>
> **IO多路复用**是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听Socket的方式、通知的方式又有多种实现，常见的有：
>
> lselect
>
> lpoll
>
> lepoll
>
> 差异：
>
> uselect和poll只会通知用户进程有Socket就绪，但不确定具体是哪个Socket ，需要用户进程逐个遍历Socket来确认
>
> uepoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间

### Redis和Memcached有哪区别❕

- 1、数据类型

   Memcached所有的值均是简单的字符串，Redis支持更为丰富的数据类型，支持string(字符串)，list(列表)，Set(集合)、Sorted Set(有序集合)、Hash(哈希)等。

- 2、持久化

   **Redis支持数据落地持久化存储，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用**。 memcache不支持数据持久存储 。

- 3、集群模式

   **Redis提供主从同步机制，以及 Cluster集群部署能力，能够提供高可用服务**。Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据

- 4、性能对比

   在读取方面，Redis的性能更高，可以达到百万级的QPS；在写入方面，Memcached的性能略高于Redis。

- 5、网络IO模型（处理并发的方式不同）

   - Redis使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞IO模式。
   - Redis采用单线程模型来处理所有的客户端请求和对数据的操作，通过异步I/O和事件驱动的方式来处理请求，可以高效地处理多个客户端连接。而Memcached采用多线程模型来处理请求，每个客户端连接由一个独立的线程来处理。

- 6、redis支持服务器端的数据操作

   - Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。
   - 在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。

### 为什么要用redis做缓存❕

<font  color=red>**1、高并发**</font>

- 将部分数据缓存到redis上，避免请求数据库，导致数据库压力过大

<font color=red>**2、高性能**</font>

- 第一次请求数据库是从硬盘读取，速度较慢
- 使用Redis后，直接操作内存，速度较快

### 为什么要用redis而不用map/guava做缓存

- 1、速度
- 2、数量
- 3、**持久化**
- 4、主从
- 5、**稳定性**
- 6、**数据类型**
- 7、Redis可单独部署，多个项目之间可以共享，本地内存无法共享
- 8、Redis有专门的管理工具可以查看缓存数据
- 9、过期策略
- 10、生态系统
- 11、分布式

### Redis的常用场景有哪些✔

**技术上：**

- **缓存：穿透、击穿、雪崩、双写一致、持久化、数据过期、淘汰策略**
- **分布式锁：setnx、redisson**
- **计数器**
- **保存token：数据类型**
- **消息队列**：数据类型
- **延迟队列**：数据类型

**业务上**：使用缓存的主要目的是提高系统的性能、减轻后端数据库的压力，并能够更好地应对高并发的访问需求。下面是一些常见的场景，适合使用缓存：

- 高频读取的数据：将经常被读取的数据缓存在内存中，减少对数据库的频繁查询，提高读取性能。
- 热点数据：将热点数据缓存起来，避免频繁访问数据库，提高系统的响应速度。
- 大量计算的结果：将计算结果缓存起来，避免重复计算，减少系统负载。
- 频繁更新的数据：将频繁更新的数据缓存起来，减少对数据库的写入操作，提高写入性能。
- 限流和防护：使用缓存来实现简单的限流和防护机制，减轻系统的压力。
- 分布式系统的数据共享：在分布式系统中，使用缓存来共享数据，减少跨网络的数据传输，提高系统的性能和稳定性。
- 排行榜、计数器、分布式会话、分布式锁、社交网络、最新列表、消息系统


### Redis的数据类型有哪些，每种数据类型的使用场景✔

**常用**

- 1、字符串：`String`

  String 是 Redis 最基本的数据类型之一，它可以存储字符串、整数或浮点数。String 中的每个键值对都是一个字符串和一个对应的值。

  使用场景：

  - 缓存：String 可以用于存储缓存数据，例如存储网站的首页内容、用户的个人信息等。
  - 计数器：String 可以用于存储计数器，例如存储网站的 PV、UV 等统计数据。
  - 分布式锁：String 可以用于实现分布式锁，通过给某个 key 设置一个唯一的值作为锁标识，来实现互斥访问。

- 2、哈希：`Hash`

  Hash 是一个键值对集合，它类似于 Java 中的 Map，可以用于存储对象或复杂数据类型。

  使用场景：

  - 存储对象：Hash 可以用于存储对象，例如存储用户的个人信息、商品的详细信息等。
  - 计数器：Hash 可以用于存储计数器，例如存储网站的 PV、UV 等统计数据。

- 3、列表：`List`

  List 是一个有序的、可重复的集合，它支持在头部和尾部添加元素，以及在指定位置插入和删除元素。

  使用场景：

  - 消息队列：List 可以用于实现消息队列，例如存储用户的通知消息、任务队列等。
  - 时间序列：List 可以用于存储时间序列数据，例如存储股票价格、气温、汇率等历史数据。

- 4、集合：`set`

  Set 是一个无序的、不可重复的集合，它可以执行交集、并集、差集等操作。

  使用场景：

  - 好友列表：Set 可以用于存储用户的好友列表，支持快速查找某个用户是否为当前用户的好友。
  - 共同关注：Set 可以用于存储多个用户共同关注的内容或话题，支持快速查找某个内容或话题被哪些用户关注。

- 5、有序集合：`sort set`

  Sorted Set 是一个有序的、不可重复的集合，它支持按照分值（score）排序，并且可以执行交集、并集、差集等操作。

  使用场景：

  - 排行榜：Sorted Set 可以用于实现排行榜功能，例如存储游戏得分、社交平台的粉丝数等。
  - 限流：Sorted Set 可以用于实现限流功能，例如存储某个 API 的访问次数、时间戳等信息。

其他

- 1、**地理位置**：`Geo`
- 2、**位图**：`Bitmap`
- 3、`Hyperloglog`
- 4、流：`stream`

### Redis大key怎么处理✔❗

Redis中的大key指的是在Redis中存储的某个key对应的value数据量很大的情况下可能会出现的问题和解决办法

<font color=red>**引发的问题**</font>

- 1、内存占用

   大key占用大量的内存资源，导致Redis实例的内存压力增加

- 2、网络传输延迟

   大key的读写操作，可能会增加网络传输的延迟，影响性能

- 3、持久化备份

   大key的持久化备份需要更多的磁盘空间和时间

**解决办法**

- 1、把大key分割成多个小key来存储，可以减少单个key的大小，降低内存压力
- 2、搭建Redis cluster 集群，把key分配到不同的hash slot槽所在的分片上，这样可以降低单个Redis节点的存储压力
- 3、**如果已经存在大key，可以做数据的拆分和迁移，按照业务需求和规则将大key拆分成多个小key，并分布到不同Redis实例上，然后在迁移完了之后清理调用不需要使用的大key**
- 4、可以考虑使用压缩算法进行压缩去减少存储空间的占用，也就是说在存储数据之前对数据进行压缩，在读取的时候进行解压缩，以节省存储空间和减少网络传输的数据量
- 5、**从业务层面进行分析，了解大key产生的原因，并根据需求和访问模式进行相应的优化**

### Redis，一个字符串类型的值能存储最大容量是多少

在 Redis 中，一个字符串类型的值最大可以存储 512 MB 的数据。这是因为 Redis 在实现上采用了一种叫作简单动态字符串（Simple Dynamic String，SDS）的数据结构来存储字符串类型的值。SDS 的实现方式决定了 Redis 可以存储的字符串类型的值最大长度不超过 512 MB。

但是，由于 SDS 在实现上需要预留一些空间来存储字符串的长度信息和其他一些元数据，因此它的内存使用效率不如普通 C 字符串高。因此，如果需要存储非常大的字符串类型的值，建议使用 Redis 的其他数据结构来存储，比如 Redis 的列表、哈希表、集合等。

### 一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素

1、Redis 的每个实例能够存放的 keys 的数量理论上是没有限制的，这取决于系统的可用内存大小。Redis 将所有的数据存储在内存中，因此实际能够存放的 keys 数量受到系统内存的限制。如果系统的可用内存不足以容纳所有的数据，Redis 会根据预设的策略进行内存淘汰，删除一些不常用的数据。

2、关于不同数据类型的存放元素的数量限制如下：

- List（列表）：Redis 的列表数据结构可以存放最多约 2^32 - 1 个元素，即大约 42 亿个元素。
- Set（集合）：Redis 的集合数据结构可以存放最多约 2^32 - 1 个元素，即大约 42 亿个元素。
- Sorted Set（有序集合）：Redis 的有序集合数据结构可以存放最多约 2^32 - 1 个元素，即大约 42 亿个元素。

需要注意的是，虽然 Redis 没有对存放 keys 和元素数量做出硬性限制，但实际使用时应根据系统的可用内存和性能需求来控制数据量，避免过度占用内存导致性能下降。

## 持久化

### Redis持久化机制✔

- 1、`RDB`快照 【Redis Database Backup file（Redis数据备份文件）】
  
  - **简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据（宕机会丢失最后一次快照后的数据）**
  
    Redis主动备份
  
    ```shell
    save #由Redis主进程来执行RDB，会阻塞所有命令
    bgsave #开启子进程执行RDB，避免主进程受到影响
    ```
  
    Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：
  
    ```shell
    # 900秒内，如果至少有1个key被修改，则执行bgsave 
    save 900 1  
    save 300 10  
    save 60 10000 
    ```
  
- 2、`AOF`追加文件【Append Only File（追加文件）】
  
  - 将redis中所有写指令记录写下来，以日志的方式追加后面
  
    **就是说当redis操作写命令的时候，都会存储这个文件中， 当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据**
  
  要在Redis中启用AOF（Append Only File）持久化，您可以按照以下步骤进行操作：
  
  - 1）打开 Redis 配置文件。默认情况下，配置文件位于 `/etc/redis/redis.conf`。
  
     ```shell
     sudo nano /etc/redis/redis.conf
     ```
  
  - 2）在配置文件中找到 `appendonly` 项，并将其设置为 `yes`，即打开AOF持久化。
  
     ```
     appendonly yes
     ```
  
  - 3）如果您希望每次更新都立即写入磁盘，可以将 `appendfsync` 设置为 `always`。这样会降低性能，但会提供更高的持久化保证。
  
     ```
     appendfsync always
     ```
  
     如果您希望在后台每秒钟同步一次，可以将 `appendfsync` 设置为 `everysec`。
  
     ```
     appendfsync everysec
     ```
  
  - 4）保存并关闭配置文件。
  
  - 5）重新启动 Redis 服务以使更改生效。
  
     ```shell
     sudo systemctl restart redis
     ```
  
  现在，Redis已经启用了AOF持久化功能。Redis会将每个写命令追加到AOF文件中，以确保数据的持久化存储。在服务器重新启动时，Redis将通过重播AOF文件来还原数据。请注意，启用AOF持久化可能会增加系统的磁盘IO负载。

RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF 文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令

### 如何选择合适的持久化方式  

- 数据不敏感：可以关闭持久化
- 数据比较重要：使用`rdb`
- 做内存数据库，使用Redis的持久化：`rdb+aof`

### Redis持久化数据和缓存怎么做扩容

- 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。
- 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。

对于 Redis 的持久化数据和缓存扩容，有一些不同的方法可以考虑：

- 1、**持久化数据扩容**：如果你使用 Redis 的持久化功能（比如 RDB 持久化或 AOF 持久化），在需要扩容时，可以考虑以下步骤：
   - **备份数据**：首先，对现有数据进行备份，确保数据的安全性。
   - **启动新实例**：启动一个新的 Redis 实例，并根据需要进行配置调整（比如设置更大的内存、调整持久化方式等）。
   - **数据迁移**：将备份的数据导入到新实例中，可以使用工具如 Redis 的 `BGSAVE` 和 `BGRESTORE` 命令，或者第三方工具进行数据迁移。
   - **切换应用到新实例**：在数据迁移完成后，修改应用程序的配置，使其连接到新的 Redis 实例。

- 2、**缓存扩容**：如果你是在考虑扩展 Redis 缓存的容量和性能，可以考虑以下方法：
   - **集群部署**：Redis 提供了集群模式，通过搭建 Redis 集群来实现缓存的水平扩展，这样可以分散数据和请求负载。
   - **使用代理**：使用诸如 Twemproxy 或 Codis 等代理，可以将请求分发到多个 Redis 实例上，以增加缓存容量和性能。
   - **增加硬件资源**：增加单个 Redis 节点的内存或性能，比如升级服务器配置或者使用更高性能的存储介质。

无论是对持久化数据还是缓存的扩容，都需要谨慎操作，尤其是在生产环境中。在进行扩容操作之前，务必做好充分的备份和测试，以确保数据安全和系统稳定。

## 过期键的删除策略、淘汰策略

### Redis过期键的删除策略（Redis回收使用的是什么算法）✔❗

- 定时删除
  - 过期时间到来时，对其执行删除
  - 对CPU不友好，对内存友好
  
- **惰性删除**

  在设置该key过期时间后，我们不去管它，当需要该key 时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。

  - 这种策略是最简单的，它将过期键的删除工作推迟到了客户端访问时才进行。这样做的好处是避免了在过期键上浪费不必要的 CPU 资源。但是，如果一个过期键很久没有被访问，那么它就一直占据着内存
  - 对内存不友好，对CPU友好

- **定期删除**

  就是说每隔一段时间，我们就对一些key进行检查，删除里面过期的key

  - Redis 使用一个定时任务来主动删除一部分过期键。
  - 在每个 Redis 数据库中，都有一个定时器每隔一定时间执行一次。定时器会扫描数据库中的部分键，检查它们是否过期。如果过期，则删除该键。
  
  - 优缺点：
  
    优点：减少内存占用、简单高效
  
    缺点：会给CPU带来一定的负担，无法处理访问频繁的键（如果某个键一直被频繁访问，那么定期删除机制可能无法及时清理该键，导致过期键继续占用内存。）

惰性删除	+	定期删除两种策略进行配合使用。

### Redis key的过期时间和永久有效分别怎么设置

- 1、设置过期时间： 使用命令 `EXPIRE key seconds` 可以将键 `key` 设置为 `seconds` 秒后过期。例如，要将键 `mykey` 设置为 60 秒后过期，可以执行以下命令：

  ```bash
  Copy CodeEXPIRE mykey 60
  ```

  如果键已存在且设置成功，命令返回 1；如果键不存在或设置失败，命令返回 0。

- 2、设置永久有效： 使用命令 `PERSIST key` 可以将键 `key` 设置为永久有效，即取消键的过期时间。例如，要使键 `mykey` 永久有效，可以执行以下命令：

  ```bash
  Copy CodePERSIST mykey
  ```

  如果键存在且成功取消过期时间，命令返回 1；如果键不存在或取消失败，命令返回 0。

### Redis内存淘汰策略✔（缓存过多，内存被占满了怎么办）

当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。

Redis支持8种不同策略来选择要删除的key：

- 1、noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，**默认就是这种策略**。
- 2、volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰
- 3、allkeys-random：对全体key ，随机进行淘汰。
- 4、volatile-random：对设置了TTL的key ，随机进行淘汰。
- 5、allkeys-lru： 对全体key，基于LRU算法进行淘汰
- 6、volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰
- 7、allkeys-lfu： 对全体key，基于LFU算法进行淘汰
- 8、volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰

> **LRU**（**L**east **R**ecently **U**sed）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。
>
> **LFU**（**L**east **F**requently **U**sed）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。
>
> **数据淘汰策略-使用建议**
>
> 1.优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。
>
> 2.如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 allkeys-random，随机选择淘汰。
>
> 3.如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。
>
> 4.如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。、
>
> **关于数据淘汰策略其他的面试问题**
>
> 1.数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ? 
>
> 使用allkeys-lru(挑选最近最少使用的数据淘汰)淘汰策略，留下来的都是经常访问的热点数据
>
> 2.Redis的内存用完了会发生什么？
>
> 主要看数据淘汰策略是什么？如果是默认的配置（ noeviction ），会直接报错

- 通常使用` allkeys-lru：`移除最近最少使用的key

## 缓存异常

### 如何保证缓存与数据库双写时的数据一致性✔❤❗

当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致

读操作：

- 缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间

写操作：

- 1、延迟双删【有脏数据风险】

  延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。

- 2、**Redisson读写锁【强一致、性能低】**

  在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。
  排他锁底层使用也是setnx，保证了同时只能有一个线程操锁住的方法

  - 强一致性的，采用Redisson提供的读写锁

    ①共享锁：读锁readLock，加锁之后，其他线程可以共享读操作   

    ②排他锁：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作

- 3、**异步的方案同步的数据**【最终一致】

  可以将缓存更新操作和数据库更新操作分别发送到消息队列中，由消息队列来完成数据同步操作。这种方式可以大大降低并发情况下的性能开销，并且可以保证数据一致性。

  - 允许延时一致的业务，采用异步通知

    ①使用MQ中间件，更新数据之后，通知缓存删除
  
    - 数据库写入：当需要对数据库进行写操作时，首先更新数据库中的数据。
    - 发送消息：在数据库数据写入成功后，发送一条消息到消息队列。消息中包含了被更新的数据的标识符或其他必要信息。
    - 消费消息：消息队列中有一个消费者，负责监听并消费这些消息。一旦消费者接收到消息，它将根据消息中的信息执行相应的操作。
    - 更新 Redis 缓存：消费者从消息中获取到被更新的数据标识符后，它将根据标识符从数据库中读取最新的数据，并将这个数据更新到 Redis 缓存中，确保缓存与数据库保持一致。
  
    通过以上步骤，可以将 Redis 缓存与数据库的数据保持同步。当数据库数据发生变化时，消息队列中的消息将触发消费者执行相应的操作，以更新 Redis 缓存中对应的数据。
  
    ②利用canal中间件，不需要修改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据， 更新缓存即可。、

### 缓存击穿原因，解决方案✔❤

- 高并发访问，某个热点的key失效，无数的请求访问，引起数据库的压力并发。

  就是说给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。

- 解决方案：
  
  - 1、**互斥锁**
  
     - 当缓存失效时，不立即去load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db的操作并回设缓存，否则重试get缓存的方法
     - 优点：强一致
     - 缺点：性能差
  
  - 2、**设置永不过期**
  
     - 1）物理不过期，针对热点key不设置过期时间
  
     - 2）逻辑过期
  
        - ①：在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前 key设置过期时间 
  
          ②：当查询的时候，从redis取出数据后判断时间是否过期 
  
          ③：如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据， 这个数据不是最新
  
        - 优点：高可用，性能优
  
        - 缺点：不能保证数据绝对一致

### 缓存穿透原因，解决方案✔

- 缓存中不存在，数据库中也不存在

  就是说查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求查数据库

- 解决方案
  
  - 1、缓存空数据
  
     - 查询返回的数据为空，仍把这个空结果进行缓存，将无效的key存放进redis中
     - 优点：实现简单，
     - 缺点：销毁内存，可能发送不一致的问题
  
  - 2、使用布隆过滤器
  
     - 查询布隆过滤器，不存在，直接返回，存在（缓存预热时，预热布隆过滤器）查Redis，命中直接放回结果，查不到，查数据库，查到结果，存到Redis并返回结果。
  
       布隆过滤器主要是用于检索一个元素是否在一个集合中。
  
     - 优点：内存占用较小，没有多余key
  
     - 缺点：实现复制，存在误判

### 缓存雪崩原因，解决方案✔

- 某一个时刻出现大规模的key失效或Redis宕机，导致大量请求到达数据库，带来巨大压力

  就是说设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB 瞬时压力过重雪崩。与缓存击穿的区别： 雪崩是很多key，击穿是某一个key缓存。

- 解决方案
  - 1、**给不同的key的TTL添加随机值**（主要）
    
    缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件
    
  - 2、给缓存业务添加降级限流策略
  
    降级指的是暂时关闭或减少某些功能或服务的访问权限或处理能力。
  
    限流是指对系统的请求进行限制或控制，确保在系统处理能力范围内，只允许一定数量的请求进入。
  
  - 3、给业务添加多级缓存
  
    例如：可以使用本地缓存（如内存）与 Redis 缓存结合使用，本地缓存用于快速读取频繁访问的数据，Redis 缓存用于读取较少访问但仍然需要缓存的数据。
  
  - 4、设置永不过期

注意：**降级限流可做为系统的保底策略，适用于穿透、击穿、雪崩**

### 什么是缓存预热

指系统上线后，提前将相关的缓存数据加载到缓存系统

### 什么是缓存降级

在缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。  

## 线程模型

### Redis为何选择单线程❕

- Redis是基于内存操作，执行速度非常快，Redis真正的性能瓶颈在于网络I/O
- 选择单线程的原因：
  - 1、避免过多的上下文切换开销
     - 如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。
  - 2、**简单可维护**
     - 如果 Redis使用多线程模式，那么所有的底层数据结构都必须实现成线程安全的，这无疑又使得 Redis的实现变得更加复杂。
  - 3、<font color=blue>**避免同步机制的开销**</font>
     - 如果 Redis选择多线程模型，又因为 Redis是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，可能会导致在操作数据过程中带来很多加锁解锁的开销，增加程序复杂度的同时还会降低性能。

### Redis真的是单线程

Redis6.0引入多线程I/O，只是用来处理网络数据的读写和协议的解析，而执行命令依旧是单线程。  

- 1、网络通信：Redis 使用一个主线程（也称为事件循环线程）来监听网络连接，接收请求，并将请求分发给多个工作线程进行处理。这样可以提高并发处理能力，允许同时处理多个客户端的请求。
- 2、数据读写：Redis 在数据读写操作时，使用了多个工作线程来并行处理多个请求。这种多线程的设计可以使得 Redis 在处理大量读写请求时能够更高效地利用多核 CPU 的计算能力。

### Redis6.0为何引入多线程

Redis的单线程模式会导致系统消耗很多CPU，在网络I/O上从而降低吞吐量

### Redis6.0采用多线程后，性能提升效果如何

Redis 作者 antirez 在 RedisConf 2019 分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是 一倍以上。 

国内也有大牛曾使用 unstable 版本在阿里云 esc 进行过测试，GET/SET 命令在 4 线程 IO 时性能相比单线程是几乎是翻倍了

### 介绍下Redis的线程模型

Redis采用单线程模型，即所有的请求都是由一个线程来处理的。这个线程负责接收客户端的请求，解析命令，执行命令，并将结果返回给客户端。在处理客户端请求时，Redis采用事件驱动模型，通过epoll机制监听网络连接事件，当有事件触发时，Redis会将该事件放入事件队列中，然后由主线程统一处理事件队列中的事件。通过这种方式，Redis可以实现高性能的数据读写操作，并且可以避免多线程带来的线程同步等问题。

### Redis 6.0 多线程的实现机制

流程简述如下： 

- 1、主线程负责接收建立连接请求，获取 Socket 放入全局等待读处理队列。 
- 2、主线程处理完读事件之后，通过 RR（Round Robin）将这些连接分配给这些 IO 线程。 
- 3、主线程阻塞等待 IO 线程读取 Socket 完毕。 
- 4、主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行。 
- 5、主线程阻塞等待 IO 线程将数据回写 Socket 完毕。

该设计有如下特点： 

- IO 线程要么同时在读 Socket，要么同时在写，不会同时读或写。 
- IO 线程只负责读写 Socket 解析命令，不负责命令处理。

### Redis6.0开启多线程后，是否会存在线程并发安全问题

（不考虑线程安全问题）

- Redis多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行

### Redis6.0与Memcached多线程模型的对比❕

- 相同点：都采用了Master线程-worker线程的模型
- 不同点
  - Memcached执行逻辑也是在worker线程里，模型更加简单，符合线程隔离
  - Redis执行逻辑交给Master线程，增加了模型复杂度，解决了线程并发安全等问题

## 事务

### Redis事务的概念

- Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。 鉴于这个原因，所以**说Redis的事务严格意义上来说是不具备原子性的**。
- Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 
- <font color=blue>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。**然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行**。  </font>

### Redis事务的三个阶段❕

1、开启事务（`multi`）

2、大量指令入队（`Queueing`）

3、执行事务块内命令（`exec`截止此处，一个事务已经结束）

- `discard`取消事务
- `watch`监视一个或多个key，如果事务执行前key被改动，事务将打断，`unwatch`取消监视。
- 【如果执行过程中，服务端收到其他命令请求，会将请求放入到队列中排队】

### Redis事务相关命令

- `Watch`监控一个或多个键，持续到EXEC命令
- `Multi`开启事务
- `Exec`执行事务内命令
- `Discard`取消事务
- `UnWatch`取消对所有key的监控

### Redis事务支持隔离性吗

- Redis是单线程程序，Redis事务总数带有隔离性的

### Redis为什么不支持事务回滚

- **Redis命令只会因为错误的语法而失败**，或是命令用在了错误类型的键上面，失败的命令是由编程错误造成的，而这些错误应该在开发过程中被发现，而不应该出现在生产环境中

### Redis事务其他实现

除了 Redis 的 MULTI/EXEC 命令之外，还有其他一些方式可以实现事务操作：

- 1、WATCH 命令：WATCH 命令可以用来监视一个或多个键，当这些键被其他客户端修改时，事务会被取消。可以通过在 EXEC 命令执行之前使用 WATCH 命令来确保事务的原子性。
- 2、Lua 脚本：Redis 支持使用 Lua 脚本执行复杂的事务操作。通过将多个命令组合成一个 Lua 脚本，并使用 EVAL 命令执行，可以保证脚本中的所有命令都会原子地执行。
- 3、Pipeline 批量操作：Pipeline 可以用来批量执行多个命令，减少网络开销。虽然 Pipeline 本身并不提供事务的原子性，但是可以通过 Pipeline 配合 WATCH 命令实现类似事务的效果。
- 4、乐观锁：乐观锁是一种基于版本号或时间戳的并发控制机制。在执行事务之前，先获取被操作键的当前版本号或时间戳，执行事务期间监测键是否被其他客户端修改，如果没有修改则提交事务，否则回滚。

需要注意的是，尽管 Redis 提供了一些机制来实现事务，但由于 Redis 是单线程的，无法保证多个客户端同时执行事务的原子性。因此，在高并发环境下，需要谨慎使用 Redis 的事务功能，并结合其他技术手段来确保数据的一致性和并发控制。

### 了解Redis事务的CAS操作吗

在Redis中，事务是一组命令的集合，它们作为一个单元进行执行。Redis事务提供了原子性、隔离性和一致性。在一个事务中，所有命令都会被当作一个整体执行，而且不会被其他客户端的命令所干扰。

CAS操作是Redis事务中的一种操作类型。CAS即“Compare-And-Set”（比较并设置），也被称为乐观锁。它是一种在并发环境下保证数据一致性的机制。CAS操作需要先读取一个值，然后和预期值进行比较，如果相等，则将新值写入，否则不作任何处理。

在Redis事务中，可以使用WATCH命令来监听一个或多个键的变化情况。当调用EXEC命令时，Redis会检查在WATCH命令之后是否有对监听的键进行过修改，如果有，则事务回滚，否则事务中所有的命令都会被执行。

在Redis事务中，你可以使用MULTI和EXEC命令来开始和提交事务。在事务中执行的所有命令都是以队列的形式存储在服务器上，直到调用EXEC命令时才会被执行。

## 主从、哨兵、集群

### Redis常见使用方式有哪些✔

- 1、单副本
  - 数据量少适用
- 2、**多副本（主从）**
  - 可用性不高，基本不用（master节点挂掉之后需要手动指定新的master）
- 3、**Sentinel（哨兵）**
  - 数据量不是很多，集群规模不是很大，需要自动容错的时候适用
- 4、**Cluster（Redis分片集群）**
  - 海量数据+高并发+高可用的场景
- 5、自研

### 介绍下Redis的单副本

- 单个Redis节点部署架构
- **优点：**
  - 部署简单
  - 性价比高
  - 高性能
- **缺点：**
  - 不能保证数据的可靠性，没有备用节点
  - 适合操作命令简单、排序、计算较少的场景

### 介绍下Redis多副本（主从）✔

- 主从部署架构，提高数据持久化和备份策略
- **优点：**
  - 可靠性高
  - 读写分离
- **缺点：**
  - 故障恢复复杂
  - 主库写能力和存储能力受到单机的线程

### 介绍一下主从同步✔

单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中

### 主从同步数据的流程✔

主从同步分为了两个阶段，一个是全量同步，一个是增量同步 

全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：

第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id 和offset偏移量。

第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。

第三：在同时**主节点会执行bgsave，生成rdb文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的rdb文件，这样就保持了一致**

当然，**如果在rdb生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步**

**增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还需要判断是不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步**

###  介绍下Redis Sentinel（哨兵）✔

- **优点**：
  - 部署简单
  - 高可用
  - 可扩展
  - 可以实现Sentinel监控
- **缺点**：
  - 部署相比主从模式要复杂
  - 资料浪费
  - 不能解决读写分离问题，实现起来相对复杂

### redis的哨兵模式，一个key值如何在redis集群中找到存储在哪里

在 Redis 哨兵模式下，一个 key 值如何找到存储在 Redis 集群中的具体节点，可以通过以下步骤：

- 1、哨兵选举：Redis 哨兵模式由主节点（master）和多个从节点（slave）组成。当主节点宕机或不可用时，哨兵会自动进行选举，选择一个从节点升级为新的主节点。

- 2、哨兵通信：每个哨兵都会与其他哨兵和 Redis 节点进行通信，交换关于集群拓扑结构的信息。这些信息包括主节点和从节点的地址、状态、优先级等。

- 3、主节点地址获取：客户端连接到任意一个哨兵节点，并发送 INFO 命令获取集群的拓扑结构信息。在 INFO 命令的返回结果中，可以找到主节点的地址。

- 4、主节点故障转移：如果当前连接的主节点不可用，客户端可以向其他哨兵节点发送 SENTINEL get-master-addr-by-name 命令，获取新的主节点地址。

- 5、数据查询：客户端连接到对应的 Redis 节点并发送 GET、SET 或其他操作命令，对指定的 key 进行读写操作。

需要注意的是，Redis 哨兵模式下的主节点切换可能会导致 key 的迁移。当主节点发生切换时，新的主节点会将原先主节点上的数据同步到自己的从节点上。因此，如果一个 key 在切换发生前已经存在于集群中，那么切换后该 key 仍然可以在 Redis 集群中找到。

总结起来，通过与哨兵节点通信和获取集群拓扑信息，客户端可以找到当前主节点的地址，并连接到对应的节点进行数据查询和操作。

### 怎么保证Redis的高并发高可用✔

首先可以搭建**主从集群**，再加上使用redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果master故障，Sentinel会将一个slave提升为master。 

当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端，所以一般项目都会采用哨兵的模式来保证redis的高并发高可用

### 使用redis是单点还是集群，哪种集群✔

我们当时使用的是主从（1主1从）加哨兵。一般单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点。尽量不做分片集群。因为集群维护起来比较麻烦，并且集群之间的心跳检测和数据通信会消耗大量的网络带宽，也没有办法使用lua脚本和事务

### redis的集群怎么同步的数据的

Redis 集群的数据同步方式与 Redis 主从同步有所不同。在 Redis 集群中，采用了**分片复制**的方式来同步数据，即将数据分散存储在多个节点上，并通过握手、数据迁移和广播等机制实现数据的一致性。每个节点负责一部分数据，写操作会被广播到其他节点，以确保数据的同步。

### redis集群脑裂，该怎么解决呢✔

这个在项目很少见，不过脑裂的问题是这样的，我们现在用的是redis的哨兵模式集群的 

有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于redis master节点和redis salve节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个salve为master， 这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在 old master那里写入数据，新节点无法同步数据，**当网络恢复后，sentinel会 将old master降为salve，这时再从新master同步数据，这会导致old master中的大量数据丢失。**

关于解决的话，我记得在redis的配置中可以设置：第一可以设置最少的salve 节点个数，比如设置至少要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失

### 介绍下Redis Cluster（分片集群）✔

Redis Cluster是Redis提供的一种分片集群解决方案，用于在多个节点之间分布和存储数据，以实现高可用性和扩展性。

Redis Cluster采用无中心节点的去中心化设计，其中包含多个主节点和从节点。每个节点都负责存储部分数据，并处理客户端请求。数据按照哈希槽（hash slot）的方式进行分片，总共有16384个哈希槽可供分配。每个主节点负责一部分哈希槽的数据存储和处理。

- **优点**
  - 高可用性：Redis Cluster采用主从复制机制，每个主节点都有多个从节点，从节点负责复制主节点的数据，并在主节点故障时接管服务，实现高可用性。
  - 扩展性：Redis Cluster支持自动分片和数据迁移，可以在节点加入或离开集群时自动进行数据的重新分片和迁移，保证数据的均衡和高可用性。
  - 可靠性：Redis Cluster使用心跳机制和故障检测来监控节点的状态，能够快速检测到故障节点并进行故障转移，保证了系统的可靠性。
  - 高性能：Redis Cluster将数据分散到多个节点上存储，可以充分利用多节点的CPU和内存资源，实现高性能的读写操作。
  - 灵活性：Redis Cluster支持多种客户端语言和协议，可以方便地与各种应用程序集成。
- **缺点**
  - 复杂性：Redis Cluster在节点之间的通信、数据同步和故障转移等方面都需要一定的复杂性处理，增加了系统的设计和实现成本。
  - 事务支持问题：Redis Cluster对于事务的支持不够完善，存在一定的限制。
  - 数据一致性问题：Redis Cluster采用的是分片集群方式，对于数据一致性和跨槽事务等方面的支持也存在一定的限制。
  - 内存容量问题：由于Redis Cluster将数据存储在内存中，因此在数据量增大时需要考虑内存的容量和成本。
  - 网络延迟问题：Redis Cluster需要网络带宽和延迟来保证节点之间的通信和数据同步，因此网络环境也需要被合理考虑。

Redis缓存分片是指将一个大的缓存数据集合分割成多个小的数据集合，存储在不同的Redis节点上。这样做的好处是可以提高数据的处理速度和容量，避免单个Redis节点的性能瓶颈和数据存储容量限制。

Redis缓存分片的实现需要使用分布式哈希算法（例如一致性哈希算法），根据哈希值将数据分配到不同的Redis节点上。在Redis缓存分片中，每个节点之间需要进行数据同步，以保证数据的一致性。数据同步可以通过Redis的主从复制功能实现，即一个节点作为主节点，其他节点作为从节点，主节点负责接收和处理客户端请求，并将更新的数据同步到从节点。从节点只能读取数据，不能写入数据。

需要注意的是，Redis缓存分片虽然可以提高系统的性能和容量，但同时也会增加系统的复杂度和维护成本。因此，在使用Redis缓存分片时，需要考虑系统的实际需求和资源情况，并且合理规划分片策略。

### redis的分片集群有什么作用✔

分片集群主要解决的是，海量数据存储的问题，集群中有多个 master，每个master保存不同数据，并且还可以给每个master设置多个slave 节点，就可以继续增大集群的高并发能力。同时每个master之间通过ping监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点

### Redis分片集群中数据是怎么存储和读取的✔

Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围， key通过 CRC16 校验后对 16384 取模来决定放置哪个槽，通过槽找到对应的节点进行存储。 

取值的逻辑是一样的

### 介绍下Redis自研

- **优点**
  - 高可靠、高可用性
  - 自主可控性高
  - 贴切业务实际需求，可缩性好，兼容性好
- **缺点**
  - 实现复杂，开发成本高
  - 需要建立配套设施
  - 维护成本高

### Redis高可用方案具体怎么实施✔

- 使用官方推荐的哨兵（sentinel）机制
- 四个功能
  - 集群监控，负责监控Redis master和slave进程是否正常工作。
  - 消息通知，如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
  - 故障转移，如果master node挂掉了，会自动转移到slave node上。
  - 配置中心，如果故障转移发生了，通知client客户端新的master地址。

### Redis主从复制的原理✔❤

- **主从架构的核心原理**：
   - master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给 slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。  
- 主从复制的断点续传
- 无磁盘化复制
- 过期key处理
   - slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。

### 由于主从延迟导致读取到过期数据怎么处理

- 通过scan命令扫库：当Redis中的key被scan的时候，相当于访问了该key，同样也会做过期检测， 充分发挥Redis惰性删除的策略。这个方法能大大降低了脏数据读取的概率，但缺点也比较明显， 会造成一定的数据库压力，否则影响线上业务的效率。
- Redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断，如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只 读命令也返回null。

### 主从复制的过程中，如果因为网络原因停止复制了会怎么样

- 断点续传，可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份

### Redis主从架构数据会丢失吗，为什么

- 异步复制导致数据库丢失
- 脑裂导致的数据丢失

### 如何解决主从架构数据丢失的问题

- 1、`min-skaves-to-write 1`：至少有一个slave。
- `min-slaves-max-lag 10`：数据复制和同步的延迟不能超过10秒，否则master就不会再接收任何请求了

### Redis哨兵是怎么工作的

- 1、每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。 
- 2、如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被当前 Sentinel 标记为主观下线。 
- 3、如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率 确认Master的确进入了主观下线状态。 min-slaves-to-write 1 min-slaves-max-lag 10 154 
- 4、当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。 
- 5、当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 （在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它 已知的所有Master，Slave发送 INFO 命令 ）。 
- 6、若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会变成主观下线。 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。 
- 7、sentinel节点会与其他sentinel节点进行“沟通”，投票选举一个sentinel节点进行故障处理，在从节点中选取一个主节点，其他从节点挂载到新的主节点上自动复制新主节点的数据。

### 故障转移时会从剩下的slave选举一个新的master，被选举为master的标准是什么

- 跟master断开连接的时长
- slave优先级
- 复制offset
- run id

### 同步配置的时候其他哨兵根据什么更新自己的配置呢

执行切换的那个哨兵，会从要切换到的新master（salve->master）那里得到一个**configuration epoch，这就是一个version号**，每次切换的version号都必须是唯一的。 

如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待failover-timeout时间，然后接替继续执行切换，此时会重新获取一个新的configuration epoch 作为新的version号。 

这个version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置的。

### 为什么Redis哨兵集群只有2个节点无法正常工作

哨兵集群必须部署2个以上节点。

如果两个哨兵实例，即两个Redis实例，一主一从的模式。

则Redis的配置quorum=1，表示一个哨兵认为master宕机即可认为master已宕机。

但是如果是机器1宕机了，那哨兵1和master都宕机了，虽然哨兵2知道master宕机了，但是这个时候，需要majority，也就是大多数哨兵都是运行的，2个哨兵的majority就是2（2的majority=2，3的majority=2，5的majority=3，4的majority=2），2个哨兵都运行着，就可以允许执行故障转移。

但此时哨兵1没了就只有1个哨兵了了，此时就没有majority来允许执行故障转移，所以故障转移不会执行。

### Redis cluster中是如何实现数据分布式的？这种方式有什么优点

在 Redis Cluster 中，数据分布式是通过使用分片（sharding）技术来实现的。Redis Cluster将整个数据集分为多个槽（slot），默认有16384个槽位。每个节点负责处理一部分槽位，这些槽位对应的数据被存储在该节点上。

以下是 Redis Cluster 数据分布式的工作原理：

- 1、槽位分配：当一个 Redis Cluster 节点加入到集群中时，它会负责处理一部分槽位。Redis Cluster 使用哈希函数将键映射到相应的槽位，然后将数据存储在负责该槽位的节点上。

- 2、槽位迁移：当新的节点加入集群或者节点离开集群时，槽位会进行重新分配和迁移。Redis Cluster 使用 Gossip 协议来广播节点信息，以实现槽位的重新分配和迁移。这样可以确保集群中的数据在节点变更时仍然可用。

- 3、主从复制：每个槽位在集群中都有一个主节点和零个或多个从节点。主节点负责处理读写请求，而从节点则用于提供冗余和高可用性。主从复制可以确保即使主节点发生故障，数据仍然可用，并且可以快速进行故障恢复。

Redis Cluster 实现数据分布式的优点包括：

- 1、高可用性：通过将数据复制到多个节点，Redis Cluster 提供了高可用性。即使在主节点故障的情况下，从节点可以接管服务并继续提供数据。

- 2、扩展性：Redis Cluster 允许添加新的节点来扩展集群的容量和吞吐量。当集群中的数据量增加时，可以通过增加节点来分担负载，而无需对现有节点进行修改。

- 3、平衡负载：通过将数据分布到不同的节点上，Redis Cluster 可以实现负载均衡。这样可以确保每个节点处理相对均衡的请求，提高整体性能和吞吐量。

- 4、自动故障迁移：Redis Cluster 使用 Gossip 协议来检测节点故障，并自动重新分配和迁移槽位。这样可以实现自动化的故障恢复，减少了人工干预和管理的需求。

综上所述，Redis Cluster 中的数据分布式通过分片、主从复制和槽位迁移等技术实现，提供了高可用性、扩展性和负载均衡等优势。这使得 Redis Cluster 成为处理大规模数据和高并发访问的理想选择。

### Redis cluster节点间通信是什么机制

在 Redis Cluster 中，节点间通信采用了一种基于二进制协议的、高效的集群总线（cluster bus）机制。

Redis Cluster 中的每个节点都会启动一个专用的 TCP 端口（默认是 16379），用于与其他节点进行通信。这些端口上的连接被称为集群总线连接（cluster bus connection）。每个节点都维护着自己的集群状态，包括节点信息、槽位分配和主从复制关系等。

当一个节点需要与另一个节点进行通信时，它会通过集群总线连接发送二进制命令和数据，然后等待响应。这些命令和数据通常是以可压缩格式（compressed format）进行传输，这样可以减少网络带宽的使用和延迟。

Redis Cluster 的集群总线机制具有以下优点：

- 1、高效：使用二进制协议和可压缩格式，可以大大减少网络带宽的使用和延迟，提高通信效率。

- 2、可靠：集群总线连接使用 TCP 协议，并支持心跳检测和超时机制，可以确保通信的可靠性和稳定性。

- 3、安全：集群总线连接使用加密传输，并且只允许集群中的节点之间进行通信，可以提供一定的安全保障。

- 4、灵活：集群总线机制允许节点之间进行实时通信，并支持自动发现和重新连接等功能，可以应对节点变更和故障等情况。

综上所述，Redis Cluster 中的节点间通信采用了基于二进制协议的、高效的集群总线机制。这种机制具有高效、可靠、安全和灵活等优点，能够满足处理大规模数据和高并发访问的需求。

## 分布式问题

### 什么是分布式锁？为什么用分布式锁

锁在程序中的作用就是同步工具，保证共享资源在同一时刻只能被一个线程访问，Java中的锁我们都很熟悉了，像synchronized 、Lock都是我们经常使用的，但是Java的锁只能保证单机的时候有效，分布式集群环境就无能为力了，这个时候我们就需要用到分布式锁。

分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来**控制分布式系统之间同步访问共享资源**。

思路是：在整个系统提供一个**全局、唯一**的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。至于这个“东西”，可以是Redis、Zookeeper，也可以是数据库。

### 常见的分布式锁有哪些解决方案

分布式锁：控制分布式系统有序的去对共享资源进行操作，通过互斥来保证数据的一致性。

数据库：基于表的唯一索引

ZooKeeper：根据ZooKeeper中的临时节点排序

Redis：使用SETNX命令实现分布式锁✔

> 在redis中提供了一个命令setnx(SET if not exists)
>
> 由于redis的单线程的，用了命令之后，只能有一个客户端对某一个key设置值，在没有过期或删除key的时候是其他客户端是不能设置这个key的
>
> **如何控制Redis实现分布式锁有效时长呢？**
>
> redis的setnx指令不好控制这个问题，我们当时采用的redis的一个框架redisson实现的。
>
> 在redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在redisson中引入了一个看门狗机制，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了
>
> 还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户1持有锁的时候，客户2来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。
>
> **redisson实现的分布式锁是可重入的吗？**
>
> 是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减一。在存储数据的时候采用的hash结构，大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数
>
> **redisson实现的分布式锁能解决主从一致性的问题吗**
>
> 这个是不能的，比如，当线程1加锁成功后，master节点数据会异步复制到slave节点，此时当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。
>
> 我们可以利用redisson提供的红锁来解决这个问题，它的主要作用是，不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁，并且要求在大多数redis节点上都成功创建锁，红锁中要求是redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。
>
> 但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁
>
> **如果业务非要保证数据的强一致性，这个该怎么解决呢？**
>
> redis本身就是支持高可用的，做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用zookeeper实现的分布式锁，它是可以保证强一致性的。

### 如何使用Redis来实现分布式锁，redis分布式锁有什么缺陷

分布式锁是一种用于在分布式环境下保证资源的互斥访问的机制，Redis 可以通过以下方式来实现分布式锁：

- 使用 SETNX 命令：SETNX（SET if Not eXists）命令可以在 key 不存在时设置它的值，用于加锁。如果返回结果为 1，则表示获取锁成功；如果返回结果为 0，则表示锁已被其他进程持有。
- 使用 EXPIRE 命令设置过期时间：为了避免死锁，需要为获取到的锁设置一个过期时间，以防止持有锁的进程异常退出或崩溃导致锁无法释放。
- 使用 DEL 命令释放锁：在不再需要锁时，使用 DEL 命令删除相应的 key，释放锁。

具体实现步骤如下：
- 1、客户端调用 SETNX 命令尝试获取锁，如果返回结果为 1，表示获取锁成功。
- 2、如果获取锁成功，在设置过期时间的同时，可以设置一个唯一标识作为锁的值，以便后续释放锁时进行校验。
- 3、执行业务逻辑。
- 4、执行完业务逻辑后，客户端通过 DEL 命令释放锁。

存在的缺陷：

- 锁竞争问题：如果多个客户端同时竞争同一个锁，可能会导致锁的频繁获取和释放，增加系统负载，甚至出现死锁。
- 锁过期问题：如果业务逻辑执行时间超过了锁的过期时间，可能导致其他客户端在业务逻辑还未执行完毕时获取到了锁，破坏了互斥性。
- 锁误释放问题：如果客户端在释放锁时发生异常或崩溃，可能导致锁无法正常释放，从而造成死锁。

为了解决这些问题，可以考虑使用带有唯一标识的锁值来确保只有加锁的客户端才能释放锁，以及使用分布式锁框架如 Redlock、Redisson 等来提供更可靠的分布式锁解决方案。

### 了解RedLock吗，RedLock的原理

RedLock 是一种用于分布式系统的分布式锁算法。它由 Redis 的创始人编写并在 2016 年发布。RedLock 旨在解决使用单个 Redis 实例作为分布式锁的可靠性问题。

RedLock 的原理如下：

- 1、多实例：RedLock 使用多个独立的 Redis 实例组成一个锁服务（lock service）。通常建议至少使用五个 Redis 实例来提供足够的可靠性。
- 2、锁获取：当一个客户端要获取锁时，它会向所有的 Redis 实例发送相同的 SETNX 命令，尝试在每个实例上设置一个相同的锁键和唯一的锁值。如果客户端在多数实例上成功获取了锁，那么它就认为锁已经获得。
- 3、锁释放：当一个客户端要释放锁时，它会向所有的 Redis 实例发送相同的 DEL 命令，尝试删除锁键。只要客户端能够在多数实例上成功删除锁键，那么它就认为锁已经释放。
- 4、锁续约：为防止锁过期而导致的问题，客户端在获得锁后需要定期续约锁的过期时间。续约可以通过向所有 Redis 实例发送相同的 EXPIRE 命令来实现。

RedLock 的设计目标是在多数 Redis 实例可用的情况下提供强一致性。即使在某些实例出现故障的情况下，只要大多数实例正常工作，锁仍然可以被正确地获取和释放。这种设计可以提高分布式系统中的锁的可靠性。

然而，需要注意的是，RedLock 并不是完全无法出错的，它还存在一些潜在的问题和局限性。例如，当网络延迟较高或者 Redis 实例之间的时钟不同步时，可能会导致锁的竞争和冲突。因此，在使用 RedLock 时，需要根据具体情况评估其适用性，并考虑其他的分布式锁方案。

### 如何解决 Redis 的并发竞争Key问题✔

1、使用SETNX命令

SETNX命令用于将一个键设置为一个值，但只有在该键不存在的情况下才会设置成功。因此，我们可以使用SETNX命令来保证同一时刻只有一个客户端能够创建该键，其他客户端则需要等待。

例如，我们可以使用如下代码来创建一个名为"lock"的键：

```
SETNX lock true
```

2、使用RedLock算法

RedLock算法是一种分布式锁算法，它可以在多个Redis实例之间协调锁定。该算法的基本思想是：在多个Redis实例之间创建一个分布式锁，并采用Quorum机制来保证锁的可靠性。

3、使用Lua脚本

Lua脚本是Redis提供的一种脚本语言，它可以在Redis服务器上执行。我们可以使用Lua脚本来对键进行操作，从而保证在执行期间不会有其他客户端干扰。

例如，我们可以使用如下Lua脚本来获取一个名为"counter"的计数器的值，并将其加1：

```
local counter = redis.call('GET', 'counter')
redis.call('SET', 'counter', tonumber(counter) + 1)
```

### Redis和Redisson有什么关系

Redisson 是一个基于 Redis 的 Java 客户端，它提供了许多方便的工具和功能，用于在 Java 应用中操作 Redis 数据库。Redisson 提供了分布式对象、分布式集合、分布式锁、分布式信号量等丰富的功能，简化了在 Java 中使用 Redis 的复杂性。

因此，可以说 Redisson 是 Redis 的一个客户端库，它使得在 Java 程序中使用 Redis 更加方便和高效。通过使用 Redisson，开发人员可以很容易地利用 Redis 提供的功能，实现分布式应用程序中常见的任务，如分布式锁、分布式集合等。

总而言之，Redisson 是 Redis 的一个 Java 客户端库，它使得与 Redis 交互变得更加容易，并提供了丰富的功能来简化分布式应用程序的开发。

## 补充

### Redis如何做内存优化

- 控制key的数量
- 缩减键值对象（key、value的长度）
- 编码优化

### 如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计

如果现在有个读超高并发的系统，可以使用 Redis 来抗住大部分读请求，我会采用以下设计：

- 1、数据缓存：利用 Redis 的缓存功能，将热点数据缓存在内存中，减少对数据库的访问。可以通过设置合适的过期时间和 LRU 策略来控制缓存的有效性和占用的内存。

- 2、分片存储：对于海量数据，可以将数据按照一定规则进行分片存储，保证每个 Redis 实例的数据量和并发访问量都不会过大。可以使用 Redis Cluster 或者自行实现一套分片方案。

- 3、预加载机制：可以在系统启动时，预加载一些常用的数据到 Redis 缓存中，加速后续的访问。可以使用 Redis 的管道（pipeline）功能以及多线程等技术来优化预加载效率。

- 4、请求限流：为了控制并发访问量，可以采用一些请求限流的策略。例如，可以使用 Redis 的计数器（counter）或者令牌桶（token bucket）算法来限制每秒的请求数量。

- 5、压力测试：在系统上线前，需要对 Redis 进行充分的压力测试，以验证 Redis 的可扩展性、可靠性和性能。可以使用工具如 RedisBench 或者自行编写压测脚本。

综上所述，通过缓存、分片、预加载、限流和压力测试等策略，可以利用 Redis 来抗住大部分读请求，提高系统的性能和稳定性。

### 怎么使用Redis实现一个延时队列✔

**延时队列是一种特殊类型的消息队列，它允许把消息发送到队列中，但不立即投递给消费者，而是在一定时间后再将消息投递给消费者**，所以，它通常用于需要在未来的某个时间执行某个任务的场景，比如订单的超时处理，定时任务等等。

在Redis里面，可以使用Zset这个有序集合来实现延迟队列，具体的实现方式可以分为几个步骤：

- 1、使用ZADD命令把消息添加到sorted set中，并将当前时间作为score，并且把当前的时间作为score
- 2、启动一个消费者线程，使用ZRANGEBYSCORE命令获取定时从Zset中获取当前时间之前的所有消息
- 3、消费者处理完成以后，可以从有序集合中删除这些消息

通过这种方式虽然可以实现延迟队列，但是消费端需要不断的向Redis去发起轮询，会存在一下这几个问题：

- 1、轮询存在时间间隔，所以延时消息的实际消费时间会大于设定时间
- 2、大量的轮询动作会对Redis服务器造成压力，所以如果需要使用延迟消息，很多MQ组件都支持这样一个能力

### JVM本地缓存，了解过吗

是的，JVM本地缓存指的是在Java应用程序中使用内存作为缓存的一种方式。它将数据存储在JVM的堆内存中，以提高读取和访问数据的性能。

JVM本地缓存的好处包括：

- 1、快速读取：由于数据存储在内存中，因此可以快速读取，避免了与外部系统的网络通信或磁盘IO等延迟。

- 2、减轻外部系统负载：将频繁访问的数据缓存在本地，可以减少对外部系统的请求，降低外部系统的负载压力。

- 3、提高系统性能：通过缓存热点数据，可以加快系统的响应速度，提高整体性能。

常见的JVM本地缓存实现方式有：

- HashMap/ConcurrentHashMap：使用Java集合类存储缓存数据，通过键值对方式进行快速查找。

- Guava Cache：Guava是Google开发的一个Java工具库，其中包含了一个强大的本地缓存组件，提供了丰富的缓存策略和功能。

- Caffeine：Caffeine是一个高性能的Java缓存库，它是Guava Cache的改进版，提供了更好的并发性能和更丰富的配置选项。

- Ehcache：Ehcache是一个广泛使用的Java缓存框架，支持多种缓存策略和持久化选项。

在使用JVM本地缓存时，需要注意以下几点：

- 缓存一致性：需要保证缓存数据与数据库或外部系统的数据一致性，可以通过合适的缓存更新策略来实现。
- 缓存过期策略：需要根据业务需求设置合适的缓存过期时间，避免数据过期而导致的不一致问题。

- 内存管理：需要注意缓存数据的大小，避免占用过多的内存资源。

JVM本地缓存是一种有效提高系统性能的方式，根据具体需求选择合适的缓存实现方式，并合理配置和管理缓存策略。

### MySQL有2000w数据，Redis中只存20w数据，如何保证Redis中的数据都是热点数据

要保证 Redis 中的数据都是热点数据，可以考虑以下几种策略：

- 1、数据预热：在系统启动或者低峰期，将 MySQL 中的热点数据加载到 Redis 中。可以通过批量读取 MySQL 数据并写入 Redis，或者定时地按需加载数据，确保 Redis 中的数据与 MySQL 中的热点数据保持一致。

- 2、缓存淘汰策略：设置适当的缓存淘汰策略，当 Redis 内存不足时，淘汰掉访问频率较低的数据，保留访问频率较高的热点数据。Redis 提供了多种淘汰策略，如 LRU（最近最少使用）、LFU（最不经常使用）等，可以根据实际情况选择合适的策略。

- 3、缓存更新策略：当 MySQL 中的数据发生变化时，及时更新 Redis 中的缓存数据。可以通过数据库触发器、消息队列等方式来监听并同步数据变更，确保 Redis 中的数据与 MySQL 中的数据保持同步。

- 4、数据访问控制：通过限制直接访问 MySQL 数据库的权限，只允许通过 Redis 访问数据，强制所有数据访问都经过 Redis 缓存。这样可以确保 Redis 中的数据始终是热点数据，并减轻 MySQL 数据库的负载。

- 5、热点数据监控：监控系统中的数据访问模式和频率，识别出热点数据，并将其放入 Redis 缓存。可以使用监控工具、日志分析等手段来实现，及时发现并处理新的热点数据。

综合运用以上策略，可以有效地保证 Redis 中的数据都是热点数据，并提升系统的性能和响应速度。根据具体的业务场景和需求，选择适合的策略或者组合多种策略来实现最佳效果。

### Redis中的管道有什么用

在 Redis 中，管道（Pipeline）是一种批量执行多个命令的机制，它可以在客户端和服务端之间减少网络通信的次数，提高了命令执行的效率。

**使用管道可以将多个 Redis 命令打包发送到服务端，而不需要等待每个命令的返回结果**。这样可以减少网络延迟对命令执行效率的影响，特别是在需要执行大量命令的场景下，如批量写入或读取数据。

管道的使用过程如下：
- 1、客户端向服务端发送 MULTI 命令，表示开始事务。
- 2、客户端连续发送多个命令到服务端。
- 3、客户端向服务端发送 EXEC 命令，表示执行事务。
- 4、服务端按顺序执行接收到的命令，并返回执行结果给客户端。

管道可以显著提高 Redis 的性能，尤其是在需要执行多个命令的场景下。然而，管道也有一些注意事项：
- 管道中的命令是顺序执行的，后面的命令依赖前面命令的执行结果。
- 管道中的命令是原子执行的，如果其中某个命令执行失败，整个事务会回滚。
- 管道中的命令无法获取即时的执行结果，只能在 EXEC 命令执行后才能获取结果。

总的来说，Redis 管道是一种优化命令执行效率的机制，适用于需要批量执行多个命令的场景，可以通过减少网络通信次数来提高性能。

### Redis—跳跃表，复杂度是多少

Redis中的跳跃表（Skip List）是一种有序数据结构，用于实现有序集合（Sorted Set）和有序映射（Sorted Map）等功能。它的插入、删除和查找操作的平均时间复杂度都是O(log n)，其中n是跳跃表中元素的数量。

跳跃表通过层级结构实现快速查找，每个元素都包含多个指针，可以跨越多个层级直接定位到目标位置，从而提高了查找效率。每个层级的元素数量是上一层级的1/2，这样在跳跃表中，最高层级的元素数量最少，而最底层级的元素数量最多。

对于插入和删除操作，跳跃表需要动态地调整层级结构，以保证元素的有序性和平衡性，因此其时间复杂度也是O(log n)。

需要注意的是，虽然跳跃表在绝大多数情况下能够提供良好的性能，但在极端情况下，例如极不均匀的数据分布或者大量重复元素的情况下，其性能可能会退化到O(n)。但是在一般情况下，跳跃表的复杂度是O(log n)。

