# Java基础

## Java概述

### 1.Java语言有哪些特点

- 面向对象（封装、继承、多态）
- 平台无关性（跨平台、一次编写，到处运行）
- 可靠性、安全性
- 支持多线程
- 支持网络编程
- **编译与解释共存**

### 2.Java和C++有什么关系，它们有什么区别

1、Java没有明确的指针概念；而C++存在指针

2、Java支持单继承、多实现；而C++支持多继承

3、Java有自动回收垃圾机制；C++需要开发人员手动管理内存

4、Java不支持操作符重载；C++支持操作符重载

5、**Java没有goto语句**

6、**Java是完全面向对象；C++更加偏向面向过程**

### 3.JVM、JRE和JDK的关系是什么✔

- JDK=JRE+开发工具集（例如javac编译工具等【将java代码编译成字节码】）
- JRE=JVM【执行Java字节码】+JavaSE标准类库

### 4.什么是字节码？采用字节码的好处是什么✔

编译器（javac）将Java源文件（.java）文件编译成字节码文件（.class）

- **编译生成固定格式的字节码（.class文件）供JVM使用**
- 一次编译，到处运行（实现了跨平台）
- 提高了代码执行的性能

### 5.OracleJDK和OpenJDK的区别是什么

| OracleJDK                                  | OpenJDK                                          |
| ------------------------------------------ | ------------------------------------------------ |
| **<font color=red>三年发布一次</font>**    | 三个月发布一次                                   |
| 不是完全开源                               | 完全开源                                         |
| 性能更好、更稳定                           | 相对来说，性能没有OracleJDK好，没有OracelJDK稳定 |
| **不提供长期支持，每次必须更新到最新版本** | **提供长期支持**                                 |

## 基础语法

### 6.Java有哪些数据类型✔

- 基本数据类型
  - 数值型
    - 整型
      - 字节型`byte`1
      - 短整型`short`2
      - 整型`int`4
      - 长整型`long`8
    - 浮点型
      - 单精度`float`4
      - 双精度`double`8
  - 字符型**`char`2**
  - 布尔型**`Boolean`1**
- 引用数据类型
  - 类 `class`
  - 接口 `interface`
  - 数组 `[]`

### 7.Switch是否能作用在byte上，是否能作用在long上，是否能作用在String上

- java5之前byte、short、char、int
- java5开始+enum
- **java7开始+String**
- 长整型(long)在目前所有的版本中都是不可以的。

### 8.访问修饰符public、private、protected、以及不写（默认）时的区别❗

- `private`当前类
- `default`当前类、同一包（+同一包子类）
- `protected`当前类、同一包（+同一包子类）、不同包的子类
- `public`当前类、同一包（+同一包子类）、不同包的子类、同一工程	

### 9.break，continue，return的区别及作用✔

- break：结束当前循环体
- continue：结束正在执行的循环体，进入下一个循环条件
- return：结束当前的方法，直接返回

### 10.final、finally、finalize的区别✔

- `final`：修饰类、方法、变量
- `finally`：异常处理的一部分，通常情况一定执行
- `finalize`：是`java.lang.Object`里定义的方法，在gc启动，垃圾回收时调用

## 关键字

### 11.为什么要用static关键字

只想为特定域分配单一存储空间，不考虑要创建多少对象或者说根本不创建任何对象，再就是我们想在没有创建对象的情况下也想调用方法

### 12."static"关键字是什么意思？Java中是否可以覆盖（override）一个private或者是static的方法

- **表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问**
- 不可以覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

### 13.是否可以在static环境中访问非static变量

- 不可以，非static变量可能还没有创建出来

### 14.static静态方法能不能引用非静态资源

- 不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它

### 15.static静态方法里面能不能引用静态资源

- 可以

### 16.非静态方法里面能不能引用静态资源

- 可以

### 17.Static静态代码块、构造代码块、普通代码块、构造函数的执行顺序是什么

- 基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块
- 代码块执行顺序**静态代码块——> 构造代码块 ——> 构造函数——> 普通代码块** 
- 继承中代码块执行顺序：**父类静态代码块——>子类静态代码块——>父类构造代码块——>父类构造函数——>子类构造代码块——>子类构造函数——>父类普通代码块——>子类普通代码块**

### 18.面向对象和面向过程的区别✔

1. 面向对象

  - 简单来说，面向对象的开发范式中，程序员将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。

    就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。

  - 优点：易维护、易复用

  - 缺点：性能比面向过程低

2. 面向过程
  - 面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。最典型的面向过程的编程语言就是C语言。

    简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。

  - 优点：性能比面向对象高

  - 缺点：没有面向对象易维护、易复用

### 19.讲讲面向对象三大特征✔

1. 封装

   - 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
   - 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。**在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。**

2. 继承

   - 继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

     通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。
     
     子类可以通过继承获得父类的非私有属性和非私有方法

3. 多态

   - 父类中定义的属性和方法被子类继承之后，具有不同的行为，或者说在各个子类中具有不同的含义的行为
   - 多态机制使具有不同内部结构的对象可以共享相同的外部接口。

### 20.Java语言是如何实现多态的❗

- 编译时多态
  - 重载。。
- 运行时多态

**我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。**

Java实现多态有 3 个必要条件：**继承、重写和向上转型**。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。

- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。

```java
public class Parent{

    public void call(){
        sout("im Parent");
    }
}

public class Son extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout("im Son");
    }
}

public class Daughter extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout("im Daughter");
    }
}

public class Test{

    public static void main(String[] args){
        Parent p =  new Son(); //3.父类的引用指向子类的对象
        Parent p1 =  new Daughter(); //3.父类的引用指向子类的对象

    }
}
/**
 *这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call调用的是Daughter的实现。
 *
 *有人说，你自己定义的时候不就已经知道p是son，p1是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的。
 *
 *比如Spring 中的IOC出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。
 */
```



### 21.重载（Overload）和重写（Override）的区别是什么✔

- 重载
  - 在同一个类中，同一个方法名，参数个数不同，参数类型不同，顺序不同
  
    就是说在同一个类中，多个函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。
  
- 重写
  - 子类继承父类后，可以对父类中同名同参数的方法，进行覆盖操作
  - 返回值范围小于等于父类，抛出异常范围小于等于父类，**访问修饰符范围大于等于父类**；**如果父类方法访问修饰符为private则子类就不能重写该方法**

### 22.重载的方法能否根据返回值类型进行区分

- 调用时不指定类型信息

### 23.构造器（constructor）是否可被重写（override）

- 不能被继承，因此不能被重写

### 24.抽象类和接口的区别是什么✔

- 内部方法细节
  - 抽象类可以存在普通方法函数
  - 接口中只能存在`public static final`方法，不能写业务逻辑
- **成员变量类型**
  - 抽象类中成员变量可以是各种类型，
  - 接口中的成员变量只能是`public static final`
- 继承、实现
  - 抽象类只能继承一个
  - 接口可以实现多个
- **<font color=red>接口中不能含有静态代码块和静态方法，而抽象类可以有静态代码块和静态方法；</font>**

### 25.抽象类能使用final修饰吗

- 不能，因为需要用其他类进行继承

### 26.java创建对象有哪几种方式

- new 创建新对象

  使用类的构造函数和 `new` 关键字来创建对象，例如：`ClassName object = new ClassName();`。

- 通过反射机制

  通过使用 Java 的反射 API，可以在运行时动态地创建对象。这种方式通常用于需要在运行时动态确定类名的情况。

- 采用 clone 机制

  如果一个类实现了 `Cloneable` 接口，就可以使用 `clone()` 方法创建该类的副本。

- 通过序列化机制

  通过将对象写入流中并从流中读取对象来创建对象。这种方式可以将对象保存到磁盘或通过网络传输。

- 使用 `newInstance()` 方法：对于那些提供默认构造函数的类，可以使用 `Class` 对象的 `newInstance()` 方法来创建对象。

### 对象的创建过程✔❤❗

1. 类加载：当程序引用一个类时，Java虚拟机（JVM）会通过类加载器查找并加载该类的字节码文件。类加载是将类的字节码文件加载到内存，并在方法区中创建类的Class对象的过程。
2. 分配内存：在内存中为对象分配一块连续的内存空间，用于存储对象的实例变量。
3. 初始化零值：在内存中分配的空间被初始化为默认值，基本类型的实例变量被初始化为0或false，引用类型的实例变量被初始化为null。
4. 设置对象头信息：在对象头中存储对象的元数据，如哈希码、GC 信息、锁状态等。
5. **执行构造方法**：根据对象所属类的构造方法，执行相应的构造逻辑，完成对象的初始化。构造方法的执行会对对象的实例变量进行赋值操作，可以进行自定义的初始化逻辑。
6. **返回对象的引用**：对象创建完成后，返回一个指向该对象的引用，可以通过该引用来访问和操作对象的实例变量和方法。

值得注意的是，Java 中的对象创建是在堆内存中完成的，而不是栈内存。栈内存只存储了对象的引用，而真正的对象实例及其数据是分配在堆内存中的。

另外，如果对象是通过关键字 `new` 创建的，则会在堆内存中分配新的对象；如果是通过反射或克隆等方式创建的对象，则会相应地调用不同的机制来完成对象的创建过程。

### 27.什么是不可变对象?好处是什么

- 任何修改都会创建一个新的对象（如：String、Integer）
- **<font color=red>线程安全</font>**

### 28.值传递和引用传递的区别的什么？为什么说Java中只有值传递✔

- 值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。

- 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。

> 举例：你有一把钥匙，当你的朋友想要去你家的时候，如果你`直接`把你的钥匙给他了，这就是引用传递。
>
> 这种情况下，如果他对这把钥匙做了什么事情，比如他在钥匙上刻下了自己名字，那么这把钥匙还给你的时候，你自己的钥匙上也会多出他刻的名字。
>
> 你有一把钥匙，当你的朋友想要去你家的时候，你`复刻`了一把新钥匙给他，自己的还在自己手里，这就是值传递。
>
> 这种情况下，他对这把钥匙做什么都不会影响你手里的这把钥匙。

**<font color=red>值传递和引用传递最大的区别是传递的过程中有没有复制出一个副本来，如果是传递副本，那就是值传递，否则就是引用传递</font>。**

在Java中，其实是通过值传递实现的参数传递，只不过对于Java对象的传递，传递的内容是对象的引用

```java
//判断输出结果
//1. 引用传递
//2. 堆栈内存分析
public static void main(String args[]) {
    StringBuffer a = new StringBuffer("A");
    StringBuffer b = new StringBuffer("B");
    operater(a,b);

    System.out.println(a+" "+b);

}

public static void operater(StringBuffer x, StringBuffer y) {

    x.append(y);
    y = x;
}
//结果：AB A
```

### 29.能否创建一个包含可变对象的不可变对象

- `final Person[] persons = new Persion[]{}`

## 对象相等判断

### 30.==和equals区别是什么✔

- `==`：如果是基本数据类型，比较是值，如果是引用类型，比较的是引用地址
- `equals`：具体看各个类重写equals方法之后的比较逻辑，比如String类，虽然是引用类型，但是String类中重写了equals（）方法，方法内部比较的是字符串中的各个字符是否全部相等
  - 没有重写，相当于“==”
  - 重写后，一般比较对象内容

### 31.介绍下hashCode()

- hashCode()->哈希值(散列码)->确定该对象在哈希表中的索引位置

### 32.为什么要有hashCode❗

- 比较对象是否重复
- 比较对象时候，大大减少了equals()的次数，相应就大大提高了执行速度
- 【先比较hashCode，在比较equals()】

### 33.hashCode(),equals()两种方法是什么关系✔

- 注意
  - 若重写`equals()`方法，必须重写`hashcode()` 方法，确保`equals()`方法判断结果为true的两个对象具备相等的`hashcode()`方法返回值【如果两个对象相同，那么他们的hashcode应该相同】
  - 如果两个对象不相同，他们的hashcode可能相同

### 34.为什么重写equals方法必须重写hashcode方法✔

如果只重写equals方法，不重写hashCode方法。就有可能导致`a.equals(b)`这个表达式成立，但是hashCode却不同

那么这个只重写equals方法的对象在使用散列集合进行存储的时候就会出现问题，因为散列集合是使用HashCode来计算key的存储位置，如果存储两个完全相同的对象，但是有不同的hashCode，就会导致这两个对象存储在hash表的不同位置，我们想要根据这个对象去获取数据的时候，就会出现一个悖论，**一个完全相同的对象会存储在hash表的两个位置**，就会破坏约定俗成的规则，使得在程序中出现一些不可预料的错误。

## String相关

### 35.String,StringBuffer,StringBuilder的区别是什么✔

String、StringBuffer和StringBuilder都是在 Java 中用于处理字符串的类，底层是`char[]`

1. **不可变性**:
   - String 类是不可变的，一旦创建了一个String对象，就不能更改其内容。**每次对字符串进行修改时，都会创建一个新的字符串对象，存在内存开销**。
   - StringBuffer 和 StringBuilder 类是可变的，它们可以通过修改现有对象来实现字符串的操作。
2. **线程安全性**：
   - String 是线程安全的，因为它的不可变性保证了多个线程操作同一个字符串对象时不会产生问题。
   - StringBuffer 是线程安全的，它的方法使用了**同步锁**来确保在多线程环境下的线程安全性。
   - StringBuilder 不是线程安全的，它的方法没有使用同步锁，因此在多线程环境下使用时需要自行处理同步问题。
3. **<font color=red>性能</font>：**
   - 由于 String 是不可变的，每次对字符串进行修改都会创建一个新的字符串对象，这会带来较大的内存开销。
   - StringBuffer 的方法使用同步锁，保证了线程安全性，但可能会影响性能。
   - StringBuilder 不考虑线程安全，方法未使用同步锁，因此在单线程环境下执行性能更好。

### 36.String为什么要设计成不可变的✔❤❗

保证数据的完整性、线程安全性、缓存的利用、安全性、效率优化

1. **保护数据的完整性**：

   不可变性确保了字符串对象的内容不会被修改。这是因为字符串被广泛用作映射关键字、缓存哈希码和网络传输中的标识符等，若可变，可能会导致数据的不一致性。

2. **线程安全性**：

   由于 String 对象的不可变性，多个线程可以共享同一个字符串对象，而无需担心静态条件和并发修改问题。这样简化了在多线程环境下对字符串的使用和处理，提高了线程安全性。

3. **缓存的利用**：

   由于 String 的不可变性，字符串对象可以被缓存，以便在需要时重复使用。例如，Java 中的字符串常量池就可以通过缓存相同的字符串值来提高内存利用率和性能。

4. **安全性**：

   在 Java 中，String 类作为参数传递给其他方法时，由于不可变性，你无需担心参数的值会被修改，从而增加了程序的可靠性和安全性。例如， 网络连接地址URL，文件路径path，反射机制所需要的String参数

5. **效率优化**：

   字符串不可变性允许进行一些额外的优化，加快了字符串的处理速度。例如，可以使用字符串的哈希值进行缓存、通过共享相同的字符串实例来节省内存，并且可以避免重复计算。

因为字符串不可变，所以可以用字符串池缓存，可以大大节省堆内存。而且还可以提前对hashcode进行缓存，更加高效

由于字符串是应用最广泛的数据结构，提高字符串的性能对提高整个应用程序的总体性能有相当大的影响。

### 37.字符型常量和字符串常量的区别❕

- 形式上：字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符；

- **含义上**：字符常量相当于一个整型值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置，相当于对象；

- 占内存上：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志) (注意: char 在Java中占两个字节)。


### 38.什么是字符串常量池❕

- **避免字符的重复创建，其维护了一块特殊的内存空间**
- 当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。

### 39.String str="aaa"与String str=new String("aaa")一样吗

- 使用`String b = new String("aaa");`，**程序会在堆内存中开辟一片新空间存放新对象**，**同时会将”aaa”字符串放入常量池**，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。 （**考虑常量池中是否有"aaa"**） 


### new String("abc")到底创建了几个对象✔

- 当使用`new`关键字创建字符串对象时，无论常量池中是否存在相同值的字符串，都会在堆内存中创建一个新的字符串对象。因此，即使常量池中已经存在字符串"abc"，这个语句也会创建一个新的堆对象，该对象包含与常量池中的字符串相同的值。

1. 在堆内存中创建了一个新的字符串对象，该对象包含值为"abc"的字符串。
2. 在常量池中存在一个字符串"abc"的对象。

因此，总共创建了两个对象：一个位于堆中，另一个位于常量池中。

总结：如果 "abc" 的这个字符串常量在常量池中不存在，需要创建：abc 这个字符串常量，new String 实例对象；如果 "abc" 字符串存在，只会创建一个 String 对象

### 40.String是最基本的数据类型吗

### 41.String有哪些特性❕

- 不变性（只读）
- **常量池优化**
- final（不能被继承，提高安全性）

### 42. 在使用 HashMap 的时候，用 String 做 key 有什么好处

- String 不可变，创建字符串时候（Hashcode值已经被缓存），不需要再次计算，相比于其他对象更快



## 包装类型

### 43. 包装类型是什么？基本类型和包装类型有什么区别

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| boolean      | Boolean   |
| short        | Short     |
| char         | Character |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |

在这八个类名中，除了 Integer 和 Character 类以后，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可。

- 包装类型可以为null，基本数据类型不可以
- **包装类型可用于泛型，而基本数据类型不可以**
- **基本类型比包装类型更高效**
- 自动装箱都是通过包装类的 `valueOf()` 方法来实现的.自动拆箱都是通过包装类对象的 `xxxValue()` 来实现的。

```java
System.out.println("基本数据类型<==>包装类");
//自动装箱 基本数据类型->包装类
Integer age1 = age;
//自动拆箱 包装类->基本数据类型
int age2 =age1;

System.out.println("基本数据类型、包装类==>String");
String s = String.valueOf(age); //基本数据类型->String
String s1 = String.valueOf(age1); //包装类->String

System.out.println("String==> 基本数据类型、包装类");
int age3 = Integer.valueOf(s); //String->基本数据类型
//int age3 = Integer.parseIns(s);
Integer age4 = Integer.parseInt(s); //String->包装类
//Integer age4 = Integer.valueOf(s); //String->包装类
```

###   44. 解释一下自动装箱和自动拆箱✔

- 自动装箱：基本数据类型-->对象，就是将基本数据类型自动转换成对应的包装类。
- 自动拆箱：对象 --> 基本数据类型，就是将包装类自动转换成对应的基本数据类型。

```java
Integer i = 10;  //自动装箱
int b = i;     //自动拆箱
```



### 45. int 和 Integer 有什么区别✔❗

关键点：

1. 堆栈存储基础数据类型与对象
2. 值比对的时候注意java的自动拆箱
3. Integer 值大小在 -128到127之内 使用IntegerCache

区别：

- 数据类型

  Integer是int的包装类，int则是java的一种基本的数据类型；

- Integer变量必须实例化后才能使用；int变量不需要

- 本质

  Integer实际是对象的引用，当new一个Integer时，实际上生成一个指针指向对象，而int则直接存储数值

- 默认值

  Integer的默认值是null，而int的默认值是0。
  
- Integer存储在堆内存中，int类型是直接存储在栈空间

```java
public static void main(String[] args){
    Integer a = 211;//相当于Integer a = Integer.valueOf(211);
    Integer b = 211;//相当于Integer b = Integer.valueOf(211);
    //比较的是对象地址，不相等

    System.out.println(a == b);//false
}
```

### Java为什么设计封装类

Java本身是面向对象的语言，一切操作都是以对象作为基础。比如说集合里面存元素，也只支持Object类型，普通类型是无法通过集合来存储的

### 46. 两个new生成的Integer变量的对比  

- 永远不相等

### 47. Integer变量和int变量的对比  

### 48. 非new生成的Integer变量和new Integer()生成变量的对比 ❕

- 非new生成的对象指的是常量池中的对象
- new生成的对象指的是堆空间的的对象
- 内存地址不同，结果为**false**

### 49. 两个非new生成的Integer对象的对比✔❕

- 常量池【-128~127】
- **超出范围，会在堆空间中新建一个对象**

Integer是一个封装类型，对应的是一个int类型的包装，Integer对象类型对-128到127之间的数据做了一层缓存，也就是说如果Integer类型的目标值在-128到127之间，就之间从缓存中去获取Integer这样一个对象实例，并且返回，否则会创建应该新的Integer对象，这样做是减少频繁创建Integer带来的消耗，从而去提升性能，如果两个Integer类型在-128到127之间，用==判断，返回的结果则是true，否则是false。

### 为什么阿里巴巴强制要求使用包装类型定义属性❕

1. 默认值的问题

   使用基本数据类型定义属性的时候，如果没有给属性赋予初始值，会使用默认值

2. 拆箱问题

   一些场景下，如果使用基本数据类型定义属性，需要进行多次拆箱和装箱操作，会带来额外的性能开销和代码复杂度，使用包装类型可以避免这个问题，提高代码效率和可读性

3. java中泛型只能使用对象来存储

   如果要在泛型编程中使用基本类型，就必须使用对应的包装类型

4. 包装类型提供了基本类型不具备的方法属性，比如`hashCode()`，`equals()`，`toString()`等	
   

## 反射

###  50. 什么是反射✔

反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；

对于任意一个对象，都能够调用它的任意一个方法和属性；

这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。

### 51.反射机制的优缺点有哪些✔

- 优点：能够运行时动态获取类的实例，提高灵活性
  - 1、增加程序的灵活性，可以在运行的过程中动态对类进行修改和操作
  - 2、提高代码的复用率，比如动态代理，就是用到了反射来实现
  - 3、可以在运行时轻松获取任意一个类的方法、属性，并且还能通过反射进行动态调用

- 缺点：**性能较低，需要解析字节码，将内存中的对象进行解析**
  - 1、反射会涉及到动态类型的解析，所以无法对这些代码进行优化，导致性能要比非反射调用更低。
  - 2、使用反射以后，代码的可读性会下降
  - 3、反射可以绕过一些限制访问的属性或者方法，可能会导致破坏了代码本身的抽象性


### 52. 如何获取反射中的Class对象

- **`Class.forName("类名路径")`**

- `类名.class`

- `对象名.getClass()`

- 如果是基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象。

  eg:`Class intClass = Integer.TYPE;`

### 53. Java反射API有几类❕

- Class类
- Field类
- Method类
- Constructor类

### 54. 反射使用的步骤  ❕

1、获取目标类的Class对象（三种方式）

2、调用Class类中的方法

- `getFields()`：获取类的公共字段
- `getDeclaredFields()`：获取类的所有字段（包括私有字段）
- `getMethods()`：获取类的公共方法
- `getDeclaredMethods()`：获取类的所有方法（包括私有方法）

3、使用反射Api进行操作

- 实例化对象：调用Class对象的`newInstance()`方法
- 调用方法：使用Method对象的`invoke()`方法
- 访问字段：使用Field对象的`set()`和`get()`方法

### 55. 为什么引入反射概念？反射机制的应用有哪些

反射机制允许程序在运行时**获取和操作**其自身的信息，包括类、对象、属性、方法等

1、动态获取类和对象的信息

2、动态加载类和对象的方法

3、运行时注解处理：反射机制可以与注解配合使用，动态地读取类和方法上的注解信息，并根据注解信息做出相应的处理。这在很多框架和库中广泛应用，比如JUnit测试框架中的@Test注解，Spring框架中的依赖注入等。

4、动态代理：通过反射，可以在运行时生成代理对象，使得可以在不修改原有代码的情况下增加额外的处理逻辑。这在AOP编程中经常使用，可以实现诸如日志记录、性能监控等横切关注点的统一处理

- jdbc数据库连接、Spring框架的使用

### 56. 反射机制的原理是什么❤❗

1. 反射获取类实例
2. 根据Class对象实例获取Constructor对象
3. 使用Constructor对象的newInstance()方法获取反射类对象
4. 使用Class对象实例获取Method对象
5. 接着调用invoke()方法

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

class MyClass {
    private String message;

    public MyClass() {
        this.message = "Hello, World!";
    }

    public void printMessage() {
        System.out.println(message);
    }

    public void printMessage(String name) {
        System.out.println("Hello, " + name + "!");
    }
}

public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        // 获取Class对象实例
        Class<?> clazz = MyClass.class;

        // 根据Class对象实例获取Constructor对象
        Constructor<?> constructor = clazz.getConstructor();

        // 使用Constructor对象的newInstance()方法获取反射类对象
        Object obj = constructor.newInstance();

        // 根据Class对象实例获取Method对象
        Method printMessageMethod = clazz.getMethod("printMessage");
        Method printMessageWithNameMethod = clazz.getMethod("printMessage", String.class);

        // 调用invoke()方法
        printMessageMethod.invoke(obj);
        printMessageWithNameMethod.invoke(obj, "Alice");
    }
}
//在上面的示例中，首先通过MyClass.class获取了对应的Class对象实例。接着使用getConstructor()方法获取默认的构造函数的Constructor对象。然后可以使用newInstance()方法创建一个MyClass的实例对象。

//之后，通过getMethod()方法分别获取了printMessage()和printMessage(String)这两个方法的Method对象。最后，通过invoke()方法调用这两个方法，并传入对应的参数。

//运行上述代码，将会输出以下结果：

//Hello, World!
//Hello, Alice!
//这样就完成了通过反射获取类实例、构造函数和方法，并进行调用的过程。
```

## 泛型

### 57. Java中的泛型是什么✔❗

- 将类型参数化，其在**编译**时才确定具体的参数

> 在Java中，编译是指将源代码文件(.java)转换为可执行的字节码文件(.class)的过程，而运行则是指执行已编译的字节码文件。编译过程通常由编译器完成，Java中的编译器是javac。
>
> 在IntelliJ IDEA中，编译Java代码通常是自动完成的，当你保存文件时，IDEA会自动编译相应的Java文件。如果没有出现编译错误，你可以直接点击运行按钮来运行程序。如果有编译错误，则需要先解决这些错误才能成功运行程序。当程序成功运行后，你可以在控制台窗口中看到输出结果。

### 58. 使用泛型的好处是什么❕

- 类型安全

  在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全。

- 消除强制类型转换

  每次使用时都需要强制转换成想要的类型

- 潜在的性能收益

  - 由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改
  - 所有工作都在编译器中完成 
  - 编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已


泛型最⼤的好处是可以提⾼代码的复⽤性。 以List接⼜为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。

### 59.Java泛型的原理是什么 ? 什么是类型擦除❕

泛型是一种语法糖，泛型这种语法糖的基本原理是类型擦除。Java中的泛型基本上都是在编译器这个层次来实现的，也就是说：**泛型只存在于编译阶段，而不存在于运行阶段**。在编译后的 class 文件中，是没有泛型这个概念的。

类型擦除：使用泛型的时候加上的类型参数，编译器在编译的时候去掉类型参数。

### 60. 什么是泛型中的限定通配符和非限定通配符

对类型进⾏限制， 泛型中有两种限定通配符：

- 限定通配符
  - `<? extends T>`即类型必须为T类型或者T子类，表示类型的下界
  - `<? super T>`即类型必须为T类型或者T的父类
- 非限定通配符
  - eg`List<?>`

### 61.List<? extends T>和List<? supere T> 之间有什么区别 ✔

- `List<? extends T>`可以接受任何继承自T 的类型的List，
- `List<? super T>`可以接受任何T的父类构成的List

### 62.可以把 `List<String>`传递给一个接受` List<Object>`参数的方法吗✔

- 不可以，编译错误，真这样做的话会导致编译错误。因为`List<Object>`可以存储任何类型的对象包括String, Integer等等，而 `List<String>`却只能用来存储String。

```java
List<Object> objectList;
List<String> stringList;
objectList = stringList; //compilation error incompatible types
//------------------------------
List<String> stringList = new ArrayList<>();
List<Object> objectList = stringList; // 假设允许这种赋值

objectList.add(123); // 试图将 Integer 添加到一个实际上是 List<String> 的列表中

```

在上述代码中，如果我们成功将 `List<String>` 赋值给 `List<Object>`，然后向 `objectList` 中添加一个整数，这将导致类型不匹配的错误。因为实际上的 `objectList` 引用的是一个 `List<String>` 对象，而不是一个能够容纳任意类型对象的 `List<Object>`。

### 63.判断`ArrayList<String>`与`ArrayList<Integer>`是否相等✔

- 相等，Class类型都是`ArrayList.Class`
- **<font color=red>泛型只在编译期</font>**

## 序列化

### 64.Java序列化与反序列化是什么✔

- 序列化：将对象转换为字节序列

  就是说将对象转换为可传输格式的过程。 是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。

- 反序列化：将字节序列转换成对象，以便能够重新恢复对象的状态。


### 65.为什么需要序列化与反序列化

- 对内存中的对象进行持久化或网络传输

### 66.序列化实现的方式有哪些

- 实现`Serializable`接口或者`Externalizable`接口

### 实现序列化和反序列化为什么要实现Serializable接口✔❤

在Java中实现Serializable这个接口是为了**支持对象的序列化和反序列化操作**，Serializable是Java提供的一个标记接口，它没有定义任何方法，只是起到一个标记的作用，当一个类实现了Serializable接口的时候，**表明这个类的对象可以被序列化成字节流，或者从字节流反序列化还原成对象**。

之所以要对序列化对象实现Serializable这个接口，有以下原因

1、**可以确保只有那些被设计为可序列化的类的对象才能被序列化**，这是一种类型安全性的保障，防止对不可序列化对象进行序列化操作

2、**它规范了类的行为，表示该类的对象可以被序列化**，通过判断对象是否实现了Serializable这个接口，可以遵循该规范，确保对象的序列化操作是否是合法的。

### 67.什么是`serialVersionUID`

- 表明类的**不同版本间的兼容性**（反序列化）

### 68.为什么还要显示指定`serialVersionUID`的值✔

- 持久化（序列化、**反序列化**）

但是，**虚拟机是否允许反序列化**， 不仅取决于类路径和功能代码是否⼀致， ⼀个⾮常重要的⼀点是两个类的序列化 ID 是否⼀致， 即`serialVersionUID`要求⼀致。

在进⾏反序列化时， JVM会把传来的字节流中的`serialVersionUID`与本地相应实体类的`serialVersionUID`进⾏⽐较， 如果相同就认为是⼀致的， 可以进⾏反序列化， 否则就会出现序列化版本不⼀致的异常， 即是`InvalidCastException`。

基于以上原理， 如果我们⼀个类实现了Serializable接口， 但是没有定义`serialVersionUID`， 然后序列化。 在序列化之后， 由于某些原因， 我们对该类做了变更， 重新启动应⽤后， 我们相对之前序列化过的对象进⾏反序列化的话就会报错

### 69.`serialVersionUID`什么时候修改

### 70.Java序列化中如果有些字段不想进行序列化，怎么办

使用` transient  `修饰

### 71. 静态变量会被序列化吗

- 不会，序列化是针对**对象**而言的，静态变量。。

## 异常

### 72. Error 和 Exception 区别是什么✔

⼆者都是 Java异常处理的重要⼦类， 各⾃都包含⼤量⼦类。均继承自Throwable类。

- `Error`非程序异常，指编译或者系统性错误

  java运⾏环境内部错误或者硬件问题， 不能指望程序来处理这样的问题， 除了退出运⾏外别⽆选择， 它是Java虚拟机抛出的。如OOM

- `Exception`程序异常，由程序内部产生，又分为运行时异常和非运行时异常、
  
  表⽰程序需要捕捉、 需要处理的异常， 是由与程序设计的不完善⽽出现的问题， 程序必须处理的问题。
  
  - 运行时异常：编译通过，运行时错误
  - 非运行时异常：编译不通过，必须捕获或者抛出
  
- 常见异常
  - NullPointExceprion空指针异常
  - OutOfMemoryError内存异常
  - IOExceptionIO异常
  - FileNotFoundException文件找不到异常
  - ClassNotFoundException类找不到异常
  - ClassCastException类型转换异常
  
- 关键字特点
  - Try:可能发生的异常
  - Catch：异常类型，一旦其中一条捕获到异常，后面就不执行了,(先写子类异常，再写父类异常)
  - Finaly：通常情况下一定执行，如system.exit,等，前面终止的话finaly就不会执行了

### 73. 非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么✔

所谓受检查异常表示是在编译的时候，要强制检查的异常，这个异常需要通过 try/catch 来进行捕捉，或者通过 throws 抛出去，否则程序是无法通过编译的，而非受检查异常表示编译器可以不需要去强制检查异常，不需要去捕获。

Throw 有两个直接子类，一个是 error，一个是 exception，error表示的是程序底层或者硬件层面的一些错误，和程序本身没有什么关系，比如 OOM，不需要去检查，属于非受检查异常。而Exception 表示程序里的一些异常，是由于程序不严谨导致，比如 NullPointerException。

Exception 派生了两种异常，一种是 RuntimeException 和其他 Exception，其中 RuntimeException  是属于运行时异常，属于非受检异常，**所以除了 error，以及RuntimeException  的派生类以外，其他异常都是受检异常**

- 是否强制要求调用者必须处理此异常（强制要求，受检查异常；非强制要求，非受检查异常）
- 非受检查异常=运行时异常
- 受检查异常 = 非运行时异常（一般异常）

###  74. throw 和 throws 的区别是什么✔

- Throw （抛出异常）只能抛出一个具体的异常，将异常显示在当段代码
- Throws（声明异常） 可以抛出多个异常，抛给调用者，用来声明一个方法可能抛出的所有异常信息

### 75. NoClassDefFoundError 和 ClassNotFoundException 区别✔

- `NoClassDefFoundError`error类型异常

  这个异常表示在编译时存在对某个类的引用，但在运行时找不到该类的定义

- `ClassNotFoundException`exception类异常中的受检查异常（非运行时异常）

  这个异常表示在运行时试图使用 `Class.forName()` 或 `ClassLoader.loadClass()` 来加载类时，找不到对应名称的类

### 76. Java常见异常有哪些

### 77. try-catch-finally 中哪个部分可以省略

- `catch`
- `try`运行时异常
- `try+catch`运行时异常+普通异常

### finally块一定会执行吗

finally在两种情况下不会执行

- 程序没有进入到try语句块因为异常导致程序终止，这个问题主要是开发人员在编写代码的时候，异常捕获的范围不够
- 在try或者cache语句块中，执行了System.exit(O)语句，导致JVM直接退出

### 78. try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗

- 会执行，在return之前执行

### 79. JVM 是如何处理异常的

- 抛出异常：创建异常对象，并转交给JVM的过程

 ### 异常代码分析✔❕

**代码一**：

关键点：

1. 异常会阻断正常代码运行
2. finally 一定会执行

```java
public static void main(String[] args) {

    try {
        int i = 100 / 0;
        System.out.print(i);
    } catch (Exception e) {

        System.out.println(1);
        throw new RuntimeException();
    } finally {
        System.out.println(2);
    }
    System.out.println(3);
}
```

答： 1 2 异常

**代码二**：

关键点：

1. 在finally中return 后不再执行后续代码
2. catch中return 不影响finally的执行
3. try catch 后的finally一定会执行

```java
public static String output = " ";

public static void foo(int i) {
    try {
        if (i == 1) {
            throw new Exception();
        }
    } catch (Exception e) {
        output += "2";
        return;
    } finally {
        output += "3";
        return;
    }

    //output += "4"; //不注释无法运行，看关键点1
}

public static void main(String[] args) {
    foo(0);
    foo(1);
    System.out.println(output);
}
```

答：323

## IO

### 80. Java的IO 流分为几种

- 流的方向：输入流、输出流
- 实现方向：节点流、处理流
- 处理数据的单位：字节流、字符流

根据输入和输出的不同组合，可以得到四种基本的IO流类型：

- 字节输入流（`InputStream`）：从源读取字节数据。
- 字节输出流（`OutputStream`）：向目标写入字节数据。
- 字符输入流（`Reader`）：从源读取字符数据。
- 字符输出流（`Writer`）：向目标写入字符数据。

### 81. 字节流如何转为字符流✔

- `InputStreamReader  `是Reader的子类，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象。
- `OutputStreamWriter`是Writer的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流输出对象。

### 82. 字符流与字节流的区别

- 字符流只适用于纯文本格式（效率大于字节流）
- 字节流适用于所有文件格式

### 83. 什么是阻塞IO？什么是非阻塞IO✔

- IO读请求的两个阶段
  - 查看数据是否就绪
    - 没有就绪，一直等待，直到数据就绪（阻塞IO）
    
    - 没有就绪，返回一个标志信息，告知当前线程数据没有就绪（非阻塞IO）
    
      阻塞与非阻塞描述的是调用者的
    
      如A调用B：
    
      如果是阻塞，A在发出调用后，要一直等待，等着B返回结果。
    
      如果是非阻塞，A在发出调用后，不需要等待，可以去做自己的事情。
    
  - 进行数据拷贝

### 同步，异步 和 阻塞，非阻塞之间的区别✔

同步：指的是任务按照顺序依次执行，每个任务必须等待上一个任务完成后才能开始执行。在同步模式下，**任务之间存在依赖关系，后续任务必须等待前一任务完成后才能执行**。

异步：指的是任务可以独立于主线程按照预定的顺序进行执行，不需要等待上一个任务完成。在异步模式下，**任务之间相互独立，可以并发地执行**。

同步、异步，是描述被调用方的。

阻塞，非阻塞，是描述调用方的。

同步不一定阻塞，异步也不一定非阻塞。没有必然关系。

举个简单的例子，老张烧水。 1 老张把水壶放到火上，一直在水壶旁等着水开。（同步阻塞） 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 3 老张把响水壶放到火上，一直在水壶旁等着水开。（异步阻塞） 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）

1和2的区别是，调用方在得到返回之前所做的事情不一行。 1和3的区别是，被调用方对于烧水的处理不一样。

### 84. BIO、NIO、AIO的区别

- BIO：同步并阻塞
  - 一个连接一个线程
- NIO：同步并非阻塞
  - 一个请求一个线程
- AIO：异步并非阻塞
  - 一个有效请求一个线程

### 85. Java IO都有哪些设计模式❕

- 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作
- 装饰器模式：一种动态地往一个类中添加新的行为的设计模式

## 补充

### 深拷贝和浅拷贝✔

深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，**一种是基本数据类型一种是实例对象的引用**

- 浅拷贝是指，**只会拷贝基本数据类型的值，以及实例对象的引用地址**，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象
- 深拷贝是指，**即会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制**，**深拷贝出来的对象**，内部的属性指向的不是同一个对象

### Java SPI 是什么，有什么作用

Java SPI 是Java提供的一种接口的扩展机制，作用有以下两个

- 把标准定义和接口实现分离，在模块化开发中很好的实现了解耦
- 实现功能的扩展，更好的满足定制化的需求

### 在java的异常处理机制中，什么时候应该抛出异常，什么时候捕获异常✔

异常相当于一种提示，如果我们抛出异常，就相当于告诉上层方法，我抛了一个异常，我处理不了这个异常，交给你来处理，而对于上层方法来说，它也需要决定自己能不能处理这个异常，是否也需要交给它的上层。

所以我们在写一个方法时，我们需要考虑的就是，**本方法能否合理的处理该异常，如果处理不了就继续向上抛出异常，包括本方法中在调用另外一个方法时，发现出现了异常，如果这个异常应该由自己来处理，那就捕获该异常并进行处理。**

### 面向对象

- 面向对象中把某一类事物所共有的属性和行为抽象出来之后就形成了一个类，类的一个实际例子就叫对象
- 类是具有共同属性名称和行为的一组对象的抽象，而对象则是一个类的真实例子

### 什么是零拷贝

零拷贝就是指应用程序可以直接把磁盘的数据从内核层面之间传输给socket，而不需要经过应用程序所在的用户空间，零拷贝通过DMA技术，把文件内容复制到内核空间的Read Buffer，接着把包含数据位置和长度信息的文件描述加载到是Socket Buffer里面，DMA直接可以把数据从内核空间传递到网卡设备，在这个流程中，数据只需要经过两次拷贝，就发送到网卡里面，减少了两次CPU的上下文切换，对效率有非常大的提高

### 为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象

**这种舍入误差的主要原因是：**
**浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。
这就好像十进制无法精确地表示分数 1/3—样。
如果在数值计算中不允许有任何舍入误差， 就应该使用 BigDecimal类。**

### JDK动态代理为什么只能代理有接口的类✔

动态代理需要传入被动态代理的一个接口类，之所以要传入接口而不能传入类，还是取决于JDK动态代理的一个底层实现，JDK 动态代理会在程序的运行期间去动态生成一个代理类，**动态生成的代理类会去继承一个 java.lang.reflect.Proxy这样一个类，同时还会去实现被代理类的接口，在Java里面不支持多种继承，所以只能代理接口**。

### Java有几种拷贝方式，哪一种效率最高✔

1、使用java.io包下的库，使用FilelnputStream读取，再使用FileOutputStream写出

2、利用iava.nio包下的库，使用transferTo或transfFrom方法实现

3、Java标准类库本身已经提供了Files.copy的实现

对于文件拷贝效率，和操作系统和配置的情况有关系

### 有哪些设计模式

设计模式分为创建者模式、结构型模式和行为型模式

创建者模式是对对象过程的各种问题和解决方案的一个总结，包括各种工厂模式、单例模式、构建器模式、原型模式

结构性模式是针对软件设计的结构的一个总结，重点关注类、对象继承和组合方式的一个实践经验的一个总结，常见的结构型模式包括桥接模式、适配器模式、装饰器模式、代理模式、组合模式、外观模式、享元模式等等

行为型模式是从类或者对象之间的一个交互职责划分等角度的总结的一个模式，比较常见的行为型模式有策略模式、解释器模式、命令模式、观察者模式、迭代器模式、模板方法模式、访问模式等等

### 介绍下策略模式和观察者模式

策略模式和观察者模式都属于行为型模式

- **策略模式主要是用在根据上下文动态控制类的行为的一个场景**，一方面可以解决多个if..else判断带来的代码复杂性和维护性问题，另一方面，把类的不同行为进行封装，使得程序可以进行动态的扩展和替换，增加了程序的灵活性，比如像支付路由这样一个场景就可以使用策略模式去实现
- **观察者模式主要是用在一对多的对象依赖关系的一个处理过程，实现某一个对象状态变更之后的感知的场景**，一方面可以降低对象依赖关系的耦合度，弱化依赖关系，另一方面，通过这种状态通知机制，可以保证这些依赖对象之间的状态协同

### 在Java中实现单例模式有哪些方法

1. 通过双重检查锁方式

   是一种线程安全并且延迟实例化的方式，但是因为加锁，所以会有性能上的一个影响

2. 通过静态内部类方式

   也是一种延迟实例化方式，由于是静态内部类，所以只会在使用时加载一次，不存在线程安全问题

3. **通过枚举类的方式**

   既是线程安全，又能防止反序列化破坏线程安全的问题，但是多线程、克隆、反序列化、反射都有可能会造成单例破坏，通过枚举实现单例模式，能够阻止所有可能被破坏的一个情况

### 选择

某java web应用以jar的方式部署在linux服务器上,应用的文件名为app.jar，为实现在后台运行jar包，且关闭终端窗口不会停止应用，以下关于启动应用正确的命令是（）（5分）

A.java -jar app.jar

B.java -jar app.jar &

C.nohup java -jar app.jar

D.nohup java -jar app.jar &

答：D

### Git如何处理冲突

当在Git中进行代码合并（merge）或者代码重置（reset）操作时，可能会出现冲突（conflict）。冲突通常发生在两个或多个分支中对同一代码文件的相同部分进行了不同的修改。为解决这些冲突，可以按照以下步骤进行处理：

1. 执行合并操作后，如果出现冲突，Git会在冲突文件中标记出冲突的部分，类似于以下形式：

   ```
   Copy Code<<<<<<< HEAD
   // 当前分支的代码
   =======
   // 合并分支的代码
   >>>>>>> branch_name
   ```

2. 打开包含冲突的文件，查看冲突部分的代码。根据你的需求，选择保留某个分支的代码或者进行修改。

3. 根据需要，手动编辑冲突文件，将代码修改为想要的最终结果。你可以选择保留某个分支的代码，也可以将两者进行合并。

4. 在完成编辑后，保存文件并使用`git add`命令将修改的文件标记为已解决冲突。

5. 当所有冲突都解决完毕后，运行`git commit`命令来提交合并后的结果。

请注意，解决冲突是一个手动的过程，需要仔细审查冲突代码并确保最终结果正确。如果对解决冲突感到困惑，可以使用图形化

### Maven生命周期

Maven是一个流行的项目管理工具，它使用约定优于配置的原则来管理项目的构建、发布和依赖管理。在Maven中，构建过程被划分为不同的阶段，这些阶段被称为"生命周期"。Maven生命周期包括三个标准的构建生命周期：clean、default（或build）和site。

1. clean生命周期：
   - 这个生命周期负责清理项目，删除之前构建生成的文件。
   - 主要阶段包括pre-clean、clean和post-clean。
   - 例如，可以使用`mvn clean`命令来执行clean生命周期，从而清理目标目录中的所有生成文件。

2. default（或build）生命周期：
   - 这是Maven的主要生命周期，负责构建项目、生成可部署的输出。
   - 主要阶段包括validate、compile、test、package、verify、install和deploy。
   - 例如，运行`mvn install`将执行default生命周期，它会编译代码、运行测试、打包以及将项目安装到本地仓库中。

3. site生命周期：
   - 这个生命周期负责生成项目站点文档。
   - 主要阶段包括pre-site、site和post-site。
   - 例如，可以使用`mvn site`命令来执行site生命周期，从而生成项目站点文档。

通过使用这些生命周期，开发人员可以方便地执行项目构建、测试、清理和站点文档生成等操作。此外，Maven还允许用户扩展现有的生命周期并自定义构建过程，以满足特定项目的需求。

### 常见的HTTP状态码：

- 200（OK）：表示请求成功，并返回请求的内容。
- 201（Created）：表示成功创建了新资源。
- 204（No Content）：表示服务器成功处理了请求，但没有返回任何内容。
- 400（Bad Request）：表示客户端发送了一个无效的请求，服务器无法理解。
- 401（Unauthorized）：表示请求要求身份验证，客户端未提供有效的身份验证凭据。
- 403（Forbidden）：表示服务器拒绝了请求访问资源的权限。
- 404（Not Found）：表示请求的资源不存在。

### 其他前沿技术

关键点：

1. 加分项，经常出现在笔试题中，目的是快速了解你的知识宽度并且希望团队中能吸收外界的知识
2. 前沿的技术多数是业务创新，技术还是这几十年的积累
3. 平时多看书 多学习

答：

1. go语言（开发中间件，性能高）
2. 物联网 IoT 嵌入式开发 树莓派小车 摄像头
3. 低代码数据中台
4. jdk新特性，g1,zgc
5. 区块链
6. 容器化云原生与监控Prometheus + Grafana
7. java高性能游戏开发
8. DDD
9. 响应式编程与异步网络编程
10. 推荐系统
11. 高并发系统架构 nginx+lua
12. chatgpt
13. 量子计算 三进制实现 火箭回收技术 常温超导。。。



