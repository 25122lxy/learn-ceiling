# Java基础

## Java概述

### 1.Java语言有哪些特点？

- 面向对象（封装、继承、多态）
- **平台无关性（跨平台、一次编写，到处运行）**
- **可靠性、安全性**
- 支持多线程
- 支持网络编程
- **编译与解释共存**

### 2.Java和C++有什么关系，它们有什么区别？

- 面向对象
- 指针
- 继承
- 内存回收
- 操作符重载
- 字符串变量（String）
- goto。。。

### 3.JVM、JRE和JDK的关系是什么？✔

- JDK=JRE+开发工具集（例如javac编译工具等【将java代码编译成字节码】）
- JRE=JVM【执行Java字节码】+JavaSE标准类库

### 4.什么是字节码？采用字节码的好处是什么？✔

编译器（javac）将Java源文件（.java）文件编译成字节码文件（.class）

- **编译生成固定格式的字节码（.class文件）供JVM使用**
- 一次编译，到处运行（实现了跨平台）
- 提高了代码执行的性能

### 5.OracleJDK和OpenJDK的区别是什么？

- 三年发布一次
- 不能完全开源
- 更稳定
- 性能更好
- 。。。

## 基础语法

### 6.Java有哪些数据类型？✔

- 基本数据类型
  - 数值型
    - 整型
      - 字节型`byte`1
      - 短整型`short`2
      - 整型`int`4
      - 长整型`long`8
    - 浮点型
      - 单精度`float`4
      - 双精度`double`8
  - 字符型`char`2
  - 布尔型`Boolean`1
- 引用数据类型
  - 类 `class`
  - 接口 `interface`
  - 数组 `[]`

### 7.Switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？

- java5之前byte、short、char、int
- java5开始+enum
- java7开始+String
- 长整型(long)在目前所有的版本中都是不可以的。

### 8.访问修饰符public、private、protected、以及不写（默认）时的区别？

- `private`当前类
- `default`当前类、同一包（+同一包子类）
- `protected`当前类、同一包（+同一包子类）、不同包的子类
- `public`当前类、同一包（+同一包子类）、不同包的子类、同一工程	

### 9.break，continue，return的区别及作用？✔

- break：结束当前循环体
- continue：结束正在执行的循环体，进入下一个循环条件
- return：结束当前的方法，直接返回

### 10.final、finally、finalize的区别？✔

- final
  - 修饰类、方法、变量
- finally
  - 异常处理的一部分，通常情况一定执行
- finalize  
  - 是`java.lang.Object`里定义的方法，在gc启动，垃圾回收时调用

## 关键字

### 11.为什么要用static关键字？

- 只想为特定域分配单一存储空间，不考虑要创建多少对象或者说根本不创建任何对象，再就是我们想在没有创建对象的情况下也想调用方法

### 12."static"关键字是什么意思？Java中是否可以覆盖（override）一个private或者是static的方法？

- **表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问**
- 不可以覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

### 13.是否可以在static环境中访问非static变量？

- 不可以，非static变量可能还没有创建出来

### 14.static静态方法能不能引用非静态资源？

- 不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它

### 15.static静态方法里面能不能引用静态资源？

- 可以

### 16.非静态方法里面能不能引用静态资源？

- 可以

### 17.Static静态代码块、构造代码块、普通代码块、构造函数的执行顺序是什么？	

- 基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块
- 代码块执行顺序**静态代码块——> 构造代码块 ——> 构造函数——> 普通代码块** 
- 继承中代码块执行顺序：**父类静态块——>子类静态块——>父类代码块——>父类构造器——>子类代码块——>子类构造器**

## 面向对象

### 18.面向对象和面向过程的区别？✔

1. 面向对象

  - 简单来说，面向对象的开发范式中，程序员将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。

    就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。

  - 优点：易维护、易复用

  - 缺点：性能比面向过程低

2. 面向过程
  - 面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。最典型的面向过程的编程语言就是C语言。

    简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。

  - 优点：性能比面向对象高

  - 缺点：没有面向对象易维护、易复用

### 19.讲讲面向对象三大特征✔

1. 封装

   - 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
   - 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。**在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。**

2. 继承

   - 继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

     通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。

3. 多态

   - 父类中定义的属性和方法被子类继承之后，具有不同的行为，或者说在各个子类中具有不同的含义的行为
   - 多态机制使具有不同内部结构的对象可以共享相同的外部接口。

### 20.Java语言是如何实现多态的？

- 编译时多态
  - 重载。。
- 运行时多态

**我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。**

Java实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。

- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。

```java
public class Parent{
    
    public void call(){
        sout("im Parent");
    }
}

public class Son extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout("im Son");
    }
}

public class Daughter extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout("im Daughter");
    }
}

public class Test{
    
    public static void main(String[] args){
        Parent p = new Son(); //3.父类的引用指向子类的对象
        Parent p1 = new Daughter(); //3.父类的引用指向子类的对象
    }
}
/**
 *这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call调用的是Daughter的实现。
 *
 *有人说，你自己定义的时候不就已经知道p是son，p1是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的。
 *
 *比如Spring 中的IOC出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。
 */
```



### 21.重载（Overload）和重写（Override）的区别是什么✔

- 重载
  - 在同一个类中，同一个方法名，参数个数不同，参数类型不同，顺序不同
  
    就是说在同一个类中，多个函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。
  
- 重写
  - 子类继承父类后，可以对分类中同名同参数的方法，进行覆盖操作
  - 返回值范围小于等于父类，抛出异常范围小于等于父类，**访问修饰符范围大于等于父类**；如果父类方法访问修饰符为private则子类就不能重写该方法

### 22.重载的方法能否根据返回值类型进行区分？

- 调用时不指定类型信息

### 23.构造器（constructor）是否可被重写（override）？

- 不能被继承，因此不能被重写

### 24.抽象类和接口的区别是什么✔

- 内部方法细节
  - 抽象类可以存在普通方法函数
  - 接口中只能存在`public static final`方法，不能写业务逻辑
- **成员变量类型**
  - 抽象类中成员变量可以是各种类型，
  - 接口中的成员变量只能是`public static final`
- 继承、实现
  - 抽象类只能继承一个
  - 接口可以实现多个
- **接口中不能含有静态代码块和静态方法，而抽象类可以有静态代码块和静态方法；**

### 25.抽象类能使用final修饰吗？

- 不能，因为需要用其他类进行继承

### 26.java创建对象有哪几种方式？

- new 创建新对象
- 通过反射机制
- 采用 clone 机制
- 通过序列化机制

### 27.什么是不可变对象?好处是什么?

- 任何修改都会创建一个新的对象（如：String、Integer）
- 线程安全

### 28.值传递和引用传递的区别的什么？为什么说Java中只有值传递✔

- 值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。

- 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。

> 举例：你有一把钥匙，当你的朋友想要去你家的时候，如果你`直接`把你的钥匙给他了，这就是引用传递。
>
> 这种情况下，如果他对这把钥匙做了什么事情，比如他在钥匙上刻下了自己名字，那么这把钥匙还给你的时候，你自己的钥匙上也会多出他刻的名字。
>
> 你有一把钥匙，当你的朋友想要去你家的时候，你`复刻`了一把新钥匙给他，自己的还在自己手里，这就是值传递。
>
> 这种情况下，他对这把钥匙做什么都不会影响你手里的这把钥匙。

**值传递和引用传递最大的区别是传递的过程中有没有复制出一个副本来，如果是传递副本，那就是值传递，否则就是引用传递。**

在Java中，其实是通过值传递实现的参数传递，只不过对于Java对象的传递，传递的内容是对象的引用

### 29.能否创建一个包含可变对象的不可变对象?	

- `final Person[] persons = new Persion[]{}`

## 对象相等判断

### 30.==和equals区别是什么✔

- `==`：如果是基本数据类型，比较是值，如果是引用类型，比较的是引用地址
- `equals`：具体看各个类重写equals方法之后的比较逻辑，比如String类，虽然是引用类型，但是String类中重写了equals（）方法，方法内部比较的是字符串中的各个字符是否全部相等
  - 没有重写，相当于“==”
  - 重写后，一般比较对象内容

### 31.介绍下hashCode()？

- hashCode()->哈希值(散列码)->确定该对象在哈希表中的索引位置

### 32.为什么要有hashCode?

- 比较对象是否重复
- 比较对象时候，大大减少了equals()的次数，相应就大大提高了执行速度
- 【先比较hashCode，在比较equals()】

### 33.hashCode(),equals()两种方法是什么关系✔

- 注意
  - 若重写`equals()`方法，必须重写`hashcode()` 方法，确保`equals()`方法判断结果为true的两个对象具备相等的`hashcode()`方法返回值【如果两个对象相同，那么他们的hashcode应该相同】
  - 如果两个对象不相同，他们的hashcode可能相同

### 34.为什么重写equals方法必须重写hashcode方法？

## String相关

### 35.String,StringBuffer,StringBuilder的区别是什么✔

- String不可变的字符序列，会开辟一个新的地址修改，**底层char[]**
- StringBuffer直接在原地址修改，线程安全，**效率不高, 底层char[]**
- StringBuilder直接在原地址修改，线程不安全，**效率高，底层char[]**

### 36.String为什么要设计成不可变的✔

设计考虑、效率优化、安全性

- 便于实现字符串池（String pool）【缓存】

- 使多线程安全（写操作）

- **避免安全问题（ 网络连接地址URL，文件路径path，反射机制 所需要的String参数** **）**

- **加快字符串处理速度（创建对象时，就缓存了hashcode的值，不需要重新计算）**【Hashcode缓存】

- 前面提到了的字符串池、hashcode缓存等，都是提升性能的提现。【性能】

  因为字符串不可变，所以可以用字符串池缓存，可以大大节省堆内存。而且还可以提前对hashcode进行缓存，更加高效

  由于字符串是应用最广泛的数据结构，提高字符串的性能对提高整个应用程序的总体性能有相当大的影响。

### 37.字符型常量和字符串常量的区别？

- 形式上：字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符；

- 含义上：字符常量相当于一个整型值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置，相当于对象；

- 占内存上：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志) (注意: char 在Java中占两个字节)。


### 38.什么是字符串常量池

- 避免字符的重复创建，其维护了一块特殊的内存空间
- 当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。

### 39.String str="aaa"与String str=new String("aaa")一样吗？new String(“aaa”);创建了几个字符串对象?

- 使用`String b = new String("aaa");`，**程序会在堆内存中开辟一片新空间存放新对象**，**同时会将”aaa”字符串放入常量池**，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。 （**考虑常量池中是否有"aaa"**） 

  当使用`new`关键字创建字符串对象时，无论常量池中是否存在相同值的字符串，都会在堆内存中创建一个新的字符串对象。因此，即使常量池中已经存在字符串"aaa"，这个语句也会创建一个新的堆对象，该对象包含与常量池中的字符串相同的值。

1. 在堆内存中创建了一个新的字符串对象，该对象包含值为"aaa"的字符串。
2. 在常量池中存在一个字符串"aaa"的对象。

因此，总共创建了两个对象：一个位于堆中，另一个位于常量池中。

### 40.String是最基本的数据类型吗?

### 41.String有哪些特性?  

- 不变性（只读）
- 常量池优化
- final（不能被继承，提高安全性）

### 42. 在使用 HashMap 的时候，用 String 做 key 有什么好处？  

- String 不可变，创建字符串时候（Hashcode值已经被缓存），不需要再次计算，相比于其他对象更快

## 包装类型

### 43. 包装类型是什么？基本类型和包装类型有什么区别？  

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| boolean      | Boolean   |
| short        | Short     |
| char         | Character |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |

在这八个类名中，除了 Integer 和 Character 类以后，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可。

- 包装类型可以为null，基本数据类型不可以
- **包装类型可用于泛型，而基本数据类型不可以**
- **基本类型比包装类型更高效**
- 自动装箱都是通过包装类的 `valueOf()` 方法来实现的.自动拆箱都是通过包装类对象的 `xxxValue()` 来实现的。

```java
System.out.println("基本数据类型<==>包装类");
//自动装箱 基本数据类型->包装类
Integer age1 = age;
//自动拆箱 包装类->基本数据类型
int age2 =age1;

System.out.println("基本数据类型、包装类==>String");
String s = String.valueOf(age); //基本数据类型->String
String s1 = String.valueOf(age1); //包装类->String

System.out.println("String==> 基本数据类型、包装类");
int age3 = Integer.valueOf(s); //String->基本数据类型
//int age3 = Integer.parseIns(s);
Integer age4 = Integer.parseInt(s); //String->包装类
//Integer age4 = Integer.valueOf(s); //String->包装类
```

###   44. 解释一下自动装箱和自动拆箱？✔

- 自动装箱：基本数据类型-->对象，就是将基本数据类型自动转换成对应的包装类。
- 自动拆箱：对象 --> 基本数据类型，就是将包装类自动转换成对应的基本数据类型。

```java
Integer i = 10;  //自动装箱
int b = i;     //自动拆箱
```



### 45. int 和 Integer 有什么区别?  

- 数据类型
- 使用
- **本质（**Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值**）**
- 默认值

### 46. 两个new生成的Integer变量的对比  

- 永远不相等

### 47. Integer变量和int变量的对比  

### 48. 非new生成的Integer变量和new Integer()生成变量的对比  

- 非new生成的对象指的是常量池中的对象
- new生成的对象指的是堆空间的的对象
- 内存地址不同，结果为**false**

### 49. 两个非new生成的Integer对象的对比  

- 常量池【-128~127】
- 超出范围，会在堆空间中新建一个对象

## 反射

###  50. 什么是反射✔

反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。

### 51.反射机制的优缺点有哪些？  

- 优点：能够运行时动态获取类的实例，提高灵活性
- 缺点：性能较低，需要解析字节码，将内存中的对象进行解析

### 52. 如何获取反射中的Class对象？  

- `Class.forName("类名路径")`
- `类名.class`
- `对象名.getClass()`
- 如果是基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象。

### 53. Java反射API有几类？  

- Class类
- Field类
- Method类
- Constructor类

### 54. 反射使用的步骤  

- 获取想要操作的类的Class对象（核心）
- 调用Class类中的方法（使用）
- 使用反射Api操作

### 55. 为什么引入反射概念？反射机制的应用有哪些？  

- 应用
  - 通过外部类的全路径名创建对象，并使用、扩展
  - 枚举出类的全部成员，包括构造函数、属性、方法
  - 测试，使用反射api访问类的私有成员
  - jdbc数据库连接、Spring框架的使用

### 56. 反射机制的原理是什么？  

- 反射获取类实例
- 根据Class对象实例获取Constructor对象
- 使用Constructor对象的newInstance()方法获取反射类对象
- 使用Class对象实例获取Method对象
- 接着调用invoke()方法

## 泛型

### 57. Java中的泛型是什么 ?  

- 将类型参数化，其在**编译**时才确定具体的参数

### 58. 使用泛型的好处是什么?  

- 类型安全
- 消除强制类型转换
- 潜在的性能收益

泛型最⼤的好处是可以提⾼代码的复⽤性。 以List接⼜为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。

### 59.Java泛型的原理是什么 ? 什么是类型擦除 ?

泛型是一种语法糖，泛型这种语法糖的基本原理是类型擦除。Java中的泛型基本上都是在编译器这个层次来实现的，也就是说：**泛型只存在于编译阶段，而不存在于运行阶段。**在编译后的 class 文件中，是没有泛型这个概念的。

类型擦除：使用泛型的时候加上的类型参数，编译器在编译的时候去掉类型参数。

### 60. 什么是泛型中的限定通配符和非限定通配符 ?  

对类型进⾏限制， 泛型中有两种限定通配符：

- 限定通配符
  - `<? extends T>`即类型必须为T类型或者T子类 表示类型的下界
  - `<? super T>`即类型必须为T类型或者T的父类
- 非限定通配符
  - eg`List<?>`

### 61.List<? extends T>和List<? supere T> 之间有什么区别 ✔

- `List<? extends T>`可以接受任何继承自T 的类型的List，
- `List<? super T>`可以接受任何T的父类构成的List

### 62.可以把 `List<String>`传递给一个接受` List<Object>`参数的方法吗？(见上面说明)

- 不可以，编译错误

### 63.判断`ArrayList<String>`与`ArrayList<Integer>`是否相等✔

- 相等，Class类型都是`ArrayList.Class`
- 泛型只在编译期

## 序列化

### 64.Java序列化与反序列化是什么✔

- 序列化：将对象转换为字节序列

  就是说将对象转换为可传输格式的过程。 是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。

- 反序列化：将字节序列转换成对象

  就是说将对象转换为可传输格式的过程。 

### 65.为什么需要序列化与反序列化

- 对内存中的对象进行持久化或网络传输

### 66.序列化实现的方式有哪些？

- 实现`Serializable`接口或者`Externalizable`接口

### 实现序列化和反序列化为什么要实现Serializable接口✔

在Java中实现Serializable这个接口是为了**支持对象的序列化和反序列化操作**，Serializable是Java提供的的一个标记接口，它没有定义任何方法，只是起到一个标记的作用，当一个类实现了Serializable接口的时候，**表明这个类的对象可以被序列化成字节流，或者从字节流反序列化还原成对象**。

之所以要对序列化对象实现Serializable这个接口，有以下原因

1、**可以确保只有那些被设计为可序列化的类的对象才能被序列化**，这是一种类型安全性的保障，防止对不可序列化对象进行序列化操作

2、**它规范了类的行为，表示该类的对象可以被序列化**，通过判断对象是否实现了Serializable这个接口，可以遵循该规范，确保对象的序列化操作是否是合法的。

### 67.什么是`serialVersionUID`？

- 表明类的不同版本间的兼容性（反序列化）

### 68.为什么还要显示指定`serialVersionUID`的值✔

- 持久化（序列化、**反序列化**）

但是， 虚拟机是否允许反序列化， 不仅取决于类路径和功能代码是否⼀致， ⼀个⾮常重要的⼀点是两个类的序列化 ID 是否⼀致， 即`serialVersionUID`要求⼀致。

在进⾏反序列化时， JVM会把传来的字节流中的`serialVersionUID`与本地相应实体类的`serialVersionUID`进⾏⽐较， 如果相同就认为是⼀致的， 可以进⾏反序列化， 否则就会出现序列化版本不⼀致的异常， 即是`InvalidCastException`。

基于以上原理， 如果我们⼀个类实现了Serializable接口， 但是没有定义`serialVersionUID`， 然后序列化。 在序列化之后， 由于某些原因， 我们对该类做了变更， 重新启动应⽤后， 我们相对之前序列化过的对象进⾏反序列化的话就会报错

### 69.`serialVersionUID`什么时候修改？

### 70.Java序列化中如果有些字段不想进行序列化，怎么办？

使用` transient  `修饰

### 71. 静态变量会被序列化吗?  

- 不会，序列化是针对**对象**而言的，静态变量。。

## 异常

### 72. Error 和 Exception 区别是什么✔

⼆者都是 Java异常处理的重要⼦类， 各⾃都包含⼤量⼦类。均继承自Throwable类。

- `Error`非程序异常，指编译或者系统性错误

  java运⾏环境内部错误或者硬件问题， 不能指望程序来处理这样的问题， 除了退出运⾏外别⽆选择， 它是Java虚拟机抛出的。

- `Exception`程序异常，由程序内部产生，又分为运行时异常和非运行时异常、
  
  表⽰程序需要捕捉、 需要处理的常， 是由与程序设计的不完善⽽出现的问题， 程序必须处理的问题。
  
  - 运行时异常：编译通过，运行时错误
  - 非运行时异常：编译不通过，必须捕获或者抛出
  
- 常见异常
  - NullPointExceprion空指针异常
  - OutOfMemoryError内存异常
  - IOExceptionIO异常
  - FileNotFoundException文件找不到异常
  - ClassNotFoundException类找不到异常
  - ClassCastException类型转换异常
  
- 关键字特点
  - Try:可能发生的异常
  - Catch：异常类型，一旦其中一条捕获到异常，后面就不执行了,(先写子类异常，再写父类异常)
  - Finaly：通常情况下一定执行，如system.exit,等，前面终止的话finaly就不会执行了

### 73. 非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么✔

- 是否强制要求调用者必须处理此异常（强制要求，受检查异常；非强制要求，非受检查异常）
- 非受检查异常=运行时异常
- 受检查异常 = 非运行时异常（一般异常）

###  74. throw 和 throws 的区别是什么✔

- Throw （抛出异常）只能抛出一个具体的异常，将异常显示在当段代码
- Throws（声明异常） 可以抛出多个异常，抛给调用者，用来声明一个方法可能抛出的所有异常信息

### 75. NoClassDefFoundError 和 ClassNotFoundException 区别？  ✔

- `NoClassDefFoundError`error类型异常
- `ClassNotFoundException`exception类异常中的受检查异常（非运行时异常）

### 76. Java常见异常有哪些？  

### 77. try-catch-finally 中哪个部分可以省略？  

- `catch`
- `try`运行时异常
- `try+catch`运行时异常+普通异常

### 78. try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？  

- 会执行，在return之前执行

### 79. JVM 是如何处理异常的？  

- 抛出异常：创建异常对象，并转交给JVM的过程

## IO

### 80. Java的IO 流分为几种？ 

- 流的方向：输入流、输出流
- 实现方向：节点流、处理流
- 处理数据的单位：字节流、字符流

### 81. 字节流如何转为字符流？✔

- `InputStreamReader  `是Reader的子类，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象。
- `OutputStreamWriter`是Writer的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流输出对象。

### 82. 字符流与字节流的区别？  

- 字符流只适用于纯文本格式（效率大于字节流）
- 字节流适用于所有文件格式

### 83. 什么是阻塞IO？什么是非阻塞IO？  

- IO读请求的两个阶段
  - 查看数据是否就绪
    - 没有就绪，一直等待，直到数据就绪（阻塞IO）
    
    - 没有就绪，返回一个标志信息，告知当前线程数据没有就绪（非阻塞IO）
    
      阻塞与非阻塞描述的是调用者的
    
      如A调用B：
    
      如果是阻塞，A在发出调用后，要一直等待，等着B返回结果。
    
      如果是非阻塞，A在发出调用后，不需要等待，可以去做自己的事情。
    
  - 进行数据拷贝

### 同步，异步 和 阻塞，非阻塞之间的区别✔

同步、异步，是描述被调用方的。

阻塞，非阻塞，是描述调用方的。

同步不一定阻塞，异步也不一定非阻塞。没有必然关系。

举个简单的例子，老张烧水。 1 老张把水壶放到火上，一直在水壶旁等着水开。（同步阻塞） 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 3 老张把响水壶放到火上，一直在水壶旁等着水开。（异步阻塞） 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）

1和2的区别是，调用方在得到返回之前所做的事情不一行。 1和3的区别是，被调用方对于烧水的处理不一样。

### 84. BIO、NIO、AIO的区别？  

- BIO：同步并阻塞
  - 一个连接一个线程
- NIO：同步并非阻塞
  - 一个请求一个线程
- AIO：异步并非阻塞
  - 一个有效请求一个线程

### 85. Java IO都有哪些设计模式？  

- 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作
- 装饰器模式：一种动态地往一个类中添加新的行为的设计模式

## 补充

### 86.深拷贝和浅拷贝✔

深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型一种是实例对象的引用

- 浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象
- 深拷贝是指，即会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象

### 87.在java的异常处理机制中，什么时候应该抛出异常，什么时候捕获异常？✔

异常相当于一种提示，如果我们抛出异常，就相当于告诉上层方法，我抛了一个异常，我处理不了这个异常，交给你来处理，而对于上层方法来说，它也需要决定自己能不能处理这个异常，是否也需要交给它的上层。
所以我们在写一个方法时，我们需要考虑的就是，**本方法能否合理的处理该异常，如果处理不了就继续向上抛出异常，包括本方法中在调用另外一个方法时，发现出现了异常，如果这个异常应该由自己来处理，那就捕获该异常并进行处理。**

### 88.面向对象

- 面向对象中把某一类事物所共有的属性和行为抽象出来之后就形成了一个类，类的一个实际例子就叫对象
- 类是具有共同属性名称和行为的一组对象的抽象，而对象则是一个类的真实例子

### 89.为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？

**这种舍入误差的主要原因是：**
**浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。
这就好像十进制无法精确地表示分数 1/3—样。
如果在数值计算中不允许有任何舍入误差， 就应该使用 BigDecimal类。**



### 常见的HTTP状态码：

- 200（OK）：表示请求成功，并返回请求的内容。
- 201（Created）：表示成功创建了新资源。
- 204（No Content）：表示服务器成功处理了请求，但没有返回任何内容。
- 400（Bad Request）：表示客户端发送了一个无效的请求，服务器无法理解。
- 401（Unauthorized）：表示请求要求身份验证，客户端未提供有效的身份验证凭据。
- 403（Forbidden）：表示服务器拒绝了请求访问资源的权限。
- 404（Not Found）：表示请求的资源不存在。







